(self.webpackChunkchess_clock = self.webpackChunkchess_clock || []).push([[179], { 255: ro => { function xi(so) { return Promise.resolve().then(() => { var Hn = new Error("Cannot find module '" + so + "'"); throw Hn.code = "MODULE_NOT_FOUND", Hn }) } xi.keys = () => [], xi.resolve = xi, xi.id = 255, ro.exports = xi }, 565: (ro, xi, so) => { "use strict"; function Hn(n) { return "function" == typeof n } let Iu = !1; const yn = { Promise: void 0, set useDeprecatedSynchronousErrorHandling(n) { if (n) { const t = new Error; console.warn("DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n" + t.stack) } else Iu && console.log("RxJS: Back to a better error behavior. Thank you. <3"); Iu = n }, get useDeprecatedSynchronousErrorHandling() { return Iu } }; function Hr(n) { setTimeout(() => { throw n }, 0) } const Va = { closed: !0, next(n) { }, error(n) { if (yn.useDeprecatedSynchronousErrorHandling) throw n; Hr(n) }, complete() { } }, jr = Array.isArray || (n => n && "number" == typeof n.length); function Fu(n) { return null !== n && "object" == typeof n } const Ba = (() => { function n(t) { return Error.call(this), this.message = t ? `${t.length} errors occurred during unsubscription:\n${t.map((e, i) => `${i + 1}) ${e.toString()}`).join("\n  ")}` : "", this.name = "UnsubscriptionError", this.errors = t, this } return n.prototype = Object.create(Error.prototype), n })(); class he { constructor(t) { this.closed = !1, this._parentOrParents = null, this._subscriptions = null, t && (this._ctorUnsubscribe = !0, this._unsubscribe = t) } unsubscribe() { let t; if (this.closed) return; let { _parentOrParents: e, _ctorUnsubscribe: i, _unsubscribe: r, _subscriptions: s } = this; if (this.closed = !0, this._parentOrParents = null, this._subscriptions = null, e instanceof he) e.remove(this); else if (null !== e) for (let o = 0; o < e.length; ++o)e[o].remove(this); if (Hn(r)) { i && (this._unsubscribe = void 0); try { r.call(this) } catch (o) { t = o instanceof Ba ? Og(o.errors) : [o] } } if (jr(s)) { let o = -1, a = s.length; for (; ++o < a;) { const l = s[o]; if (Fu(l)) try { l.unsubscribe() } catch (c) { t = t || [], c instanceof Ba ? t = t.concat(Og(c.errors)) : t.push(c) } } } if (t) throw new Ba(t) } add(t) { let e = t; if (!t) return he.EMPTY; switch (typeof t) { case "function": e = new he(t); case "object": if (e === this || e.closed || "function" != typeof e.unsubscribe) return e; if (this.closed) return e.unsubscribe(), e; if (!(e instanceof he)) { const s = e; e = new he, e._subscriptions = [s] } break; default: throw new Error("unrecognized teardown " + t + " added to Subscription.") }let { _parentOrParents: i } = e; if (null === i) e._parentOrParents = this; else if (i instanceof he) { if (i === this) return e; e._parentOrParents = [i, this] } else { if (-1 !== i.indexOf(this)) return e; i.push(this) } const r = this._subscriptions; return null === r ? this._subscriptions = [e] : r.push(e), e } remove(t) { const e = this._subscriptions; if (e) { const i = e.indexOf(t); -1 !== i && e.splice(i, 1) } } } var n; function Og(n) { return n.reduce((t, e) => t.concat(e instanceof Ba ? e.errors : e), []) } he.EMPTY = ((n = new he).closed = !0, n); const Ha = "function" == typeof Symbol ? Symbol("rxSubscriber") : "@@rxSubscriber_" + Math.random(); class Ie extends he { constructor(t, e, i) { switch (super(), this.syncErrorValue = null, this.syncErrorThrown = !1, this.syncErrorThrowable = !1, this.isStopped = !1, arguments.length) { case 0: this.destination = Va; break; case 1: if (!t) { this.destination = Va; break } if ("object" == typeof t) { t instanceof Ie ? (this.syncErrorThrowable = t.syncErrorThrowable, this.destination = t, t.add(this)) : (this.syncErrorThrowable = !0, this.destination = new Ng(this, t)); break } default: this.syncErrorThrowable = !0, this.destination = new Ng(this, t, e, i) } } [Ha]() { return this } static create(t, e, i) { const r = new Ie(t, e, i); return r.syncErrorThrowable = !1, r } next(t) { this.isStopped || this._next(t) } error(t) { this.isStopped || (this.isStopped = !0, this._error(t)) } complete() { this.isStopped || (this.isStopped = !0, this._complete()) } unsubscribe() { this.closed || (this.isStopped = !0, super.unsubscribe()) } _next(t) { this.destination.next(t) } _error(t) { this.destination.error(t), this.unsubscribe() } _complete() { this.destination.complete(), this.unsubscribe() } _unsubscribeAndRecycle() { const { _parentOrParents: t } = this; return this._parentOrParents = null, this.unsubscribe(), this.closed = !1, this.isStopped = !1, this._parentOrParents = t, this } } class Ng extends Ie { constructor(t, e, i, r) { super(), this._parentSubscriber = t; let s, o = this; Hn(e) ? s = e : e && (s = e.next, i = e.error, r = e.complete, e !== Va && (o = Object.create(e), Hn(o.unsubscribe) && this.add(o.unsubscribe.bind(o)), o.unsubscribe = this.unsubscribe.bind(this))), this._context = o, this._next = s, this._error = i, this._complete = r } next(t) { if (!this.isStopped && this._next) { const { _parentSubscriber: e } = this; yn.useDeprecatedSynchronousErrorHandling && e.syncErrorThrowable ? this.__tryOrSetError(e, this._next, t) && this.unsubscribe() : this.__tryOrUnsub(this._next, t) } } error(t) { if (!this.isStopped) { const { _parentSubscriber: e } = this, { useDeprecatedSynchronousErrorHandling: i } = yn; if (this._error) i && e.syncErrorThrowable ? (this.__tryOrSetError(e, this._error, t), this.unsubscribe()) : (this.__tryOrUnsub(this._error, t), this.unsubscribe()); else if (e.syncErrorThrowable) i ? (e.syncErrorValue = t, e.syncErrorThrown = !0) : Hr(t), this.unsubscribe(); else { if (this.unsubscribe(), i) throw t; Hr(t) } } } complete() { if (!this.isStopped) { const { _parentSubscriber: t } = this; if (this._complete) { const e = () => this._complete.call(this._context); yn.useDeprecatedSynchronousErrorHandling && t.syncErrorThrowable ? (this.__tryOrSetError(t, e), this.unsubscribe()) : (this.__tryOrUnsub(e), this.unsubscribe()) } else this.unsubscribe() } } __tryOrUnsub(t, e) { try { t.call(this._context, e) } catch (i) { if (this.unsubscribe(), yn.useDeprecatedSynchronousErrorHandling) throw i; Hr(i) } } __tryOrSetError(t, e, i) { if (!yn.useDeprecatedSynchronousErrorHandling) throw new Error("bad call"); try { e.call(this._context, i) } catch (r) { return yn.useDeprecatedSynchronousErrorHandling ? (t.syncErrorValue = r, t.syncErrorThrown = !0, !0) : (Hr(r), !0) } return !1 } _unsubscribe() { const { _parentSubscriber: t } = this; this._context = null, this._parentSubscriber = null, t.unsubscribe() } } const oo = "function" == typeof Symbol && Symbol.observable || "@@observable"; function Pg(n) { return n } let me = (() => { class n { constructor(e) { this._isScalar = !1, e && (this._subscribe = e) } lift(e) { const i = new n; return i.source = this, i.operator = e, i } subscribe(e, i, r) { const { operator: s } = this, o = function (n, t, e) { if (n) { if (n instanceof Ie) return n; if (n[Ha]) return n[Ha]() } return n || t || e ? new Ie(n, t, e) : new Ie(Va) }(e, i, r); if (o.add(s ? s.call(o, this.source) : this.source || yn.useDeprecatedSynchronousErrorHandling && !o.syncErrorThrowable ? this._subscribe(o) : this._trySubscribe(o)), yn.useDeprecatedSynchronousErrorHandling && o.syncErrorThrowable && (o.syncErrorThrowable = !1, o.syncErrorThrown)) throw o.syncErrorValue; return o } _trySubscribe(e) { try { return this._subscribe(e) } catch (i) { yn.useDeprecatedSynchronousErrorHandling && (e.syncErrorThrown = !0, e.syncErrorValue = i), function (n) { for (; n;) { const { closed: t, destination: e, isStopped: i } = n; if (t || i) return !1; n = e && e instanceof Ie ? e : null } return !0 }(e) ? e.error(i) : console.warn(i) } } forEach(e, i) { return new (i = Vg(i))((r, s) => { let o; o = this.subscribe(a => { try { e(a) } catch (l) { s(l), o && o.unsubscribe() } }, s, r) }) } _subscribe(e) { const { source: i } = this; return i && i.subscribe(e) } [oo]() { return this } pipe(...e) { return 0 === e.length ? this : function (n) { return 0 === n.length ? Pg : 1 === n.length ? n[0] : function (e) { return n.reduce((i, r) => r(i), e) } }(e)(this) } toPromise(e) { return new (e = Vg(e))((i, r) => { let s; this.subscribe(o => s = o, o => r(o), () => i(s)) }) } } return n.create = t => new n(t), n })(); function Vg(n) { if (n || (n = yn.Promise || Promise), !n) throw new Error("no Promise impl found"); return n } const er = (() => { function n() { return Error.call(this), this.message = "object unsubscribed", this.name = "ObjectUnsubscribedError", this } return n.prototype = Object.create(Error.prototype), n })(); class Bg extends he { constructor(t, e) { super(), this.subject = t, this.subscriber = e, this.closed = !1 } unsubscribe() { if (this.closed) return; this.closed = !0; const t = this.subject, e = t.observers; if (this.subject = null, !e || 0 === e.length || t.isStopped || t.closed) return; const i = e.indexOf(this.subscriber); -1 !== i && e.splice(i, 1) } } class Hg extends Ie { constructor(t) { super(t), this.destination = t } } let ie = (() => { class n extends me { constructor() { super(), this.observers = [], this.closed = !1, this.isStopped = !1, this.hasError = !1, this.thrownError = null } [Ha]() { return new Hg(this) } lift(e) { const i = new jg(this, this); return i.operator = e, i } next(e) { if (this.closed) throw new er; if (!this.isStopped) { const { observers: i } = this, r = i.length, s = i.slice(); for (let o = 0; o < r; o++)s[o].next(e) } } error(e) { if (this.closed) throw new er; this.hasError = !0, this.thrownError = e, this.isStopped = !0; const { observers: i } = this, r = i.length, s = i.slice(); for (let o = 0; o < r; o++)s[o].error(e); this.observers.length = 0 } complete() { if (this.closed) throw new er; this.isStopped = !0; const { observers: e } = this, i = e.length, r = e.slice(); for (let s = 0; s < i; s++)r[s].complete(); this.observers.length = 0 } unsubscribe() { this.isStopped = !0, this.closed = !0, this.observers = null } _trySubscribe(e) { if (this.closed) throw new er; return super._trySubscribe(e) } _subscribe(e) { if (this.closed) throw new er; return this.hasError ? (e.error(this.thrownError), he.EMPTY) : this.isStopped ? (e.complete(), he.EMPTY) : (this.observers.push(e), new Bg(this, e)) } asObservable() { const e = new me; return e.source = this, e } } return n.create = (t, e) => new jg(t, e), n })(); class jg extends ie { constructor(t, e) { super(), this.destination = t, this.source = e } next(t) { const { destination: e } = this; e && e.next && e.next(t) } error(t) { const { destination: e } = this; e && e.error && this.destination.error(t) } complete() { const { destination: t } = this; t && t.complete && this.destination.complete() } _subscribe(t) { const { source: e } = this; return e ? this.source.subscribe(t) : he.EMPTY } } function Gr(n) { return n && "function" == typeof n.schedule } function Dt(n, t) { return function (i) { if ("function" != typeof n) throw new TypeError("argument is not a function. Are you looking for `mapTo()`?"); return i.lift(new KA(n, t)) } } class KA { constructor(t, e) { this.project = t, this.thisArg = e } call(t, e) { return e.subscribe(new QA(t, this.project, this.thisArg)) } } class QA extends Ie { constructor(t, e, i) { super(t), this.project = e, this.count = 0, this.thisArg = i || this } _next(t) { let e; try { e = this.project.call(this.thisArg, t, this.count++) } catch (i) { return void this.destination.error(i) } this.destination.next(e) } } const Gg = n => t => { for (let e = 0, i = n.length; e < i && !t.closed; e++)t.next(n[e]); t.complete() }, ja = "function" == typeof Symbol && Symbol.iterator ? Symbol.iterator : "@@iterator", $g = n => n && "number" == typeof n.length && "function" != typeof n; function Ug(n) { return !!n && "function" != typeof n.subscribe && "function" == typeof n.then } const Ru = n => { if (n && "function" == typeof n[oo]) return (n => t => { const e = n[oo](); if ("function" != typeof e.subscribe) throw new TypeError("Provided object does not correctly implement Symbol.observable"); return e.subscribe(t) })(n); if ($g(n)) return Gg(n); if (Ug(n)) return (n => t => (n.then(e => { t.closed || (t.next(e), t.complete()) }, e => t.error(e)).then(null, Hr), t))(n); if (n && "function" == typeof n[ja]) return (n => t => { const e = n[ja](); for (; ;) { let i; try { i = e.next() } catch (r) { return t.error(r), t } if (i.done) { t.complete(); break } if (t.next(i.value), t.closed) break } return "function" == typeof e.return && t.add(() => { e.return && e.return() }), t })(n); { const e = `You provided ${Fu(n) ? "an invalid object" : `'${n}'`} where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.`; throw new TypeError(e) } }; function ku(n, t) { return new me(e => { const i = new he; let r = 0; return i.add(t.schedule(function () { r !== n.length ? (e.next(n[r++]), e.closed || i.add(this.schedule())) : e.complete() })), i }) } function Ga(n, t) { return t ? function (n, t) { if (null != n) { if (function (n) { return n && "function" == typeof n[oo] }(n)) return function (n, t) { return new me(e => { const i = new he; return i.add(t.schedule(() => { const r = n[oo](); i.add(r.subscribe({ next(s) { i.add(t.schedule(() => e.next(s))) }, error(s) { i.add(t.schedule(() => e.error(s))) }, complete() { i.add(t.schedule(() => e.complete())) } })) })), i }) }(n, t); if (Ug(n)) return function (n, t) { return new me(e => { const i = new he; return i.add(t.schedule(() => n.then(r => { i.add(t.schedule(() => { e.next(r), i.add(t.schedule(() => e.complete())) })) }, r => { i.add(t.schedule(() => e.error(r))) }))), i }) }(n, t); if ($g(n)) return ku(n, t); if (function (n) { return n && "function" == typeof n[ja] }(n) || "string" == typeof n) return function (n, t) { if (!n) throw new Error("Iterable cannot be null"); return new me(e => { const i = new he; let r; return i.add(() => { r && "function" == typeof r.return && r.return() }), i.add(t.schedule(() => { r = n[ja](), i.add(t.schedule(function () { if (e.closed) return; let s, o; try { const a = r.next(); s = a.value, o = a.done } catch (a) { return void e.error(a) } o ? e.complete() : (e.next(s), this.schedule()) })) })), i }) }(n, t) } throw new TypeError((null !== n && typeof n || n) + " is not observable") }(n, t) : n instanceof me ? n : new me(Ru(n)) } class ao extends Ie { constructor(t) { super(), this.parent = t } _next(t) { this.parent.notifyNext(t) } _error(t) { this.parent.notifyError(t), this.unsubscribe() } _complete() { this.parent.notifyComplete(), this.unsubscribe() } } class lo extends Ie { notifyNext(t) { this.destination.next(t) } notifyError(t) { this.destination.error(t) } notifyComplete() { this.destination.complete() } } function co(n, t) { if (t.closed) return; if (n instanceof me) return n.subscribe(t); let e; try { e = Ru(n)(t) } catch (i) { t.error(i) } return e } function Ou(n, t, e = Number.POSITIVE_INFINITY) { return "function" == typeof t ? i => i.pipe(Ou((r, s) => Ga(n(r, s)).pipe(Dt((o, a) => t(r, o, s, a))), e)) : ("number" == typeof t && (e = t), i => i.lift(new oS(n, e))) } class oS { constructor(t, e = Number.POSITIVE_INFINITY) { this.project = t, this.concurrent = e } call(t, e) { return e.subscribe(new aS(t, this.project, this.concurrent)) } } class aS extends lo { constructor(t, e, i = Number.POSITIVE_INFINITY) { super(t), this.project = e, this.concurrent = i, this.hasCompleted = !1, this.buffer = [], this.active = 0, this.index = 0 } _next(t) { this.active < this.concurrent ? this._tryNext(t) : this.buffer.push(t) } _tryNext(t) { let e; const i = this.index++; try { e = this.project(t, i) } catch (r) { return void this.destination.error(r) } this.active++, this._innerSub(e) } _innerSub(t) { const e = new ao(this), i = this.destination; i.add(e); const r = co(t, e); r !== e && i.add(r) } _complete() { this.hasCompleted = !0, 0 === this.active && 0 === this.buffer.length && this.destination.complete(), this.unsubscribe() } notifyNext(t) { this.destination.next(t) } notifyComplete() { const t = this.buffer; this.active--, t.length > 0 ? this._next(t.shift()) : 0 === this.active && this.hasCompleted && this.destination.complete() } } function zg(n = Number.POSITIVE_INFINITY) { return Ou(Pg, n) } function Nu(n, t) { return t ? ku(n, t) : new me(Gg(n)) } function uo(...n) { let t = Number.POSITIVE_INFINITY, e = null, i = n[n.length - 1]; return Gr(i) ? (e = n.pop(), n.length > 1 && "number" == typeof n[n.length - 1] && (t = n.pop())) : "number" == typeof i && (t = n.pop()), null === e && 1 === n.length && n[0] instanceof me ? n[0] : zg(t)(Nu(n, e)) } function Wg() { return function (t) { return t.lift(new lS(t)) } } class lS { constructor(t) { this.connectable = t } call(t, e) { const { connectable: i } = this; i._refCount++; const r = new cS(t, i), s = e.subscribe(r); return r.closed || (r.connection = i.connect()), s } } class cS extends Ie { constructor(t, e) { super(t), this.connectable = e } _unsubscribe() { const { connectable: t } = this; if (!t) return void (this.connection = null); this.connectable = null; const e = t._refCount; if (e <= 0) return void (this.connection = null); if (t._refCount = e - 1, e > 1) return void (this.connection = null); const { connection: i } = this, r = t._connection; this.connection = null, r && (!i || r === i) && r.unsubscribe() } } class uS extends me { constructor(t, e) { super(), this.source = t, this.subjectFactory = e, this._refCount = 0, this._isComplete = !1 } _subscribe(t) { return this.getSubject().subscribe(t) } getSubject() { const t = this._subject; return (!t || t.isStopped) && (this._subject = this.subjectFactory()), this._subject } connect() { let t = this._connection; return t || (this._isComplete = !1, t = this._connection = new he, t.add(this.source.subscribe(new fS(this.getSubject(), this))), t.closed && (this._connection = null, t = he.EMPTY)), t } refCount() { return Wg()(this) } } const dS = (() => { const n = uS.prototype; return { operator: { value: null }, _refCount: { value: 0, writable: !0 }, _subject: { value: null, writable: !0 }, _connection: { value: null, writable: !0 }, _subscribe: { value: n._subscribe }, _isComplete: { value: n._isComplete, writable: !0 }, getSubject: { value: n.getSubject }, connect: { value: n.connect }, refCount: { value: n.refCount } } })(); class fS extends Hg { constructor(t, e) { super(t), this.connectable = e } _error(t) { this._unsubscribe(), super._error(t) } _complete() { this.connectable._isComplete = !0, this._unsubscribe(), super._complete() } _unsubscribe() { const t = this.connectable; if (t) { this.connectable = null; const e = t._connection; t._refCount = 0, t._subject = null, t._connection = null, e && e.unsubscribe() } } } function mS() { return new ie } function qg() { return n => Wg()(function (n, t) { return function (i) { let r; r = "function" == typeof n ? n : function () { return n }; const s = Object.create(i, dS); return s.source = i, s.subjectFactory = r, s } }(mS)(n)) } function pe(n) { for (let t in n) if (n[t] === pe) return t; throw Error("Could not find renamed property on target object.") } function Pu(n, t) { for (const e in t) t.hasOwnProperty(e) && !n.hasOwnProperty(e) && (n[e] = t[e]) } function re(n) { if ("string" == typeof n) return n; if (Array.isArray(n)) return "[" + n.map(re).join(", ") + "]"; if (null == n) return "" + n; if (n.overriddenName) return `${n.overriddenName}`; if (n.name) return `${n.name}`; const t = n.toString(); if (null == t) return "" + t; const e = t.indexOf("\n"); return -1 === e ? t : t.substring(0, e) } function Lu(n, t) { return null == n || "" === n ? null === t ? "" : t : null == t || "" === t ? n : n + " " + t } const _S = pe({ __forward_ref__: pe }); function xe(n) { return n.__forward_ref__ = xe, n.toString = function () { return re(this()) }, n } function L(n) { return Kg(n) ? n() : n } function Kg(n) { return "function" == typeof n && n.hasOwnProperty(_S) && n.__forward_ref__ === xe } class tr extends Error { constructor(t, e) { super(function (n, t) { return `${n ? `NG0${n}: ` : ""}${t}` }(t, e)), this.code = t } } function J(n) { return "string" == typeof n ? n : null == n ? "" : String(n) } function xt(n) { return "function" == typeof n ? n.name || n.toString() : "object" == typeof n && null != n && "function" == typeof n.type ? n.type.name || n.type.toString() : J(n) } function $a(n, t) { const e = t ? ` in ${t}` : ""; throw new tr("201", `No provider for ${xt(n)} found${e}`) } function Ht(n, t) { null == n && function (n, t, e, i) { throw new Error(`ASSERTION ERROR: ${n}` + (null == i ? "" : ` [Expected=> ${e} ${i} ${t} <=Actual]`)) }(t, n, null, "!=") } function E(n) { return { token: n.token, providedIn: n.providedIn || null, factory: n.factory, value: void 0 } } function X(n) { return { providers: n.providers || [], imports: n.imports || [] } } function si(n) { return Qg(n, Ua) || Qg(n, Jg) } function Qg(n, t) { return n.hasOwnProperty(t) ? n[t] : null } function Yg(n) { return n && (n.hasOwnProperty(Bu) || n.hasOwnProperty(DS)) ? n[Bu] : null } const Ua = pe({ \u0275prov: pe }), Bu = pe({ \u0275inj: pe }), Jg = pe({ ngInjectableDef: pe }), DS = pe({ ngInjectorDef: pe }); var G = (() => ((G = G || {})[G.Default = 0] = "Default", G[G.Host = 1] = "Host", G[G.Self = 2] = "Self", G[G.SkipSelf = 4] = "SkipSelf", G[G.Optional = 8] = "Optional", G))(); let Hu; function Mi(n) { const t = Hu; return Hu = n, t } function Zg(n, t, e) { const i = si(n); return i && "root" == i.providedIn ? void 0 === i.value ? i.value = i.factory() : i.value : e & G.Optional ? null : void 0 !== t ? t : void $a(re(n), "Injector") } function Ai(n) { return { toString: n }.toString() } var Zt = (() => ((Zt = Zt || {})[Zt.OnPush = 0] = "OnPush", Zt[Zt.Default = 1] = "Default", Zt))(), qe = (() => ((qe = qe || {})[qe.Emulated = 0] = "Emulated", qe[qe.None = 2] = "None", qe[qe.ShadowDom = 3] = "ShadowDom", qe))(); const MS = "undefined" != typeof globalThis && globalThis, AS = "undefined" != typeof window && window, SS = "undefined" != typeof self && "undefined" != typeof WorkerGlobalScope && self instanceof WorkerGlobalScope && self, TS = "undefined" != typeof global && global, _e = MS || TS || AS || SS, $r = {}, we = [], za = pe({ \u0275cmp: pe }), ju = pe({ \u0275dir: pe }), Gu = pe({ \u0275pipe: pe }), Xg = pe({ \u0275mod: pe }), IS = pe({ \u0275loc: pe }), oi = pe({ \u0275fac: pe }), fo = pe({ __NG_ELEMENT_ID__: pe }); let FS = 0; function tt(n) { return Ai(() => { const e = {}, i = { type: n.type, providersResolver: null, decls: n.decls, vars: n.vars, factory: null, template: n.template || null, consts: n.consts || null, ngContentSelectors: n.ngContentSelectors, hostBindings: n.hostBindings || null, hostVars: n.hostVars || 0, hostAttrs: n.hostAttrs || null, contentQueries: n.contentQueries || null, declaredInputs: e, inputs: null, outputs: null, exportAs: n.exportAs || null, onPush: n.changeDetection === Zt.OnPush, directiveDefs: null, pipeDefs: null, selectors: n.selectors || we, viewQuery: n.viewQuery || null, features: n.features || null, data: n.data || {}, encapsulation: n.encapsulation || qe.Emulated, id: "c", styles: n.styles || we, _: null, setInput: null, schemas: n.schemas || null, tView: null }, r = n.directives, s = n.features, o = n.pipes; return i.id += FS++, i.inputs = im(n.inputs, e), i.outputs = im(n.outputs), s && s.forEach(a => a(i)), i.directiveDefs = r ? () => ("function" == typeof r ? r() : r).map(em) : null, i.pipeDefs = o ? () => ("function" == typeof o ? o() : o).map(tm) : null, i }) } function em(n) { return Mt(n) || function (n) { return n[ju] || null }(n) } function tm(n) { return function (n) { return n[Gu] || null }(n) } const nm = {}; function ee(n) { return Ai(() => { const t = { type: n.type, bootstrap: n.bootstrap || we, declarations: n.declarations || we, imports: n.imports || we, exports: n.exports || we, transitiveCompileScopes: null, schemas: n.schemas || null, id: n.id || null }; return null != n.id && (nm[n.id] = n.type), t }) } function im(n, t) { if (null == n) return $r; const e = {}; for (const i in n) if (n.hasOwnProperty(i)) { let r = n[i], s = r; Array.isArray(r) && (s = r[1], r = r[0]), e[r] = i, t && (t[r] = s) } return e } const C = tt; function Mt(n) { return n[za] || null } function Xt(n, t) { const e = n[Xg] || null; if (!e && !0 === t) throw new Error(`Type ${re(n)} does not have '\u0275mod' property.`); return e } function jn(n) { return Array.isArray(n) && "object" == typeof n[1] } function bn(n) { return Array.isArray(n) && !0 === n[1] } function zu(n) { return 0 != (8 & n.flags) } function Qa(n) { return 2 == (2 & n.flags) } function Ya(n) { return 1 == (1 & n.flags) } function Cn(n) { return null !== n.template } function VS(n) { return 0 != (512 & n[2]) } function or(n, t) { return n.hasOwnProperty(oi) ? n[oi] : null } class sm { constructor(t, e, i) { this.previousValue = t, this.currentValue = e, this.firstChange = i } isFirstChange() { return this.firstChange } } function nt() { return om } function om(n) { return n.type.prototype.ngOnChanges && (n.setInput = GS), jS } function jS() { const n = lm(this), t = null == n ? void 0 : n.current; if (t) { const e = n.previous; if (e === $r) n.previous = t; else for (let i in t) e[i] = t[i]; n.current = null, this.ngOnChanges(t) } } function GS(n, t, e, i) { const r = lm(n) || function (n, t) { return n[am] = t }(n, { previous: $r, current: null }), s = r.current || (r.current = {}), o = r.previous, a = this.declaredInputs[e], l = o[a]; s[a] = new sm(l && l.currentValue, t, o === $r), n[i] = t } nt.ngInherit = !0; const am = "__ngSimpleChanges__"; function lm(n) { return n[am] || null } let Ku; function Ve(n) { return !!n.listen } const dm = { createRenderer: (n, t) => void 0 !== Ku ? Ku : "undefined" != typeof document ? document : void 0 }; function Ke(n) { for (; Array.isArray(n);)n = n[0]; return n } function Ja(n, t) { return Ke(t[n]) } function nn(n, t) { return Ke(t[n.index]) } function Yu(n, t) { return n.data[t] } function Gt(n, t) { const e = t[n]; return jn(e) ? e : e[0] } function fm(n) { return 4 == (4 & n[2]) } function Ju(n) { return 128 == (128 & n[2]) } function Ti(n, t) { return null == t ? null : n[t] } function hm(n) { n[18] = 0 } function Zu(n, t) { n[5] += t; let e = n, i = n[3]; for (; null !== i && (1 === t && 1 === e[5] || -1 === t && 0 === e[5]);)i[5] += t, e = i, i = i[3] } const z = { lFrame: Cm(null), bindingsEnabled: !0, isInCheckNoChangesMode: !1 }; function pm() { return z.bindingsEnabled } function w() { return z.lFrame.lView } function ue() { return z.lFrame.tView } function ai(n) { return z.lFrame.contextLView = n, n[8] } function it() { let n = gm(); for (; null !== n && 64 === n.type;)n = n.parent; return n } function gm() { return z.lFrame.currentTNode } function Gn(n, t) { const e = z.lFrame; e.currentTNode = n, e.isParent = t } function Xu() { return z.lFrame.isParent } function ed() { z.lFrame.isParent = !1 } function Za() { return z.isInCheckNoChangesMode } function Xa(n) { z.isInCheckNoChangesMode = n } function Qr() { return z.lFrame.bindingIndex++ } function r0(n, t) { const e = z.lFrame; e.bindingIndex = e.bindingRootIndex = n, td(t) } function td(n) { z.lFrame.currentDirectiveIndex = n } function nd(n) { const t = z.lFrame.currentDirectiveIndex; return -1 === t ? null : n[t] } function ym() { return z.lFrame.currentQueryIndex } function id(n) { z.lFrame.currentQueryIndex = n } function o0(n) { const t = n[1]; return 2 === t.type ? t.declTNode : 1 === t.type ? n[6] : null } function vm(n, t, e) { if (e & G.SkipSelf) { let r = t, s = n; for (; !(r = r.parent, null !== r || e & G.Host || (r = o0(s), null === r || (s = s[15], 10 & r.type)));); if (null === r) return !1; t = r, n = s } const i = z.lFrame = bm(); return i.currentTNode = t, i.lView = n, !0 } function el(n) { const t = bm(), e = n[1]; z.lFrame = t, t.currentTNode = e.firstChild, t.lView = n, t.tView = e, t.contextLView = n, t.bindingIndex = e.bindingStartIndex, t.inI18n = !1 } function bm() { const n = z.lFrame, t = null === n ? null : n.child; return null === t ? Cm(n) : t } function Cm(n) { const t = { currentTNode: null, isParent: !0, lView: null, tView: null, selectedIndex: -1, contextLView: null, elementDepthCount: 0, currentNamespace: null, currentDirectiveIndex: -1, bindingRootIndex: -1, bindingIndex: -1, currentQueryIndex: 0, parent: n, child: null, inI18n: !1 }; return null !== n && (n.child = t), t } function wm() { const n = z.lFrame; return z.lFrame = n.parent, n.currentTNode = null, n.lView = null, n } const Em = wm; function tl() { const n = wm(); n.isParent = !0, n.tView = null, n.selectedIndex = -1, n.contextLView = null, n.elementDepthCount = 0, n.currentDirectiveIndex = -1, n.currentNamespace = null, n.bindingRootIndex = -1, n.bindingIndex = -1, n.currentQueryIndex = 0 } function St() { return z.lFrame.selectedIndex } function Ii(n) { z.lFrame.selectedIndex = n } function Be() { const n = z.lFrame; return Yu(n.tView, n.selectedIndex) } function nl(n, t) { for (let e = t.directiveStart, i = t.directiveEnd; e < i; e++) { const s = n.data[e].type.prototype, { ngAfterContentInit: o, ngAfterContentChecked: a, ngAfterViewInit: l, ngAfterViewChecked: c, ngOnDestroy: u } = s; o && (n.contentHooks || (n.contentHooks = [])).push(-e, o), a && ((n.contentHooks || (n.contentHooks = [])).push(e, a), (n.contentCheckHooks || (n.contentCheckHooks = [])).push(e, a)), l && (n.viewHooks || (n.viewHooks = [])).push(-e, l), c && ((n.viewHooks || (n.viewHooks = [])).push(e, c), (n.viewCheckHooks || (n.viewCheckHooks = [])).push(e, c)), null != u && (n.destroyHooks || (n.destroyHooks = [])).push(e, u) } } function il(n, t, e) { Dm(n, t, 3, e) } function rl(n, t, e, i) { (3 & n[2]) === e && Dm(n, t, e, i) } function rd(n, t) { let e = n[2]; (3 & e) === t && (e &= 2047, e += 1, n[2] = e) } function Dm(n, t, e, i) { const s = null != i ? i : -1, o = t.length - 1; let a = 0; for (let l = void 0 !== i ? 65535 & n[18] : 0; l < o; l++)if ("number" == typeof t[l + 1]) { if (a = t[l], null != i && a >= i) break } else t[l] < 0 && (n[18] += 65536), (a < s || -1 == s) && (g0(n, e, t, l), n[18] = (4294901760 & n[18]) + l + 2), l++ } function g0(n, t, e, i) { const r = e[i] < 0, s = e[i + 1], a = n[r ? -e[i] : e[i]]; if (r) { if (n[2] >> 11 < n[18] >> 16 && (3 & n[2]) === t) { n[2] += 2048; try { s.call(a) } finally { } } } else try { s.call(a) } finally { } } class _o { constructor(t, e, i) { this.factory = t, this.resolving = !1, this.canSeeViewProviders = e, this.injectImpl = i } } function sl(n, t, e) { const i = Ve(n); let r = 0; for (; r < e.length;) { const s = e[r]; if ("number" == typeof s) { if (0 !== s) break; r++; const o = e[r++], a = e[r++], l = e[r++]; i ? n.setAttribute(t, a, l, o) : t.setAttributeNS(o, a, l) } else { const o = s, a = e[++r]; od(o) ? i && n.setProperty(t, o, a) : i ? n.setAttribute(t, o, a) : t.setAttribute(o, a), r++ } } return r } function xm(n) { return 3 === n || 4 === n || 6 === n } function od(n) { return 64 === n.charCodeAt(0) } function ol(n, t) { if (null !== t && 0 !== t.length) if (null === n || 0 === n.length) n = t.slice(); else { let e = -1; for (let i = 0; i < t.length; i++) { const r = t[i]; "number" == typeof r ? e = r : 0 === e || Mm(n, e, r, null, -1 === e || 2 === e ? t[++i] : null) } } return n } function Mm(n, t, e, i, r) { let s = 0, o = n.length; if (-1 === t) o = -1; else for (; s < n.length;) { const a = n[s++]; if ("number" == typeof a) { if (a === t) { o = -1; break } if (a > t) { o = s - 1; break } } } for (; s < n.length;) { const a = n[s]; if ("number" == typeof a) break; if (a === e) { if (null === i) return void (null !== r && (n[s + 1] = r)); if (i === n[s + 1]) return void (n[s + 2] = r) } s++, null !== i && s++, null !== r && s++ } -1 !== o && (n.splice(o, 0, t), s = o + 1), n.splice(s++, 0, e), null !== i && n.splice(s++, 0, i), null !== r && n.splice(s++, 0, r) } function Am(n) { return -1 !== n } function Yr(n) { return 32767 & n } function Jr(n, t) { let e = function (n) { return n >> 16 }(n), i = t; for (; e > 0;)i = i[15], e--; return i } let ad = !0; function al(n) { const t = ad; return ad = n, t } let C0 = 0; function vo(n, t) { const e = cd(n, t); if (-1 !== e) return e; const i = t[1]; i.firstCreatePass && (n.injectorIndex = t.length, ld(i.data, n), ld(t, null), ld(i.blueprint, null)); const r = ll(n, t), s = n.injectorIndex; if (Am(r)) { const o = Yr(r), a = Jr(r, t), l = a[1].data; for (let c = 0; c < 8; c++)t[s + c] = a[o + c] | l[o + c] } return t[s + 8] = r, s } function ld(n, t) { n.push(0, 0, 0, 0, 0, 0, 0, 0, t) } function cd(n, t) { return -1 === n.injectorIndex || n.parent && n.parent.injectorIndex === n.injectorIndex || null === t[n.injectorIndex + 8] ? -1 : n.injectorIndex } function ll(n, t) { if (n.parent && -1 !== n.parent.injectorIndex) return n.parent.injectorIndex; let e = 0, i = null, r = t; for (; null !== r;) { const s = r[1], o = s.type; if (i = 2 === o ? s.declTNode : 1 === o ? r[6] : null, null === i) return -1; if (e++, r = r[15], -1 !== i.injectorIndex) return i.injectorIndex | e << 16 } return -1 } function cl(n, t, e) { !function (n, t, e) { let i; "string" == typeof e ? i = e.charCodeAt(0) || 0 : e.hasOwnProperty(fo) && (i = e[fo]), null == i && (i = e[fo] = C0++); const r = 255 & i; t.data[n + (r >> 5)] |= 1 << r }(n, t, e) } function Im(n, t, e) { if (e & G.Optional) return n; $a(t, "NodeInjector") } function Fm(n, t, e, i) { if (e & G.Optional && void 0 === i && (i = null), 0 == (e & (G.Self | G.Host))) { const r = n[9], s = Mi(void 0); try { return r ? r.get(t, i, e & G.Optional) : Zg(t, i, e & G.Optional) } finally { Mi(s) } } return Im(i, t, e) } function Rm(n, t, e, i = G.Default, r) { if (null !== n) { const s = function (n) { if ("string" == typeof n) return n.charCodeAt(0) || 0; const t = n.hasOwnProperty(fo) ? n[fo] : void 0; return "number" == typeof t ? t >= 0 ? 255 & t : D0 : t }(e); if ("function" == typeof s) { if (!vm(t, n, i)) return i & G.Host ? Im(r, e, i) : Fm(t, e, i, r); try { const o = s(i); if (null != o || i & G.Optional) return o; $a(e) } finally { Em() } } else if ("number" == typeof s) { let o = null, a = cd(n, t), l = -1, c = i & G.Host ? t[16][6] : null; for ((-1 === a || i & G.SkipSelf) && (l = -1 === a ? ll(n, t) : t[a + 8], -1 !== l && Nm(i, !1) ? (o = t[1], a = Yr(l), t = Jr(l, t)) : a = -1); -1 !== a;) { const u = t[1]; if (Om(s, a, u.data)) { const d = x0(a, t, e, o, i, c); if (d !== km) return d } l = t[a + 8], -1 !== l && Nm(i, t[1].data[a + 8] === c) && Om(s, a, t) ? (o = u, a = Yr(l), t = Jr(l, t)) : a = -1 } } } return Fm(t, e, i, r) } const km = {}; function D0() { return new Zr(it(), w()) } function x0(n, t, e, i, r, s) { const o = t[1], a = o.data[n + 8], u = ul(a, o, e, null == i ? Qa(a) && ad : i != o && 0 != (3 & a.type), r & G.Host && s === a); return null !== u ? bo(t, o, u, a) : km } function ul(n, t, e, i, r) { const s = n.providerIndexes, o = t.data, a = 1048575 & s, l = n.directiveStart, u = s >> 20, f = r ? a + u : n.directiveEnd; for (let h = i ? a : a + u; h < f; h++) { const p = o[h]; if (h < l && e === p || h >= l && p.type === e) return h } if (r) { const h = o[l]; if (h && Cn(h) && h.type === e) return l } return null } function bo(n, t, e, i) { let r = n[e]; const s = t.data; if (function (n) { return n instanceof _o }(r)) { const o = r; o.resolving && function (n, t) { throw new tr("200", `Circular dependency in DI detected for ${n}`) }(xt(s[e])); const a = al(o.canSeeViewProviders); o.resolving = !0; const l = o.injectImpl ? Mi(o.injectImpl) : null; vm(n, i, G.Default); try { r = n[e] = o.factory(void 0, s, n, i), t.firstCreatePass && e >= i.directiveStart && function (n, t, e) { const { ngOnChanges: i, ngOnInit: r, ngDoCheck: s } = t.type.prototype; if (i) { const o = om(t); (e.preOrderHooks || (e.preOrderHooks = [])).push(n, o), (e.preOrderCheckHooks || (e.preOrderCheckHooks = [])).push(n, o) } r && (e.preOrderHooks || (e.preOrderHooks = [])).push(0 - n, r), s && ((e.preOrderHooks || (e.preOrderHooks = [])).push(n, s), (e.preOrderCheckHooks || (e.preOrderCheckHooks = [])).push(n, s)) }(e, s[e], t) } finally { null !== l && Mi(l), al(a), o.resolving = !1, Em() } } return r } function Om(n, t, e) { return !!(e[t + (n >> 5)] & 1 << n) } function Nm(n, t) { return !(n & G.Self || n & G.Host && t) } class Zr { constructor(t, e) { this._tNode = t, this._lView = e } get(t, e) { return Rm(this._tNode, this._lView, t, void 0, e) } } function P(n) { return Ai(() => { const t = n.prototype.constructor, e = t[oi] || ud(t), i = Object.prototype; let r = Object.getPrototypeOf(n.prototype).constructor; for (; r && r !== i;) { const s = r[oi] || ud(r); if (s && s !== e) return s; r = Object.getPrototypeOf(r) } return s => new s }) } function ud(n) { return Kg(n) ? () => { const t = ud(L(n)); return t && t() } : or(n) } const es = "__parameters__"; function ar(n, t, e) { return Ai(() => { const i = function (n) { return function (...e) { if (n) { const i = n(...e); for (const r in i) this[r] = i[r] } } }(t); function r(...s) { if (this instanceof r) return i.apply(this, s), this; const o = new r(...s); return a.annotation = o, a; function a(l, c, u) { const d = l.hasOwnProperty(es) ? l[es] : Object.defineProperty(l, es, { value: [] })[es]; for (; d.length <= u;)d.push(null); return (d[u] = d[u] || []).push(o), l } } return e && (r.prototype = Object.create(e.prototype)), r.prototype.ngMetadataName = n, r.annotationCls = r, r }) } class k { constructor(t, e) { this._desc = t, this.ngMetadataName = "InjectionToken", this.\u0275prov = void 0, "number" == typeof e ? this.__NG_ELEMENT_ID__ = e : void 0 !== e && (this.\u0275prov = E({ token: this, providedIn: e.providedIn || "root", factory: e.factory })) } toString() { return `InjectionToken ${this._desc}` } } function rn(n, t) { void 0 === t && (t = n); for (let e = 0; e < n.length; e++) { let i = n[e]; Array.isArray(i) ? (t === n && (t = n.slice(0, e)), rn(i, t)) : t !== n && t.push(i) } return t } function Un(n, t) { n.forEach(e => Array.isArray(e) ? Un(e, t) : t(e)) } function fl(n, t, e) { t >= n.length ? n.push(e) : n.splice(t, 0, e) } function lr(n, t) { return t >= n.length - 1 ? n.pop() : n.splice(t, 1)[0] } function Ri(n, t) { const e = []; for (let i = 0; i < n; i++)e.push(t); return e } function $t(n, t, e) { let i = ns(n, t); return i >= 0 ? n[1 | i] = e : (i = ~i, function (n, t, e, i) { let r = n.length; if (r == t) n.push(e, i); else if (1 === r) n.push(i, n[0]), n[0] = e; else { for (r--, n.push(n[r - 1], n[r]); r > t;)n[r] = n[r - 2], r--; n[t] = e, n[t + 1] = i } }(n, i, t, e)), i } function hd(n, t) { const e = ns(n, t); if (e >= 0) return n[1 | e] } function ns(n, t) { return function (n, t, e) { let i = 0, r = n.length >> e; for (; r !== i;) { const s = i + (r - i >> 1), o = n[s << e]; if (t === o) return s << e; o > t ? r = s : i = s + 1 } return ~(r << e) }(n, t, 1) } const xo = {}, gd = "__NG_DI_FLAG__", is = "ngTempTokenPath", V0 = /\n/gm, md = "__source", _d = pe({ provide: String, useValue: pe }); let Mo; function rs(n) { const t = Mo; return Mo = n, t } function H0(n, t = G.Default) { if (void 0 === Mo) throw new Error("inject() must be called from an injection context"); return null === Mo ? Zg(n, void 0, t) : Mo.get(n, t & G.Optional ? null : void 0, t) } function m(n, t = G.Default) { return (Hu || H0)(L(n), t) } const Ao = m; function cr(n) { const t = []; for (let e = 0; e < n.length; e++) { const i = L(n[e]); if (Array.isArray(i)) { if (0 === i.length) throw new Error("Arguments array must have arguments."); let r, s = G.Default; for (let o = 0; o < i.length; o++) { const a = i[o], l = j0(a); "number" == typeof l ? -1 === l ? r = a.token : s |= l : r = a } t.push(m(r, s)) } else t.push(m(i)) } return t } function So(n, t) { return n[gd] = t, n.prototype[gd] = t, n } function j0(n) { return n[gd] } function jm(n, t, e, i) { const r = n[is]; throw t[md] && r.unshift(t[md]), n.message = function (n, t, e, i = null) { n = n && "\n" === n.charAt(0) && "\u0275" == n.charAt(1) ? n.substr(2) : n; let r = re(t); if (Array.isArray(t)) r = t.map(re).join(" -> "); else if ("object" == typeof t) { let s = []; for (let o in t) if (t.hasOwnProperty(o)) { let a = t[o]; s.push(o + ":" + ("string" == typeof a ? JSON.stringify(a) : re(a))) } r = `{${s.join(", ")}}` } return `${e}${i ? "(" + i + ")" : ""}[${r}]: ${n.replace(V0, "\n  ")}` }("\n" + n.message, r, e, i), n.ngTokenPath = r, n[is] = null, n } const To = So(ar("Inject", n => ({ token: n })), -1), Ut = So(ar("Optional"), 8), ki = So(ar("SkipSelf"), 4); let ml; function os(n) { var t; return (null === (t = function () { if (void 0 === ml && (ml = null, _e.trustedTypes)) try { ml = _e.trustedTypes.createPolicy("angular", { createHTML: n => n, createScript: n => n, createScriptURL: n => n }) } catch (n) { } return ml }()) || void 0 === t ? void 0 : t.createHTML(n)) || n } class ur { constructor(t) { this.changingThisBreaksApplicationSecurity = t } toString() { return `SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see https://g.co/ng/security#xss)` } } class Z0 extends ur { getTypeName() { return "HTML" } } class X0 extends ur { getTypeName() { return "Style" } } class eT extends ur { getTypeName() { return "Script" } } class tT extends ur { getTypeName() { return "URL" } } class nT extends ur { getTypeName() { return "ResourceURL" } } function zt(n) { return n instanceof ur ? n.changingThisBreaksApplicationSecurity : n } function zn(n, t) { const e = Qm(n); if (null != e && e !== t) { if ("ResourceURL" === e && "URL" === t) return !0; throw new Error(`Required a safe ${t}, got a ${e} (see https://g.co/ng/security#xss)`) } return e === t } function Qm(n) { return n instanceof ur && n.getTypeName() || null } class lT { constructor(t) { this.inertDocumentHelper = t } getInertBodyElement(t) { t = "<body><remove></remove>" + t; try { const e = (new window.DOMParser).parseFromString(os(t), "text/html").body; return null === e ? this.inertDocumentHelper.getInertBodyElement(t) : (e.removeChild(e.firstChild), e) } catch (e) { return null } } } class cT { constructor(t) { if (this.defaultDoc = t, this.inertDocument = this.defaultDoc.implementation.createHTMLDocument("sanitization-inert"), null == this.inertDocument.body) { const e = this.inertDocument.createElement("html"); this.inertDocument.appendChild(e); const i = this.inertDocument.createElement("body"); e.appendChild(i) } } getInertBodyElement(t) { const e = this.inertDocument.createElement("template"); if ("content" in e) return e.innerHTML = os(t), e; const i = this.inertDocument.createElement("body"); return i.innerHTML = os(t), this.defaultDoc.documentMode && this.stripCustomNsAttrs(i), i } stripCustomNsAttrs(t) { const e = t.attributes; for (let r = e.length - 1; 0 < r; r--) { const o = e.item(r).name; ("xmlns:ns1" === o || 0 === o.indexOf("ns1:")) && t.removeAttribute(o) } let i = t.firstChild; for (; i;)i.nodeType === Node.ELEMENT_NODE && this.stripCustomNsAttrs(i), i = i.nextSibling } } const dT = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^&:/?#]*(?:[/?#]|$))/gi, fT = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[a-z0-9+\/]+=*$/i; function Fo(n) { return (n = String(n)).match(dT) || n.match(fT) ? n : "unsafe:" + n } function Jm(n) { return (n = String(n)).split(",").map(t => Fo(t.trim())).join(", ") } function Wn(n) { const t = {}; for (const e of n.split(",")) t[e] = !0; return t } function Ro(...n) { const t = {}; for (const e of n) for (const i in e) e.hasOwnProperty(i) && (t[i] = !0); return t } const Zm = Wn("area,br,col,hr,img,wbr"), Xm = Wn("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"), e_ = Wn("rp,rt"), Cd = Ro(Zm, Ro(Xm, Wn("address,article,aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul")), Ro(e_, Wn("a,abbr,acronym,audio,b,bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video")), Ro(e_, Xm)), wd = Wn("background,cite,href,itemtype,longdesc,poster,src,xlink:href"), Ed = Wn("srcset"), t_ = Ro(wd, Ed, Wn("abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,scope,scrolling,shape,size,sizes,span,srclang,start,summary,tabindex,target,title,translate,type,usemap,valign,value,vspace,width"), Wn("aria-activedescendant,aria-atomic,aria-autocomplete,aria-busy,aria-checked,aria-colcount,aria-colindex,aria-colspan,aria-controls,aria-current,aria-describedby,aria-details,aria-disabled,aria-dropeffect,aria-errormessage,aria-expanded,aria-flowto,aria-grabbed,aria-haspopup,aria-hidden,aria-invalid,aria-keyshortcuts,aria-label,aria-labelledby,aria-level,aria-live,aria-modal,aria-multiline,aria-multiselectable,aria-orientation,aria-owns,aria-placeholder,aria-posinset,aria-pressed,aria-readonly,aria-relevant,aria-required,aria-roledescription,aria-rowcount,aria-rowindex,aria-rowspan,aria-selected,aria-setsize,aria-sort,aria-valuemax,aria-valuemin,aria-valuenow,aria-valuetext")), hT = Wn("script,style,template"); class pT { constructor() { this.sanitizedSomething = !1, this.buf = [] } sanitizeChildren(t) { let e = t.firstChild, i = !0; for (; e;)if (e.nodeType === Node.ELEMENT_NODE ? i = this.startElement(e) : e.nodeType === Node.TEXT_NODE ? this.chars(e.nodeValue) : this.sanitizedSomething = !0, i && e.firstChild) e = e.firstChild; else for (; e;) { e.nodeType === Node.ELEMENT_NODE && this.endElement(e); let r = this.checkClobberedElement(e, e.nextSibling); if (r) { e = r; break } e = this.checkClobberedElement(e, e.parentNode) } return this.buf.join("") } startElement(t) { const e = t.nodeName.toLowerCase(); if (!Cd.hasOwnProperty(e)) return this.sanitizedSomething = !0, !hT.hasOwnProperty(e); this.buf.push("<"), this.buf.push(e); const i = t.attributes; for (let r = 0; r < i.length; r++) { const s = i.item(r), o = s.name, a = o.toLowerCase(); if (!t_.hasOwnProperty(a)) { this.sanitizedSomething = !0; continue } let l = s.value; wd[a] && (l = Fo(l)), Ed[a] && (l = Jm(l)), this.buf.push(" ", o, '="', n_(l), '"') } return this.buf.push(">"), !0 } endElement(t) { const e = t.nodeName.toLowerCase(); Cd.hasOwnProperty(e) && !Zm.hasOwnProperty(e) && (this.buf.push("</"), this.buf.push(e), this.buf.push(">")) } chars(t) { this.buf.push(n_(t)) } checkClobberedElement(t, e) { if (e && (t.compareDocumentPosition(e) & Node.DOCUMENT_POSITION_CONTAINED_BY) === Node.DOCUMENT_POSITION_CONTAINED_BY) throw new Error(`Failed to sanitize html because the element is clobbered: ${t.outerHTML}`); return e } } const gT = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g, mT = /([^\#-~ |!])/g; function n_(n) { return n.replace(/&/g, "&amp;").replace(gT, function (t) { return "&#" + (1024 * (t.charCodeAt(0) - 55296) + (t.charCodeAt(1) - 56320) + 65536) + ";" }).replace(mT, function (t) { return "&#" + t.charCodeAt(0) + ";" }).replace(/</g, "&lt;").replace(/>/g, "&gt;") } let yl; function i_(n, t) { let e = null; try { yl = yl || function (n) { const t = new cT(n); return function () { try { return !!(new window.DOMParser).parseFromString(os(""), "text/html") } catch (n) { return !1 } }() ? new lT(t) : t }(n); let i = t ? String(t) : ""; e = yl.getInertBodyElement(i); let r = 5, s = i; do { if (0 === r) throw new Error("Failed to sanitize html because the input is unstable"); r--, i = s, s = e.innerHTML, e = yl.getInertBodyElement(i) } while (i !== s); return os((new pT).sanitizeChildren(Dd(e) || e)) } finally { if (e) { const i = Dd(e) || e; for (; i.firstChild;)i.removeChild(i.firstChild) } } } function Dd(n) { return "content" in n && function (n) { return n.nodeType === Node.ELEMENT_NODE && "TEMPLATE" === n.nodeName }(n) ? n.content : null } var de = (() => ((de = de || {})[de.NONE = 0] = "NONE", de[de.HTML = 1] = "HTML", de[de.STYLE = 2] = "STYLE", de[de.SCRIPT = 3] = "SCRIPT", de[de.URL = 4] = "URL", de[de.RESOURCE_URL = 5] = "RESOURCE_URL", de))(); const a_ = "__ngContext__"; function mt(n, t) { n[a_] = t } function Md(n) { const t = function (n) { return n[a_] || null }(n); return t ? Array.isArray(t) ? t : t.lView : null } function vl(n) { return n.ngOriginalError } function OT(n, ...t) { n.error(...t) } class wn { constructor() { this._console = console } handleError(t) { const e = this._findOriginalError(t), i = this._findContext(t), r = function (n) { return n && n.ngErrorLogger || OT }(t); r(this._console, "ERROR", t), e && r(this._console, "ORIGINAL ERROR", e), i && r(this._console, "ERROR CONTEXT", i) } _findContext(t) { return t ? function (n) { return n.ngDebugContext }(t) || this._findContext(vl(t)) : null } _findOriginalError(t) { let e = t && vl(t); for (; e && vl(e);)e = vl(e); return e || null } } const m_ = (() => ("undefined" != typeof requestAnimationFrame && requestAnimationFrame || setTimeout).bind(_e))(); function __(n) { return n.ownerDocument } function qn(n) { return n instanceof Function ? n() : n } var Wt = (() => ((Wt = Wt || {})[Wt.Important = 1] = "Important", Wt[Wt.DashCase = 2] = "DashCase", Wt))(); function Td(n, t) { return undefined(n, t) } function No(n) { const t = n[3]; return bn(t) ? t[3] : t } function Id(n) { return w_(n[13]) } function Fd(n) { return w_(n[4]) } function w_(n) { for (; null !== n && !bn(n);)n = n[4]; return n } function ls(n, t, e, i, r) { if (null != i) { let s, o = !1; bn(i) ? s = i : jn(i) && (o = !0, i = i[0]); const a = Ke(i); 0 === n && null !== e ? null == r ? S_(t, e, a) : dr(t, e, a, r || null, !0) : 1 === n && null !== e ? dr(t, e, a, r || null, !0) : 2 === n ? function (n, t, e) { const i = Cl(n, t); i && function (n, t, e, i) { Ve(n) ? n.removeChild(t, e, i) : t.removeChild(e) }(n, i, t, e) }(t, a, o) : 3 === n && t.destroyNode(a), null != s && function (n, t, e, i, r) { const s = e[7]; s !== Ke(e) && ls(t, n, i, s, r); for (let a = 10; a < e.length; a++) { const l = e[a]; Po(l[1], l, n, t, i, s) } }(t, n, s, e, r) } } function kd(n, t, e) { return Ve(n) ? n.createElement(t, e) : null === e ? n.createElement(t) : n.createElementNS(e, t) } function D_(n, t) { const e = n[9], i = e.indexOf(t), r = t[3]; 1024 & t[2] && (t[2] &= -1025, Zu(r, -1)), e.splice(i, 1) } function Od(n, t) { if (n.length <= 10) return; const e = 10 + t, i = n[e]; if (i) { const r = i[17]; null !== r && r !== n && D_(r, i), t > 0 && (n[e - 1][4] = i[4]); const s = lr(n, 10 + t); !function (n, t) { Po(n, t, t[11], 2, null, null), t[0] = null, t[6] = null }(i[1], i); const o = s[19]; null !== o && o.detachView(s[1]), i[3] = null, i[4] = null, i[2] &= -129 } return i } function x_(n, t) { if (!(256 & t[2])) { const e = t[11]; Ve(e) && e.destroyNode && Po(n, t, e, 3, null, null), function (n) { let t = n[13]; if (!t) return Nd(n[1], n); for (; t;) { let e = null; if (jn(t)) e = t[13]; else { const i = t[10]; i && (e = i) } if (!e) { for (; t && !t[4] && t !== n;)jn(t) && Nd(t[1], t), t = t[3]; null === t && (t = n), jn(t) && Nd(t[1], t), e = t && t[4] } t = e } }(t) } } function Nd(n, t) { if (!(256 & t[2])) { t[2] &= -129, t[2] |= 256, function (n, t) { let e; if (null != n && null != (e = n.destroyHooks)) for (let i = 0; i < e.length; i += 2) { const r = t[e[i]]; if (!(r instanceof _o)) { const s = e[i + 1]; if (Array.isArray(s)) for (let o = 0; o < s.length; o += 2) { const a = r[s[o]], l = s[o + 1]; try { l.call(a) } finally { } } else try { s.call(r) } finally { } } } }(n, t), function (n, t) { const e = n.cleanup, i = t[7]; let r = -1; if (null !== e) for (let s = 0; s < e.length - 1; s += 2)if ("string" == typeof e[s]) { const o = e[s + 1], a = "function" == typeof o ? o(t) : Ke(t[o]), l = i[r = e[s + 2]], c = e[s + 3]; "boolean" == typeof c ? a.removeEventListener(e[s], l, c) : c >= 0 ? i[r = c]() : i[r = -c].unsubscribe(), s += 2 } else { const o = i[r = e[s + 1]]; e[s].call(o) } if (null !== i) { for (let s = r + 1; s < i.length; s++)i[s](); t[7] = null } }(n, t), 1 === t[1].type && Ve(t[11]) && t[11].destroy(); const e = t[17]; if (null !== e && bn(t[3])) { e !== t[3] && D_(e, t); const i = t[19]; null !== i && i.detachView(n) } } } function M_(n, t, e) { return function (n, t, e) { let i = t; for (; null !== i && 40 & i.type;)i = (t = i).parent; if (null === i) return e[0]; if (2 & i.flags) { const r = n.data[i.directiveStart].encapsulation; if (r === qe.None || r === qe.Emulated) return null } return nn(i, e) }(n, t.parent, e) } function dr(n, t, e, i, r) { Ve(n) ? n.insertBefore(t, e, i, r) : t.insertBefore(e, i, r) } function S_(n, t, e) { Ve(n) ? n.appendChild(t, e) : t.appendChild(e) } function T_(n, t, e, i, r) { null !== i ? dr(n, t, e, i, r) : S_(n, t, e) } function Cl(n, t) { return Ve(n) ? n.parentNode(t) : t.parentNode } function I_(n, t, e) { return R_(n, t, e) } let R_ = function (n, t, e) { return 40 & n.type ? nn(n, e) : null }; function wl(n, t, e, i) { const r = M_(n, i, t), s = t[11], a = I_(i.parent || t[6], i, t); if (null != r) if (Array.isArray(e)) for (let l = 0; l < e.length; l++)T_(s, r, e[l], a, !1); else T_(s, r, e, a, !1) } function El(n, t) { if (null !== t) { const e = t.type; if (3 & e) return nn(t, n); if (4 & e) return Ld(-1, n[t.index]); if (8 & e) { const i = t.child; if (null !== i) return El(n, i); { const r = n[t.index]; return bn(r) ? Ld(-1, r) : Ke(r) } } if (32 & e) return Td(t, n)() || Ke(n[t.index]); { const i = O_(n, t); return null !== i ? Array.isArray(i) ? i[0] : El(No(n[16]), i) : El(n, t.next) } } return null } function O_(n, t) { return null !== t ? n[16][6].projection[t.projection] : null } function Ld(n, t) { const e = 10 + n + 1; if (e < t.length) { const i = t[e], r = i[1].firstChild; if (null !== r) return El(i, r) } return t[7] } function Vd(n, t, e, i, r, s, o) { for (; null != e;) { const a = i[e.index], l = e.type; if (o && 0 === t && (a && mt(Ke(a), i), e.flags |= 4), 64 != (64 & e.flags)) if (8 & l) Vd(n, t, e.child, i, r, s, !1), ls(t, n, r, a, s); else if (32 & l) { const c = Td(e, i); let u; for (; u = c();)ls(t, n, r, u, s); ls(t, n, r, a, s) } else 16 & l ? P_(n, t, i, e, r, s) : ls(t, n, r, a, s); e = o ? e.projectionNext : e.next } } function Po(n, t, e, i, r, s) { Vd(e, i, n.firstChild, t, r, s, !1) } function P_(n, t, e, i, r, s) { const o = e[16], l = o[6].projection[i.projection]; if (Array.isArray(l)) for (let c = 0; c < l.length; c++)ls(t, n, r, l[c], s); else Vd(n, t, l, o[3], r, s, !0) } function L_(n, t, e) { Ve(n) ? n.setAttribute(t, "style", e) : t.style.cssText = e } function Bd(n, t, e) { Ve(n) ? "" === e ? n.removeAttribute(t, "class") : n.setAttribute(t, "class", e) : t.className = e } function V_(n, t, e) { let i = n.length; for (; ;) { const r = n.indexOf(t, e); if (-1 === r) return r; if (0 === r || n.charCodeAt(r - 1) <= 32) { const s = t.length; if (r + s === i || n.charCodeAt(r + s) <= 32) return r } e = r + 1 } } const B_ = "ng-template"; function sI(n, t, e) { let i = 0; for (; i < n.length;) { let r = n[i++]; if (e && "class" === r) { if (r = n[i], -1 !== V_(r.toLowerCase(), t, 0)) return !0 } else if (1 === r) { for (; i < n.length && "string" == typeof (r = n[i++]);)if (r.toLowerCase() === t) return !0; return !1 } } return !1 } function H_(n) { return 4 === n.type && n.value !== B_ } function oI(n, t, e) { return t === (4 !== n.type || e ? n.value : B_) } function aI(n, t, e) { let i = 4; const r = n.attrs || [], s = function (n) { for (let t = 0; t < n.length; t++)if (xm(n[t])) return t; return n.length }(r); let o = !1; for (let a = 0; a < t.length; a++) { const l = t[a]; if ("number" != typeof l) { if (!o) if (4 & i) { if (i = 2 | 1 & i, "" !== l && !oI(n, l, e) || "" === l && 1 === t.length) { if (En(i)) return !1; o = !0 } } else { const c = 8 & i ? l : t[++a]; if (8 & i && null !== n.attrs) { if (!sI(n.attrs, c, e)) { if (En(i)) return !1; o = !0 } continue } const d = lI(8 & i ? "class" : l, r, H_(n), e); if (-1 === d) { if (En(i)) return !1; o = !0; continue } if ("" !== c) { let f; f = d > s ? "" : r[d + 1].toLowerCase(); const h = 8 & i ? f : null; if (h && -1 !== V_(h, c, 0) || 2 & i && c !== f) { if (En(i)) return !1; o = !0 } } } } else { if (!o && !En(i) && !En(l)) return !1; if (o && En(l)) continue; o = !1, i = l | 1 & i } } return En(i) || o } function En(n) { return 0 == (1 & n) } function lI(n, t, e, i) { if (null === t) return -1; let r = 0; if (i || !e) { let s = !1; for (; r < t.length;) { const o = t[r]; if (o === n) return r; if (3 === o || 6 === o) s = !0; else { if (1 === o || 2 === o) { let a = t[++r]; for (; "string" == typeof a;)a = t[++r]; continue } if (4 === o) break; if (0 === o) { r += 4; continue } } r += s ? 1 : 2 } return -1 } return function (n, t) { let e = n.indexOf(4); if (e > -1) for (e++; e < n.length;) { const i = n[e]; if ("number" == typeof i) return -1; if (i === t) return e; e++ } return -1 }(t, n) } function j_(n, t, e = !1) { for (let i = 0; i < t.length; i++)if (aI(n, t[i], e)) return !0; return !1 } function fI(n, t) { e: for (let e = 0; e < t.length; e++) { const i = t[e]; if (n.length === i.length) { for (let r = 0; r < n.length; r++)if (n[r] !== i[r]) continue e; return !0 } } return !1 } function G_(n, t) { return n ? ":not(" + t.trim() + ")" : t } function hI(n) { let t = n[0], e = 1, i = 2, r = "", s = !1; for (; e < n.length;) { let o = n[e]; if ("string" == typeof o) if (2 & i) { const a = n[++e]; r += "[" + o + (a.length > 0 ? '="' + a + '"' : "") + "]" } else 8 & i ? r += "." + o : 4 & i && (r += " " + o); else "" !== r && !En(o) && (t += G_(s, r), r = ""), i = o, s = s || !En(i); e++ } return "" !== r && (t += G_(s, r)), t } const q = {}; function B(n) { $_(ue(), w(), St() + n, Za()) } function $_(n, t, e, i) { if (!i) if (3 == (3 & t[2])) { const s = n.preOrderCheckHooks; null !== s && il(t, s, e) } else { const s = n.preOrderHooks; null !== s && rl(t, s, 0, e) } Ii(e) } function Dl(n, t) { return n << 17 | t << 2 } function Dn(n) { return n >> 17 & 32767 } function Hd(n) { return 2 | n } function ci(n) { return (131068 & n) >> 2 } function jd(n, t) { return -131069 & n | t << 2 } function Gd(n) { return 1 | n } function X_(n, t) { const e = n.contentQueries; if (null !== e) for (let i = 0; i < e.length; i += 2) { const r = e[i], s = e[i + 1]; if (-1 !== s) { const o = n.data[s]; id(r), o.contentQueries(2, t[s], s) } } } function Lo(n, t, e, i, r, s, o, a, l, c) { const u = t.blueprint.slice(); return u[0] = r, u[2] = 140 | i, hm(u), u[3] = u[15] = n, u[8] = e, u[10] = o || n && n[10], u[11] = a || n && n[11], u[12] = l || n && n[12] || null, u[9] = c || n && n[9] || null, u[6] = s, u[16] = 2 == t.type ? n[16] : u, u } function cs(n, t, e, i, r) { let s = n.data[t]; if (null === s) s = function (n, t, e, i, r) { const s = gm(), o = Xu(), l = n.data[t] = function (n, t, e, i, r, s) { return { type: e, index: i, insertBeforeIndex: null, injectorIndex: t ? t.injectorIndex : -1, directiveStart: -1, directiveEnd: -1, directiveStylingLast: -1, propertyBindings: null, flags: 0, providerIndexes: 0, value: r, attrs: s, mergedAttrs: null, localNames: null, initialInputs: void 0, inputs: null, outputs: null, tViews: null, next: null, projectionNext: null, child: null, parent: t, projection: null, styles: null, stylesWithoutHost: null, residualStyles: void 0, classes: null, classesWithoutHost: null, residualClasses: void 0, classBindings: 0, styleBindings: 0 } }(0, o ? s : s && s.parent, e, t, i, r); return null === n.firstChild && (n.firstChild = l), null !== s && (o ? null == s.child && null !== l.parent && (s.child = l) : null === s.next && (s.next = l)), l }(n, t, e, i, r), z.lFrame.inI18n && (s.flags |= 64); else if (64 & s.type) { s.type = e, s.value = i, s.attrs = r; const o = function () { const n = z.lFrame, t = n.currentTNode; return n.isParent ? t : t.parent }(); s.injectorIndex = null === o ? -1 : o.injectorIndex } return Gn(s, !0), s } function us(n, t, e, i) { if (0 === e) return -1; const r = t.length; for (let s = 0; s < e; s++)t.push(i), n.blueprint.push(i), n.data.push(null); return r } function Vo(n, t, e) { el(t); try { const i = n.viewQuery; null !== i && sf(1, i, e); const r = n.template; null !== r && ey(n, t, r, 1, e), n.firstCreatePass && (n.firstCreatePass = !1), n.staticContentQueries && X_(n, t), n.staticViewQueries && sf(2, n.viewQuery, e); const s = n.components; null !== s && function (n, t) { for (let e = 0; e < t.length; e++)WI(n, t[e]) }(t, s) } catch (i) { throw n.firstCreatePass && (n.incompleteFirstPass = !0, n.firstCreatePass = !1), i } finally { t[2] &= -5, tl() } } function ds(n, t, e, i) { const r = t[2]; if (256 == (256 & r)) return; el(t); const s = Za(); try { hm(t), function (n) { z.lFrame.bindingIndex = n }(n.bindingStartIndex), null !== e && ey(n, t, e, 2, i); const o = 3 == (3 & r); if (!s) if (o) { const c = n.preOrderCheckHooks; null !== c && il(t, c, null) } else { const c = n.preOrderHooks; null !== c && rl(t, c, 0, null), rd(t, 0) } if (function (n) { for (let t = Id(n); null !== t; t = Fd(t)) { if (!t[2]) continue; const e = t[9]; for (let i = 0; i < e.length; i++) { const r = e[i], s = r[3]; 0 == (1024 & r[2]) && Zu(s, 1), r[2] |= 1024 } } }(t), function (n) { for (let t = Id(n); null !== t; t = Fd(t))for (let e = 10; e < t.length; e++) { const i = t[e], r = i[1]; Ju(i) && ds(r, i, r.template, i[8]) } }(t), null !== n.contentQueries && X_(n, t), !s) if (o) { const c = n.contentCheckHooks; null !== c && il(t, c) } else { const c = n.contentHooks; null !== c && rl(t, c, 1), rd(t, 1) } !function (n, t) { const e = n.hostBindingOpCodes; if (null !== e) try { for (let i = 0; i < e.length; i++) { const r = e[i]; if (r < 0) Ii(~r); else { const s = r, o = e[++i], a = e[++i]; r0(o, s), a(2, t[s]) } } } finally { Ii(-1) } }(n, t); const a = n.components; null !== a && function (n, t) { for (let e = 0; e < t.length; e++)zI(n, t[e]) }(t, a); const l = n.viewQuery; if (null !== l && sf(2, l, i), !s) if (o) { const c = n.viewCheckHooks; null !== c && il(t, c) } else { const c = n.viewHooks; null !== c && rl(t, c, 2), rd(t, 2) } !0 === n.firstUpdatePass && (n.firstUpdatePass = !1), s || (t[2] &= -73), 1024 & t[2] && (t[2] &= -1025, Zu(t[3], -1)) } finally { tl() } } function MI(n, t, e, i) { const r = t[10], s = !Za(), o = fm(t); try { s && !o && r.begin && r.begin(), o && Vo(n, t, i), ds(n, t, e, i) } finally { s && !o && r.end && r.end() } } function ey(n, t, e, i, r) { const s = St(), o = 2 & i; try { Ii(-1), o && t.length > 20 && $_(n, t, 20, Za()), e(i, r) } finally { Ii(s) } } function ty(n, t, e) { if (zu(t)) { const r = t.directiveEnd; for (let s = t.directiveStart; s < r; s++) { const o = n.data[s]; o.contentQueries && o.contentQueries(1, e[s], s) } } } function Yd(n, t, e) { !pm() || (function (n, t, e, i) { const r = e.directiveStart, s = e.directiveEnd; n.firstCreatePass || vo(e, t), mt(i, t); const o = e.initialInputs; for (let a = r; a < s; a++) { const l = n.data[a], c = Cn(l); c && HI(t, e, l); const u = bo(t, n, a, e); mt(u, t), null !== o && jI(0, a - r, u, l, 0, o), c && (Gt(e.index, t)[8] = u) } }(n, t, e, nn(e, t)), 128 == (128 & e.flags) && function (n, t, e) { const i = e.directiveStart, r = e.directiveEnd, o = e.index, a = z.lFrame.currentDirectiveIndex; try { Ii(o); for (let l = i; l < r; l++) { const c = n.data[l], u = t[l]; td(l), (null !== c.hostBindings || 0 !== c.hostVars || null !== c.hostAttrs) && cy(c, u) } } finally { Ii(-1), td(a) } }(n, t, e)) } function Jd(n, t, e = nn) { const i = t.localNames; if (null !== i) { let r = t.index + 1; for (let s = 0; s < i.length; s += 2) { const o = i[s + 1], a = -1 === o ? e(t, n) : n[o]; n[r++] = a } } } function ny(n) { const t = n.tView; return null === t || t.incompleteFirstPass ? n.tView = Al(1, null, n.template, n.decls, n.vars, n.directiveDefs, n.pipeDefs, n.viewQuery, n.schemas, n.consts) : t } function Al(n, t, e, i, r, s, o, a, l, c) { const u = 20 + i, d = u + r, f = function (n, t) { const e = []; for (let i = 0; i < t; i++)e.push(i < n ? null : q); return e }(u, d), h = "function" == typeof c ? c() : c; return f[1] = { type: n, blueprint: f, template: e, queries: null, viewQuery: a, declTNode: t, data: f.slice().fill(null, u), bindingStartIndex: u, expandoStartIndex: d, hostBindingOpCodes: null, firstCreatePass: !0, firstUpdatePass: !0, staticViewQueries: !1, staticContentQueries: !1, preOrderHooks: null, preOrderCheckHooks: null, contentHooks: null, contentCheckHooks: null, viewHooks: null, viewCheckHooks: null, destroyHooks: null, cleanup: null, contentQueries: null, components: null, directiveRegistry: "function" == typeof s ? s() : s, pipeRegistry: "function" == typeof o ? o() : o, firstChild: null, schemas: l, consts: h, incompleteFirstPass: !1 } } function sy(n, t, e, i) { const r = gy(t); null === e ? r.push(i) : (r.push(e), n.firstCreatePass && my(n).push(i, r.length - 1)) } function oy(n, t, e) { for (let i in n) if (n.hasOwnProperty(i)) { const r = n[i]; (e = null === e ? {} : e).hasOwnProperty(i) ? e[i].push(t, r) : e[i] = [t, r] } return e } function qt(n, t, e, i, r, s, o, a) { const l = nn(t, e); let u, c = t.inputs; !a && null != c && (u = c[i]) ? (vy(n, e, u, i, r), Qa(t) && function (n, t) { const e = Gt(t, n); 16 & e[2] || (e[2] |= 64) }(e, t.index)) : 3 & t.type && (i = function (n) { return "class" === n ? "className" : "for" === n ? "htmlFor" : "formaction" === n ? "formAction" : "innerHtml" === n ? "innerHTML" : "readonly" === n ? "readOnly" : "tabindex" === n ? "tabIndex" : n }(i), r = null != o ? o(r, t.value || "", i) : r, Ve(s) ? s.setProperty(l, i, r) : od(i) || (l.setProperty ? l.setProperty(i, r) : l[i] = r)) } function Zd(n, t, e, i) { let r = !1; if (pm()) { const s = function (n, t, e) { const i = n.directiveRegistry; let r = null; if (i) for (let s = 0; s < i.length; s++) { const o = i[s]; j_(e, o.selectors, !1) && (r || (r = []), cl(vo(e, t), n, o.type), Cn(o) ? (uy(n, e), r.unshift(o)) : r.push(o)) } return r }(n, t, e), o = null === i ? null : { "": -1 }; if (null !== s) { r = !0, dy(e, n.data.length, s.length); for (let u = 0; u < s.length; u++) { const d = s[u]; d.providersResolver && d.providersResolver(d) } let a = !1, l = !1, c = us(n, t, s.length, null); for (let u = 0; u < s.length; u++) { const d = s[u]; e.mergedAttrs = ol(e.mergedAttrs, d.hostAttrs), fy(n, e, t, c, d), BI(c, d, o), null !== d.contentQueries && (e.flags |= 8), (null !== d.hostBindings || null !== d.hostAttrs || 0 !== d.hostVars) && (e.flags |= 128); const f = d.type.prototype; !a && (f.ngOnChanges || f.ngOnInit || f.ngDoCheck) && ((n.preOrderHooks || (n.preOrderHooks = [])).push(e.index), a = !0), !l && (f.ngOnChanges || f.ngDoCheck) && ((n.preOrderCheckHooks || (n.preOrderCheckHooks = [])).push(e.index), l = !0), c++ } !function (n, t) { const i = t.directiveEnd, r = n.data, s = t.attrs, o = []; let a = null, l = null; for (let c = t.directiveStart; c < i; c++) { const u = r[c], d = u.inputs, f = null === s || H_(t) ? null : GI(d, s); o.push(f), a = oy(d, c, a), l = oy(u.outputs, c, l) } null !== a && (a.hasOwnProperty("class") && (t.flags |= 16), a.hasOwnProperty("style") && (t.flags |= 32)), t.initialInputs = o, t.inputs = a, t.outputs = l }(n, e) } o && function (n, t, e) { if (t) { const i = n.localNames = []; for (let r = 0; r < t.length; r += 2) { const s = e[t[r + 1]]; if (null == s) throw new tr("301", `Export of name '${t[r + 1]}' not found!`); i.push(t[r], s) } } }(e, i, o) } return e.mergedAttrs = ol(e.mergedAttrs, e.attrs), r } function ly(n, t, e, i, r, s) { const o = s.hostBindings; if (o) { let a = n.hostBindingOpCodes; null === a && (a = n.hostBindingOpCodes = []); const l = ~t.index; (function (n) { let t = n.length; for (; t > 0;) { const e = n[--t]; if ("number" == typeof e && e < 0) return e } return 0 })(a) != l && a.push(l), a.push(i, r, o) } } function cy(n, t) { null !== n.hostBindings && n.hostBindings(1, t) } function uy(n, t) { t.flags |= 2, (n.components || (n.components = [])).push(t.index) } function BI(n, t, e) { if (e) { if (t.exportAs) for (let i = 0; i < t.exportAs.length; i++)e[t.exportAs[i]] = n; Cn(t) && (e[""] = n) } } function dy(n, t, e) { n.flags |= 1, n.directiveStart = t, n.directiveEnd = t + e, n.providerIndexes = t } function fy(n, t, e, i, r) { n.data[i] = r; const s = r.factory || (r.factory = or(r.type)), o = new _o(s, Cn(r), null); n.blueprint[i] = o, e[i] = o, ly(n, t, 0, i, us(n, e, r.hostVars, q), r) } function HI(n, t, e) { const i = nn(t, n), r = ny(e), s = n[10], o = Sl(n, Lo(n, r, null, e.onPush ? 64 : 16, i, t, s, s.createRenderer(i, e), null, null)); n[t.index] = o } function Kn(n, t, e, i, r, s) { const o = nn(n, t); !function (n, t, e, i, r, s, o) { if (null == s) Ve(n) ? n.removeAttribute(t, r, e) : t.removeAttribute(r); else { const a = null == o ? J(s) : o(s, i || "", r); Ve(n) ? n.setAttribute(t, r, a, e) : e ? t.setAttributeNS(e, r, a) : t.setAttribute(r, a) } }(t[11], o, s, n.value, e, i, r) } function jI(n, t, e, i, r, s) { const o = s[t]; if (null !== o) { const a = i.setInput; for (let l = 0; l < o.length;) { const c = o[l++], u = o[l++], d = o[l++]; null !== a ? i.setInput(e, d, c, u) : e[u] = d } } } function GI(n, t) { let e = null, i = 0; for (; i < t.length;) { const r = t[i]; if (0 !== r) if (5 !== r) { if ("number" == typeof r) break; n.hasOwnProperty(r) && (null === e && (e = []), e.push(r, n[r], t[i + 1])), i += 2 } else i += 2; else i += 4 } return e } function hy(n, t, e, i) { return new Array(n, !0, !1, t, null, 0, i, e, null, null) } function zI(n, t) { const e = Gt(t, n); if (Ju(e)) { const i = e[1]; 80 & e[2] ? ds(i, e, i.template, e[8]) : e[5] > 0 && ef(e) } } function ef(n) { for (let i = Id(n); null !== i; i = Fd(i))for (let r = 10; r < i.length; r++) { const s = i[r]; if (1024 & s[2]) { const o = s[1]; ds(o, s, o.template, s[8]) } else s[5] > 0 && ef(s) } const e = n[1].components; if (null !== e) for (let i = 0; i < e.length; i++) { const r = Gt(e[i], n); Ju(r) && r[5] > 0 && ef(r) } } function WI(n, t) { const e = Gt(t, n), i = e[1]; (function (n, t) { for (let e = t.length; e < n.blueprint.length; e++)t.push(n.blueprint[e]) })(i, e), Vo(i, e, e[8]) } function Sl(n, t) { return n[13] ? n[14][4] = t : n[13] = t, n[14] = t, t } function tf(n) { for (; n;) { n[2] |= 64; const t = No(n); if (VS(n) && !t) return n; n = t } return null } function rf(n, t, e) { const i = t[10]; i.begin && i.begin(); try { ds(n, t, n.template, e) } catch (r) { throw yy(t, r), r } finally { i.end && i.end() } } function py(n) { !function (n) { for (let t = 0; t < n.components.length; t++) { const e = n.components[t], i = Md(e), r = i[1]; MI(r, i, r.template, e) } }(n[8]) } function sf(n, t, e) { id(0), t(n, e) } const JI = (() => Promise.resolve(null))(); function gy(n) { return n[7] || (n[7] = []) } function my(n) { return n.cleanup || (n.cleanup = []) } function _y(n, t, e) { return (null === n || Cn(n)) && (e = function (n) { for (; Array.isArray(n);) { if ("object" == typeof n[1]) return n; n = n[0] } return null }(e[t.index])), e[11] } function yy(n, t) { const e = n[9], i = e ? e.get(wn, null) : null; i && i.handleError(t) } function vy(n, t, e, i, r) { for (let s = 0; s < e.length;) { const o = e[s++], a = e[s++], l = t[o], c = n.data[o]; null !== c.setInput ? c.setInput(l, r, i, a) : l[a] = r } } function di(n, t, e) { const i = Ja(t, n); !function (n, t, e) { Ve(n) ? n.setValue(t, e) : t.textContent = e }(n[11], i, e) } function Tl(n, t, e) { let i = e ? n.styles : null, r = e ? n.classes : null, s = 0; if (null !== t) for (let o = 0; o < t.length; o++) { const a = t[o]; "number" == typeof a ? s = a : 1 == s ? r = Lu(r, a) : 2 == s && (i = Lu(i, a + ": " + t[++o] + ";")) } e ? n.styles = i : n.stylesWithoutHost = i, e ? n.classes = r : n.classesWithoutHost = r } const fr = new k("INJECTOR", -1); class by { get(t, e = xo) { if (e === xo) { const i = new Error(`NullInjectorError: No provider for ${re(t)}!`); throw i.name = "NullInjectorError", i } return e } } const Bo = new k("Set Injector scope."), Ho = {}, eF = {}; let af; function Cy() { return void 0 === af && (af = new by), af } function wy(n, t = null, e = null, i) { return new nF(n, e, t || Cy(), i) } class nF { constructor(t, e, i, r = null) { this.parent = i, this.records = new Map, this.injectorDefTypes = new Set, this.onDestroy = new Set, this._destroyed = !1; const s = []; e && Un(e, a => this.processProvider(a, t, e)), Un([t], a => this.processInjectorType(a, [], s)), this.records.set(fr, fs(void 0, this)); const o = this.records.get(Bo); this.scope = null != o ? o.value : null, this.source = r || ("object" == typeof t ? null : re(t)) } get destroyed() { return this._destroyed } destroy() { this.assertNotDestroyed(), this._destroyed = !0; try { this.onDestroy.forEach(t => t.ngOnDestroy()) } finally { this.records.clear(), this.onDestroy.clear(), this.injectorDefTypes.clear() } } get(t, e = xo, i = G.Default) { this.assertNotDestroyed(); const r = rs(this), s = Mi(void 0); try { if (!(i & G.SkipSelf)) { let a = this.records.get(t); if (void 0 === a) { const l = function (n) { return "function" == typeof n || "object" == typeof n && n instanceof k }(t) && si(t); a = l && this.injectableDefInScope(l) ? fs(lf(t), Ho) : null, this.records.set(t, a) } if (null != a) return this.hydrate(t, a) } return (i & G.Self ? Cy() : this.parent).get(t, e = i & G.Optional && e === xo ? null : e) } catch (o) { if ("NullInjectorError" === o.name) { if ((o[is] = o[is] || []).unshift(re(t)), r) throw o; return jm(o, t, "R3InjectorError", this.source) } throw o } finally { Mi(s), rs(r) } } _resolveInjectorDefTypes() { this.injectorDefTypes.forEach(t => this.get(t)) } toString() { const t = []; return this.records.forEach((i, r) => t.push(re(r))), `R3Injector[${t.join(", ")}]` } assertNotDestroyed() { if (this._destroyed) throw new Error("Injector has already been destroyed.") } processInjectorType(t, e, i) { if (!(t = L(t))) return !1; let r = Yg(t); const s = null == r && t.ngModule || void 0, o = void 0 === s ? t : s, a = -1 !== i.indexOf(o); if (void 0 !== s && (r = Yg(s)), null == r) return !1; if (null != r.imports && !a) { let u; i.push(o); try { Un(r.imports, d => { this.processInjectorType(d, e, i) && (void 0 === u && (u = []), u.push(d)) }) } finally { } if (void 0 !== u) for (let d = 0; d < u.length; d++) { const { ngModule: f, providers: h } = u[d]; Un(h, p => this.processProvider(p, f, h || we)) } } this.injectorDefTypes.add(o); const l = or(o) || (() => new o); this.records.set(o, fs(l, Ho)); const c = r.providers; if (null != c && !a) { const u = t; Un(c, d => this.processProvider(d, u, c)) } return void 0 !== s && void 0 !== t.providers } processProvider(t, e, i) { let r = hs(t = L(t)) ? t : L(t && t.provide); const s = function (n, t, e) { return Dy(n) ? fs(void 0, n.useValue) : fs(Ey(n), Ho) }(t); if (hs(t) || !0 !== t.multi) this.records.get(r); else { let o = this.records.get(r); o || (o = fs(void 0, Ho, !0), o.factory = () => cr(o.multi), this.records.set(r, o)), r = t, o.multi.push(t) } this.records.set(r, s) } hydrate(t, e) { return e.value === Ho && (e.value = eF, e.value = e.factory()), "object" == typeof e.value && e.value && function (n) { return null !== n && "object" == typeof n && "function" == typeof n.ngOnDestroy }(e.value) && this.onDestroy.add(e.value), e.value } injectableDefInScope(t) { if (!t.providedIn) return !1; const e = L(t.providedIn); return "string" == typeof e ? "any" === e || e === this.scope : this.injectorDefTypes.has(e) } } function lf(n) { const t = si(n), e = null !== t ? t.factory : or(n); if (null !== e) return e; if (n instanceof k) throw new Error(`Token ${re(n)} is missing a \u0275prov definition.`); if (n instanceof Function) return function (n) { const t = n.length; if (t > 0) { const i = Ri(t, "?"); throw new Error(`Can't resolve all parameters for ${re(n)}: (${i.join(", ")}).`) } const e = function (n) { const t = n && (n[Ua] || n[Jg]); if (t) { const e = function (n) { if (n.hasOwnProperty("name")) return n.name; const t = ("" + n).match(/^function\s*([^\s(]+)/); return null === t ? "" : t[1] }(n); return console.warn(`DEPRECATED: DI is instantiating a token "${e}" that inherits its @Injectable decorator but does not provide one itself.\nThis will become an error in a future version of Angular. Please add @Injectable() to the "${e}" class.`), t } return null }(n); return null !== e ? () => e.factory(n) : () => new n }(n); throw new Error("unreachable") } function Ey(n, t, e) { let i; if (hs(n)) { const r = L(n); return or(r) || lf(r) } if (Dy(n)) i = () => L(n.useValue); else if (function (n) { return !(!n || !n.useFactory) }(n)) i = () => n.useFactory(...cr(n.deps || [])); else if (function (n) { return !(!n || !n.useExisting) }(n)) i = () => m(L(n.useExisting)); else { const r = L(n && (n.useClass || n.provide)); if (!function (n) { return !!n.deps }(n)) return or(r) || lf(r); i = () => new r(...cr(n.deps)) } return i } function fs(n, t, e = !1) { return { factory: n, value: t, multi: e ? [] : void 0 } } function Dy(n) { return null !== n && "object" == typeof n && _d in n } function hs(n) { return "function" == typeof n } const xy = function (n, t, e) { return function (n, t = null, e = null, i) { const r = wy(n, t, e, i); return r._resolveInjectorDefTypes(), r }({ name: e }, t, n, e) }; class ce { static create(t, e) { return Array.isArray(t) ? xy(t, e, "") : xy(t.providers, t.parent, t.name || "") } } function EF(n, t) { nl(Md(n)[1], it()) } function D(n) { let t = function (n) { return Object.getPrototypeOf(n.prototype).constructor }(n.type), e = !0; const i = [n]; for (; t;) { let r; if (Cn(n)) r = t.\u0275cmp || t.\u0275dir; else { if (t.\u0275cmp) throw new Error("Directives cannot inherit Components"); r = t.\u0275dir } if (r) { if (e) { i.push(r); const o = n; o.inputs = pf(n.inputs), o.declaredInputs = pf(n.declaredInputs), o.outputs = pf(n.outputs); const a = r.hostBindings; a && AF(n, a); const l = r.viewQuery, c = r.contentQueries; if (l && xF(n, l), c && MF(n, c), Pu(n.inputs, r.inputs), Pu(n.declaredInputs, r.declaredInputs), Pu(n.outputs, r.outputs), Cn(r) && r.data.animation) { const u = n.data; u.animation = (u.animation || []).concat(r.data.animation) } } const s = r.features; if (s) for (let o = 0; o < s.length; o++) { const a = s[o]; a && a.ngInherit && a(n), a === D && (e = !1) } } t = Object.getPrototypeOf(t) } !function (n) { let t = 0, e = null; for (let i = n.length - 1; i >= 0; i--) { const r = n[i]; r.hostVars = t += r.hostVars, r.hostAttrs = ol(r.hostAttrs, e = ol(e, r.hostAttrs)) } }(i) } function pf(n) { return n === $r ? {} : n === we ? [] : n } function xF(n, t) { const e = n.viewQuery; n.viewQuery = e ? (i, r) => { t(i, r), e(i, r) } : t } function MF(n, t) { const e = n.contentQueries; n.contentQueries = e ? (i, r, s) => { t(i, r, s), e(i, r, s) } : t } function AF(n, t) { const e = n.hostBindings; n.hostBindings = e ? (i, r) => { t(i, r), e(i, r) } : t } ce.THROW_IF_NOT_FOUND = xo, ce.NULL = new by, ce.\u0275prov = E({ token: ce, providedIn: "any", factory: () => m(fr) }), ce.__NG_ELEMENT_ID__ = -1; let Il = null; function ps() { if (!Il) { const n = _e.Symbol; if (n && n.iterator) Il = n.iterator; else { const t = Object.getOwnPropertyNames(Map.prototype); for (let e = 0; e < t.length; ++e) { const i = t[e]; "entries" !== i && "size" !== i && Map.prototype[i] === Map.prototype.entries && (Il = i) } } } return Il } function Go(n) { return !!gf(n) && (Array.isArray(n) || !(n instanceof Map) && ps() in n) } function gf(n) { return null !== n && ("function" == typeof n || "object" == typeof n) } function _t(n, t, e) { return !Object.is(n[t], e) && (n[t] = e, !0) } function Qe(n, t, e, i) { const r = w(); return _t(r, Qr(), t) && (ue(), Kn(Be(), r, n, t, e, i)), Qe } function Ee(n, t, e, i, r, s, o, a) { const l = w(), c = ue(), u = n + 20, d = c.firstCreatePass ? function (n, t, e, i, r, s, o, a, l) { const c = t.consts, u = cs(t, n, 4, o || null, Ti(c, a)); Zd(t, e, u, Ti(c, l)), nl(t, u); const d = u.tViews = Al(2, u, i, r, s, t.directiveRegistry, t.pipeRegistry, null, t.schemas, c); return null !== t.queries && (t.queries.template(t, u), d.queries = t.queries.embeddedTView(u)), u }(u, c, l, t, e, i, r, s, o) : c.data[u]; Gn(d, !1); const f = l[11].createComment(""); wl(c, l, f, d), mt(f, l), Sl(l, l[u] = hy(f, l, f, d)), Ya(d) && Yd(c, l, d), null != o && Jd(l, d, a) } function g(n, t = G.Default) { const e = w(); return null === e ? m(n, t) : Rm(it(), e, L(n), t) } function K(n, t, e) { const i = w(); return _t(i, Qr(), t) && qt(ue(), Be(), i, n, t, i[11], e, !1), K } function bf(n, t, e, i, r) { const o = r ? "class" : "style"; vy(n, e, t.inputs[o], o, i) } function x(n, t, e, i) { const r = w(), s = ue(), o = 20 + n, a = r[11], l = r[o] = kd(a, t, z.lFrame.currentNamespace), c = s.firstCreatePass ? function (n, t, e, i, r, s, o) { const a = t.consts, c = cs(t, n, 2, r, Ti(a, s)); return Zd(t, e, c, Ti(a, o)), null !== c.attrs && Tl(c, c.attrs, !1), null !== c.mergedAttrs && Tl(c, c.mergedAttrs, !0), null !== t.queries && t.queries.elementStart(t, c), c }(o, s, r, 0, t, e, i) : s.data[o]; Gn(c, !0); const u = c.mergedAttrs; null !== u && sl(a, l, u); const d = c.classes; null !== d && Bd(a, l, d); const f = c.styles; null !== f && L_(a, l, f), 64 != (64 & c.flags) && wl(s, r, l, c), 0 === z.lFrame.elementDepthCount && mt(l, r), z.lFrame.elementDepthCount++, Ya(c) && (Yd(s, r, c), ty(s, c, r)), null !== i && Jd(r, c) } function M() { let n = it(); Xu() ? ed() : (n = n.parent, Gn(n, !1)); const t = n; z.lFrame.elementDepthCount--; const e = ue(); e.firstCreatePass && (nl(e, n), zu(n) && e.queries.elementEnd(n)), null != t.classesWithoutHost && function (n) { return 0 != (16 & n.flags) }(t) && bf(e, t, w(), t.classesWithoutHost, !0), null != t.stylesWithoutHost && function (n) { return 0 != (32 & n.flags) }(t) && bf(e, t, w(), t.stylesWithoutHost, !1) } function Ye(n, t, e, i) { x(n, t, e, i), M() } function kl(n, t, e) { const i = w(), r = ue(), s = n + 20, o = r.firstCreatePass ? function (n, t, e, i, r) { const s = t.consts, o = Ti(s, i), a = cs(t, n, 8, "ng-container", o); return null !== o && Tl(a, o, !0), Zd(t, e, a, Ti(s, r)), null !== t.queries && t.queries.elementStart(t, a), a }(s, r, i, t, e) : r.data[s]; Gn(o, !0); const a = i[s] = i[11].createComment(""); wl(r, i, a, o), mt(a, i), Ya(o) && (Yd(r, i, o), ty(r, o, i)), null != e && Jd(i, o) } function Ol() { let n = it(); const t = ue(); Xu() ? ed() : (n = n.parent, Gn(n, !1)), t.firstCreatePass && (nl(t, n), zu(n) && t.queries.elementEnd(n)) } function pr() { return w() } function Nl(n) { return !!n && "function" == typeof n.then } const Cf = function (n) { return !!n && "function" == typeof n.subscribe }; function ye(n, t, e, i) { const r = w(), s = ue(), o = it(); return dv(s, r, r[11], o, n, t, !!e, i), ye } function wf(n, t) { const e = it(), i = w(), r = ue(); return dv(r, i, _y(nd(r.data), e, i), e, n, t, !1), wf } function dv(n, t, e, i, r, s, o, a) { const l = Ya(i), u = n.firstCreatePass && my(n), d = t[8], f = gy(t); let h = !0; if (3 & i.type || a) { const _ = nn(i, t), b = a ? a(_) : _, v = f.length, S = a ? I => a(Ke(I[i.index])) : i.index; if (Ve(e)) { let I = null; if (!a && l && (I = function (n, t, e, i) { const r = n.cleanup; if (null != r) for (let s = 0; s < r.length - 1; s += 2) { const o = r[s]; if (o === e && r[s + 1] === i) { const a = t[7], l = r[s + 2]; return a.length > l ? a[l] : null } "string" == typeof o && (s += 2) } return null }(n, t, r, i.index)), null !== I) (I.__ngLastListenerFn__ || I).__ngNextListenerFn__ = s, I.__ngLastListenerFn__ = s, h = !1; else { s = Ef(i, t, d, s, !1); const U = e.listen(b, r, s); f.push(s, U), u && u.push(r, S, v, v + 1) } } else s = Ef(i, t, d, s, !0), b.addEventListener(r, s, o), f.push(s), u && u.push(r, S, v, o) } else s = Ef(i, t, d, s, !1); const p = i.outputs; let y; if (h && null !== p && (y = p[r])) { const _ = y.length; if (_) for (let b = 0; b < _; b += 2) { const be = t[y[b]][y[b + 1]].subscribe(s), De = f.length; f.push(s, be), u && u.push(r, i.index, De, -(De + 1)) } } } function fv(n, t, e, i) { try { return !1 !== e(i) } catch (r) { return yy(n, r), !1 } } function Ef(n, t, e, i, r) { return function s(o) { if (o === Function) return i; const a = 2 & n.flags ? Gt(n.index, t) : t; 0 == (32 & t[2]) && tf(a); let l = fv(t, 0, i, o), c = s.__ngNextListenerFn__; for (; c;)l = fv(t, 0, c, o) && l, c = c.__ngNextListenerFn__; return r && !1 === l && (o.preventDefault(), o.returnValue = !1), l } } function He(n = 1) { return function (n) { return (z.lFrame.contextLView = function (n, t) { for (; n > 0;)t = t[15], n--; return t }(n, z.lFrame.contextLView))[8] }(n) } function lR(n, t) { let e = null; const i = function (n) { const t = n.attrs; if (null != t) { const e = t.indexOf(5); if (0 == (1 & e)) return t[e + 1] } return null }(n); for (let r = 0; r < t.length; r++) { const s = t[r]; if ("*" !== s) { if (null === i ? j_(n, s, !0) : fI(i, s)) return r } else e = r } return e } function an(n) { const t = w()[16][6]; if (!t.projection) { const i = t.projection = Ri(n ? n.length : 1, null), r = i.slice(); let s = t.child; for (; null !== s;) { const o = n ? lR(s, n) : 0; null !== o && (r[o] ? r[o].projectionNext = s : i[o] = s, r[o] = s), s = s.next } } } function Ae(n, t = 0, e) { const i = w(), r = ue(), s = cs(r, 20 + n, 16, null, e || null); null === s.projection && (s.projection = t), ed(), 64 != (64 & s.flags) && function (n, t, e) { P_(t[11], 0, t, e, M_(n, e, t), I_(e.parent || t[6], e, t)) }(r, i, s) } function wv(n, t, e, i, r) { const s = n[e + 1], o = null === t; let a = i ? Dn(s) : ci(s), l = !1; for (; 0 !== a && (!1 === l || o);) { const u = n[a + 1]; dR(n[a], t) && (l = !0, n[a + 1] = i ? Gd(u) : Hd(u)), a = i ? Dn(u) : ci(u) } l && (n[e + 1] = i ? Hd(s) : Gd(s)) } function dR(n, t) { return null === n || null == t || (Array.isArray(n) ? n[1] : n) === t || !(!Array.isArray(n) || "string" != typeof t) && ns(n, t) >= 0 } function je(n, t) { return function (n, t, e, i) { const r = w(), s = ue(), o = function (n) { const t = z.lFrame, e = t.bindingIndex; return t.bindingIndex = t.bindingIndex + n, e }(2); s.firstUpdatePass && function (n, t, e, i) { const r = n.data; if (null === r[e + 1]) { const s = r[St()], o = function (n, t) { return t >= n.expandoStartIndex }(n, e); (function (n, t) { return 0 != (n.flags & (t ? 16 : 32)) })(s, i) && null === t && !o && (t = !1), t = function (n, t, e, i) { const r = nd(n); let s = i ? t.residualClasses : t.residualStyles; if (null === r) 0 === (i ? t.classBindings : t.styleBindings) && (e = Uo(e = Mf(null, n, t, e, i), t.attrs, i), s = null); else { const o = t.directiveStylingLast; if (-1 === o || n[o] !== r) if (e = Mf(r, n, t, e, i), null === s) { let l = function (n, t, e) { const i = e ? t.classBindings : t.styleBindings; if (0 !== ci(i)) return n[Dn(i)] }(n, t, i); void 0 !== l && Array.isArray(l) && (l = Mf(null, n, t, l[1], i), l = Uo(l, t.attrs, i), function (n, t, e, i) { n[Dn(e ? t.classBindings : t.styleBindings)] = i }(n, t, i, l)) } else s = function (n, t, e) { let i; const r = t.directiveEnd; for (let s = 1 + t.directiveStylingLast; s < r; s++)i = Uo(i, n[s].hostAttrs, e); return Uo(i, t.attrs, e) }(n, t, i) } return void 0 !== s && (i ? t.residualClasses = s : t.residualStyles = s), e }(r, s, t, i), function (n, t, e, i, r, s) { let o = s ? t.classBindings : t.styleBindings, a = Dn(o), l = ci(o); n[i] = e; let u, c = !1; if (Array.isArray(e)) { const d = e; u = d[1], (null === u || ns(d, u) > 0) && (c = !0) } else u = e; if (r) if (0 !== l) { const f = Dn(n[a + 1]); n[i + 1] = Dl(f, a), 0 !== f && (n[f + 1] = jd(n[f + 1], i)), n[a + 1] = function (n, t) { return 131071 & n | t << 17 }(n[a + 1], i) } else n[i + 1] = Dl(a, 0), 0 !== a && (n[a + 1] = jd(n[a + 1], i)), a = i; else n[i + 1] = Dl(l, 0), 0 === a ? a = i : n[l + 1] = jd(n[l + 1], i), l = i; c && (n[i + 1] = Hd(n[i + 1])), wv(n, u, i, !0), wv(n, u, i, !1), function (n, t, e, i, r) { const s = r ? n.residualClasses : n.residualStyles; null != s && "string" == typeof t && ns(s, t) >= 0 && (e[i + 1] = Gd(e[i + 1])) }(t, u, n, i, s), o = Dl(a, l), s ? t.classBindings = o : t.styleBindings = o }(r, s, t, e, o, i) } }(s, n, o, i), t !== q && _t(r, o, t) && function (n, t, e, i, r, s, o, a) { if (!(3 & t.type)) return; const l = n.data, c = l[a + 1]; Pl(function (n) { return 1 == (1 & n) }(c) ? kv(l, t, e, r, ci(c), o) : void 0) || (Pl(s) || function (n) { return 2 == (2 & n) }(c) && (s = kv(l, null, e, r, a, o)), function (n, t, e, i, r) { const s = Ve(n); if (t) r ? s ? n.addClass(e, i) : e.classList.add(i) : s ? n.removeClass(e, i) : e.classList.remove(i); else { let o = -1 === i.indexOf("-") ? void 0 : Wt.DashCase; if (null == r) s ? n.removeStyle(e, i, o) : e.style.removeProperty(i); else { const a = "string" == typeof r && r.endsWith("!important"); a && (r = r.slice(0, -10), o |= Wt.Important), s ? n.setStyle(e, i, r, o) : e.style.setProperty(i, r, a ? "important" : "") } } }(i, o, Ja(St(), e), r, s)) }(s, s.data[St()], r, r[11], n, r[o + 1] = function (n, t) { return null == n || ("string" == typeof t ? n += t : "object" == typeof n && (n = re(zt(n)))), n }(t, e), i, o) }(n, t, null, !0), je } function Mf(n, t, e, i, r) { let s = null; const o = e.directiveEnd; let a = e.directiveStylingLast; for (-1 === a ? a = e.directiveStart : a++; a < o && (s = t[a], i = Uo(i, s.hostAttrs, r), s !== n);)a++; return null !== n && (e.directiveStylingLast = a), i } function Uo(n, t, e) { const i = e ? 1 : 2; let r = -1; if (null !== t) for (let s = 0; s < t.length; s++) { const o = t[s]; "number" == typeof o ? r = o : r === i && (Array.isArray(n) || (n = void 0 === n ? [] : ["", n]), $t(n, o, !!e || t[++s])) } return void 0 === n ? null : n } function kv(n, t, e, i, r, s) { const o = null === t; let a; for (; r > 0;) { const l = n[r], c = Array.isArray(l), u = c ? l[1] : l, d = null === u; let f = e[r + 1]; f === q && (f = d ? we : void 0); let h = d ? hd(f, i) : u === i ? f : void 0; if (c && !Pl(h) && (h = hd(l, i)), Pl(h) && (a = h, o)) return a; const p = n[r + 1]; r = o ? Dn(p) : ci(p) } if (null !== t) { let l = s ? t.residualClasses : t.residualStyles; null != l && (a = hd(l, i)) } return a } function Pl(n) { return void 0 !== n } function oe(n, t = "") { const e = w(), i = ue(), r = n + 20, s = i.firstCreatePass ? cs(i, r, 1, t, null) : i.data[r], o = e[r] = function (n, t) { return Ve(n) ? n.createText(t) : n.createTextNode(t) }(e[11], t); wl(i, e, o, s), Gn(s, !1) } function Ms(n) { return ln("", n, ""), Ms } function ln(n, t, e) { const i = w(), r = function (n, t, e, i) { return _t(n, Qr(), e) ? t + J(e) + i : q }(i, n, t, e); return r !== q && di(i, St(), r), ln } function Ll(n, t, e) { const i = w(); return _t(i, Qr(), t) && qt(ue(), Be(), i, n, t, i[11], e, !0), Ll } function Af(n, t, e) { const i = w(); if (_t(i, Qr(), t)) { const s = ue(), o = Be(); qt(s, o, i, n, t, _y(nd(s.data), o, i), e, !0) } return Af } const gr = void 0; var WR = ["en", [["a", "p"], ["AM", "PM"], gr], [["AM", "PM"], gr, gr], [["S", "M", "T", "W", "T", "F", "S"], ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"]], gr, [["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"], ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]], gr, [["B", "A"], ["BC", "AD"], ["Before Christ", "Anno Domini"]], 0, [6, 0], ["M/d/yy", "MMM d, y", "MMMM d, y", "EEEE, MMMM d, y"], ["h:mm a", "h:mm:ss a", "h:mm:ss a z", "h:mm:ss a zzzz"], ["{1}, {0}", gr, "{1} 'at' {0}", gr], [".", ",", ";", "%", "+", "-", "E", "\xd7", "\u2030", "\u221e", "NaN", ":"], ["#,##0.###", "#,##0%", "\xa4#,##0.00", "#E0"], "USD", "$", "US Dollar", {}, "ltr", function (n) { const t = Math.floor(Math.abs(n)), e = n.toString().replace(/^[^.]*\.?/, "").length; return 1 === t && 0 === e ? 1 : 5 }]; let As = {}; function Xv(n) { return n in As || (As[n] = _e.ng && _e.ng.common && _e.ng.common.locales && _e.ng.common.locales[n]), As[n] } var F = (() => ((F = F || {})[F.LocaleId = 0] = "LocaleId", F[F.DayPeriodsFormat = 1] = "DayPeriodsFormat", F[F.DayPeriodsStandalone = 2] = "DayPeriodsStandalone", F[F.DaysFormat = 3] = "DaysFormat", F[F.DaysStandalone = 4] = "DaysStandalone", F[F.MonthsFormat = 5] = "MonthsFormat", F[F.MonthsStandalone = 6] = "MonthsStandalone", F[F.Eras = 7] = "Eras", F[F.FirstDayOfWeek = 8] = "FirstDayOfWeek", F[F.WeekendRange = 9] = "WeekendRange", F[F.DateFormat = 10] = "DateFormat", F[F.TimeFormat = 11] = "TimeFormat", F[F.DateTimeFormat = 12] = "DateTimeFormat", F[F.NumberSymbols = 13] = "NumberSymbols", F[F.NumberFormats = 14] = "NumberFormats", F[F.CurrencyCode = 15] = "CurrencyCode", F[F.CurrencySymbol = 16] = "CurrencySymbol", F[F.CurrencyName = 17] = "CurrencyName", F[F.Currencies = 18] = "Currencies", F[F.Directionality = 19] = "Directionality", F[F.PluralCase = 20] = "PluralCase", F[F.ExtraData = 21] = "ExtraData", F))(); const Vl = "en-US"; let eb = Vl; function Sf(n) { Ht(n, "Expected localeId to be defined"), "string" == typeof n && (eb = n.toLowerCase().replace(/_/g, "-")) } function Ff(n, t, e, i, r) { if (n = L(n), Array.isArray(n)) for (let s = 0; s < n.length; s++)Ff(n[s], t, e, i, r); else { const s = ue(), o = w(); let a = hs(n) ? n : L(n.provide), l = Ey(n); const c = it(), u = 1048575 & c.providerIndexes, d = c.directiveStart, f = c.providerIndexes >> 20; if (hs(n) || !n.multi) { const h = new _o(l, r, g), p = kf(a, t, r ? u : u + f, d); -1 === p ? (cl(vo(c, o), s, a), Rf(s, n, t.length), t.push(a), c.directiveStart++, c.directiveEnd++, r && (c.providerIndexes += 1048576), e.push(h), o.push(h)) : (e[p] = h, o[p] = h) } else { const h = kf(a, t, u + f, d), p = kf(a, t, u, u + f), y = h >= 0 && e[h], _ = p >= 0 && e[p]; if (r && !_ || !r && !y) { cl(vo(c, o), s, a); const b = function (n, t, e, i, r) { const s = new _o(n, e, g); return s.multi = [], s.index = t, s.componentProviders = 0, Db(s, r, i && !e), s }(r ? $k : Gk, e.length, r, i, l); !r && _ && (e[p].providerFactory = b), Rf(s, n, t.length, 0), t.push(a), c.directiveStart++, c.directiveEnd++, r && (c.providerIndexes += 1048576), e.push(b), o.push(b) } else Rf(s, n, h > -1 ? h : p, Db(e[r ? p : h], l, !r && i)); !r && i && _ && e[p].componentProviders++ } } } function Rf(n, t, e, i) { const r = hs(t); if (r || function (n) { return !!n.useClass }(t)) { const o = (t.useClass || t).prototype.ngOnDestroy; if (o) { const a = n.destroyHooks || (n.destroyHooks = []); if (!r && t.multi) { const l = a.indexOf(e); -1 === l ? a.push(e, [i, o]) : a[l + 1].push(i, o) } else a.push(e, o) } } } function Db(n, t, e) { return e && n.componentProviders++, n.multi.push(t) - 1 } function kf(n, t, e, i) { for (let r = e; r < i; r++)if (t[r] === n) return r; return -1 } function Gk(n, t, e, i) { return Of(this.multi, []) } function $k(n, t, e, i) { const r = this.multi; let s; if (this.providerFactory) { const o = this.providerFactory.componentProviders, a = bo(e, e[1], this.providerFactory.index, i); s = a.slice(0, o), Of(r, s); for (let l = o; l < a.length; l++)s.push(a[l]) } else s = [], Of(r, s); return s } function Of(n, t) { for (let e = 0; e < n.length; e++)t.push((0, n[e])()); return t } function ae(n, t = []) { return e => { e.providersResolver = (i, r) => function (n, t, e) { const i = ue(); if (i.firstCreatePass) { const r = Cn(n); Ff(e, i.data, i.blueprint, r, !0), Ff(t, i.data, i.blueprint, r, !1) } }(i, r ? r(n) : n, t) } } class xb { } const Ab = "ngComponent"; class Wk { resolveComponentFactory(t) { throw function (n) { const t = Error(`No component factory found for ${re(n)}. Did you add it to @NgModule.entryComponents?`); return t[Ab] = n, t }(t) } } class hi { } function $l(...n) { } function Ts(n, t) { return new O(nn(n, t)) } hi.NULL = new Wk; const Qk = function () { return Ts(it(), w()) }; let O = (() => { class n { constructor(e) { this.nativeElement = e } } return n.__NG_ELEMENT_ID__ = Qk, n })(); function Sb(n) { return n instanceof O ? n.nativeElement : n } class mr { } let pi = (() => { class n { } return n.__NG_ELEMENT_ID__ = () => Jk(), n })(); const Jk = function () { const n = w(), e = Gt(it().index, n); return function (n) { return n[11] }(jn(e) ? e : n) }; let Pf = (() => { class n { } return n.\u0275prov = E({ token: n, providedIn: "root", factory: () => null }), n })(); class Pi { constructor(t) { this.full = t, this.major = t.split(".")[0], this.minor = t.split(".")[1], this.patch = t.split(".").slice(2).join(".") } } const Tb = new Pi("12.2.1"); class Ib { constructor() { } supports(t) { return Go(t) } create(t) { return new tO(t) } } const eO = (n, t) => t; class tO { constructor(t) { this.length = 0, this._linkedRecords = null, this._unlinkedRecords = null, this._previousItHead = null, this._itHead = null, this._itTail = null, this._additionsHead = null, this._additionsTail = null, this._movesHead = null, this._movesTail = null, this._removalsHead = null, this._removalsTail = null, this._identityChangesHead = null, this._identityChangesTail = null, this._trackByFn = t || eO } forEachItem(t) { let e; for (e = this._itHead; null !== e; e = e._next)t(e) } forEachOperation(t) { let e = this._itHead, i = this._removalsHead, r = 0, s = null; for (; e || i;) { const o = !i || e && e.currentIndex < Rb(i, r, s) ? e : i, a = Rb(o, r, s), l = o.currentIndex; if (o === i) r--, i = i._nextRemoved; else if (e = e._next, null == o.previousIndex) r++; else { s || (s = []); const c = a - r, u = l - r; if (c != u) { for (let f = 0; f < c; f++) { const h = f < s.length ? s[f] : s[f] = 0, p = h + f; u <= p && p < c && (s[f] = h + 1) } s[o.previousIndex] = u - c } } a !== l && t(o, a, l) } } forEachPreviousItem(t) { let e; for (e = this._previousItHead; null !== e; e = e._nextPrevious)t(e) } forEachAddedItem(t) { let e; for (e = this._additionsHead; null !== e; e = e._nextAdded)t(e) } forEachMovedItem(t) { let e; for (e = this._movesHead; null !== e; e = e._nextMoved)t(e) } forEachRemovedItem(t) { let e; for (e = this._removalsHead; null !== e; e = e._nextRemoved)t(e) } forEachIdentityChange(t) { let e; for (e = this._identityChangesHead; null !== e; e = e._nextIdentityChange)t(e) } diff(t) { if (null == t && (t = []), !Go(t)) throw new Error(`Error trying to diff '${re(t)}'. Only arrays and iterables are allowed`); return this.check(t) ? this : null } onDestroy() { } check(t) { this._reset(); let r, s, o, e = this._itHead, i = !1; if (Array.isArray(t)) { this.length = t.length; for (let a = 0; a < this.length; a++)s = t[a], o = this._trackByFn(a, s), null !== e && Object.is(e.trackById, o) ? (i && (e = this._verifyReinsertion(e, s, o, a)), Object.is(e.item, s) || this._addIdentityChange(e, s)) : (e = this._mismatch(e, s, o, a), i = !0), e = e._next } else r = 0, function (n, t) { if (Array.isArray(n)) for (let e = 0; e < n.length; e++)t(n[e]); else { const e = n[ps()](); let i; for (; !(i = e.next()).done;)t(i.value) } }(t, a => { o = this._trackByFn(r, a), null !== e && Object.is(e.trackById, o) ? (i && (e = this._verifyReinsertion(e, a, o, r)), Object.is(e.item, a) || this._addIdentityChange(e, a)) : (e = this._mismatch(e, a, o, r), i = !0), e = e._next, r++ }), this.length = r; return this._truncate(e), this.collection = t, this.isDirty } get isDirty() { return null !== this._additionsHead || null !== this._movesHead || null !== this._removalsHead || null !== this._identityChangesHead } _reset() { if (this.isDirty) { let t; for (t = this._previousItHead = this._itHead; null !== t; t = t._next)t._nextPrevious = t._next; for (t = this._additionsHead; null !== t; t = t._nextAdded)t.previousIndex = t.currentIndex; for (this._additionsHead = this._additionsTail = null, t = this._movesHead; null !== t; t = t._nextMoved)t.previousIndex = t.currentIndex; this._movesHead = this._movesTail = null, this._removalsHead = this._removalsTail = null, this._identityChangesHead = this._identityChangesTail = null } } _mismatch(t, e, i, r) { let s; return null === t ? s = this._itTail : (s = t._prev, this._remove(t)), null !== (t = null === this._unlinkedRecords ? null : this._unlinkedRecords.get(i, null)) ? (Object.is(t.item, e) || this._addIdentityChange(t, e), this._reinsertAfter(t, s, r)) : null !== (t = null === this._linkedRecords ? null : this._linkedRecords.get(i, r)) ? (Object.is(t.item, e) || this._addIdentityChange(t, e), this._moveAfter(t, s, r)) : t = this._addAfter(new nO(e, i), s, r), t } _verifyReinsertion(t, e, i, r) { let s = null === this._unlinkedRecords ? null : this._unlinkedRecords.get(i, null); return null !== s ? t = this._reinsertAfter(s, t._prev, r) : t.currentIndex != r && (t.currentIndex = r, this._addToMoves(t, r)), t } _truncate(t) { for (; null !== t;) { const e = t._next; this._addToRemovals(this._unlink(t)), t = e } null !== this._unlinkedRecords && this._unlinkedRecords.clear(), null !== this._additionsTail && (this._additionsTail._nextAdded = null), null !== this._movesTail && (this._movesTail._nextMoved = null), null !== this._itTail && (this._itTail._next = null), null !== this._removalsTail && (this._removalsTail._nextRemoved = null), null !== this._identityChangesTail && (this._identityChangesTail._nextIdentityChange = null) } _reinsertAfter(t, e, i) { null !== this._unlinkedRecords && this._unlinkedRecords.remove(t); const r = t._prevRemoved, s = t._nextRemoved; return null === r ? this._removalsHead = s : r._nextRemoved = s, null === s ? this._removalsTail = r : s._prevRemoved = r, this._insertAfter(t, e, i), this._addToMoves(t, i), t } _moveAfter(t, e, i) { return this._unlink(t), this._insertAfter(t, e, i), this._addToMoves(t, i), t } _addAfter(t, e, i) { return this._insertAfter(t, e, i), this._additionsTail = null === this._additionsTail ? this._additionsHead = t : this._additionsTail._nextAdded = t, t } _insertAfter(t, e, i) { const r = null === e ? this._itHead : e._next; return t._next = r, t._prev = e, null === r ? this._itTail = t : r._prev = t, null === e ? this._itHead = t : e._next = t, null === this._linkedRecords && (this._linkedRecords = new Fb), this._linkedRecords.put(t), t.currentIndex = i, t } _remove(t) { return this._addToRemovals(this._unlink(t)) } _unlink(t) { null !== this._linkedRecords && this._linkedRecords.remove(t); const e = t._prev, i = t._next; return null === e ? this._itHead = i : e._next = i, null === i ? this._itTail = e : i._prev = e, t } _addToMoves(t, e) { return t.previousIndex === e || (this._movesTail = null === this._movesTail ? this._movesHead = t : this._movesTail._nextMoved = t), t } _addToRemovals(t) { return null === this._unlinkedRecords && (this._unlinkedRecords = new Fb), this._unlinkedRecords.put(t), t.currentIndex = null, t._nextRemoved = null, null === this._removalsTail ? (this._removalsTail = this._removalsHead = t, t._prevRemoved = null) : (t._prevRemoved = this._removalsTail, this._removalsTail = this._removalsTail._nextRemoved = t), t } _addIdentityChange(t, e) { return t.item = e, this._identityChangesTail = null === this._identityChangesTail ? this._identityChangesHead = t : this._identityChangesTail._nextIdentityChange = t, t } } class nO { constructor(t, e) { this.item = t, this.trackById = e, this.currentIndex = null, this.previousIndex = null, this._nextPrevious = null, this._prev = null, this._next = null, this._prevDup = null, this._nextDup = null, this._prevRemoved = null, this._nextRemoved = null, this._nextAdded = null, this._nextMoved = null, this._nextIdentityChange = null } } class iO { constructor() { this._head = null, this._tail = null } add(t) { null === this._head ? (this._head = this._tail = t, t._nextDup = null, t._prevDup = null) : (this._tail._nextDup = t, t._prevDup = this._tail, t._nextDup = null, this._tail = t) } get(t, e) { let i; for (i = this._head; null !== i; i = i._nextDup)if ((null === e || e <= i.currentIndex) && Object.is(i.trackById, t)) return i; return null } remove(t) { const e = t._prevDup, i = t._nextDup; return null === e ? this._head = i : e._nextDup = i, null === i ? this._tail = e : i._prevDup = e, null === this._head } } class Fb { constructor() { this.map = new Map } put(t) { const e = t.trackById; let i = this.map.get(e); i || (i = new iO, this.map.set(e, i)), i.add(t) } get(t, e) { const r = this.map.get(t); return r ? r.get(t, e) : null } remove(t) { const e = t.trackById; return this.map.get(e).remove(t) && this.map.delete(e), t } get isEmpty() { return 0 === this.map.size } clear() { this.map.clear() } } function Rb(n, t, e) { const i = n.previousIndex; if (null === i) return i; let r = 0; return e && i < e.length && (r = e[i]), i + t + r } class kb { constructor() { } supports(t) { return t instanceof Map || gf(t) } create() { return new rO } } class rO { constructor() { this._records = new Map, this._mapHead = null, this._appendAfter = null, this._previousMapHead = null, this._changesHead = null, this._changesTail = null, this._additionsHead = null, this._additionsTail = null, this._removalsHead = null, this._removalsTail = null } get isDirty() { return null !== this._additionsHead || null !== this._changesHead || null !== this._removalsHead } forEachItem(t) { let e; for (e = this._mapHead; null !== e; e = e._next)t(e) } forEachPreviousItem(t) { let e; for (e = this._previousMapHead; null !== e; e = e._nextPrevious)t(e) } forEachChangedItem(t) { let e; for (e = this._changesHead; null !== e; e = e._nextChanged)t(e) } forEachAddedItem(t) { let e; for (e = this._additionsHead; null !== e; e = e._nextAdded)t(e) } forEachRemovedItem(t) { let e; for (e = this._removalsHead; null !== e; e = e._nextRemoved)t(e) } diff(t) { if (t) { if (!(t instanceof Map || gf(t))) throw new Error(`Error trying to diff '${re(t)}'. Only maps and objects are allowed`) } else t = new Map; return this.check(t) ? this : null } onDestroy() { } check(t) { this._reset(); let e = this._mapHead; if (this._appendAfter = null, this._forEach(t, (i, r) => { if (e && e.key === r) this._maybeAddToChanges(e, i), this._appendAfter = e, e = e._next; else { const s = this._getOrCreateRecordForKey(r, i); e = this._insertBeforeOrAppend(e, s) } }), e) { e._prev && (e._prev._next = null), this._removalsHead = e; for (let i = e; null !== i; i = i._nextRemoved)i === this._mapHead && (this._mapHead = null), this._records.delete(i.key), i._nextRemoved = i._next, i.previousValue = i.currentValue, i.currentValue = null, i._prev = null, i._next = null } return this._changesTail && (this._changesTail._nextChanged = null), this._additionsTail && (this._additionsTail._nextAdded = null), this.isDirty } _insertBeforeOrAppend(t, e) { if (t) { const i = t._prev; return e._next = t, e._prev = i, t._prev = e, i && (i._next = e), t === this._mapHead && (this._mapHead = e), this._appendAfter = t, t } return this._appendAfter ? (this._appendAfter._next = e, e._prev = this._appendAfter) : this._mapHead = e, this._appendAfter = e, null } _getOrCreateRecordForKey(t, e) { if (this._records.has(t)) { const r = this._records.get(t); this._maybeAddToChanges(r, e); const s = r._prev, o = r._next; return s && (s._next = o), o && (o._prev = s), r._next = null, r._prev = null, r } const i = new sO(t); return this._records.set(t, i), i.currentValue = e, this._addToAdditions(i), i } _reset() { if (this.isDirty) { let t; for (this._previousMapHead = this._mapHead, t = this._previousMapHead; null !== t; t = t._next)t._nextPrevious = t._next; for (t = this._changesHead; null !== t; t = t._nextChanged)t.previousValue = t.currentValue; for (t = this._additionsHead; null != t; t = t._nextAdded)t.previousValue = t.currentValue; this._changesHead = this._changesTail = null, this._additionsHead = this._additionsTail = null, this._removalsHead = null } } _maybeAddToChanges(t, e) { Object.is(e, t.currentValue) || (t.previousValue = t.currentValue, t.currentValue = e, this._addToChanges(t)) } _addToAdditions(t) { null === this._additionsHead ? this._additionsHead = this._additionsTail = t : (this._additionsTail._nextAdded = t, this._additionsTail = t) } _addToChanges(t) { null === this._changesHead ? this._changesHead = this._changesTail = t : (this._changesTail._nextChanged = t, this._changesTail = t) } _forEach(t, e) { t instanceof Map ? t.forEach(e) : Object.keys(t).forEach(i => e(t[i], i)) } } class sO { constructor(t) { this.key = t, this.previousValue = null, this.currentValue = null, this._nextPrevious = null, this._next = null, this._prev = null, this._nextAdded = null, this._nextRemoved = null, this._nextChanged = null } } function Ob() { return new _r([new Ib]) } let _r = (() => { class n { constructor(e) { this.factories = e } static create(e, i) { if (null != i) { const r = i.factories.slice(); e = e.concat(r) } return new n(e) } static extend(e) { return { provide: n, useFactory: i => n.create(e, i || Ob()), deps: [[n, new ki, new Ut]] } } find(e) { const i = this.factories.find(r => r.supports(e)); if (null != i) return i; throw new Error(`Cannot find a differ supporting object '${e}' of type '${function (n) { return n.name || typeof n }(e)}'`) } } return n.\u0275prov = E({ token: n, providedIn: "root", factory: Ob }), n })(); function Nb() { return new Li([new kb]) } let Li = (() => { class n { constructor(e) { this.factories = e } static create(e, i) { if (i) { const r = i.factories.slice(); e = e.concat(r) } return new n(e) } static extend(e) { return { provide: n, useFactory: i => n.create(e, i || Nb()), deps: [[n, new ki, new Ut]] } } find(e) { const i = this.factories.find(r => r.supports(e)); if (i) return i; throw new Error(`Cannot find a differ supporting object '${e}'`) } } return n.\u0275prov = E({ token: n, providedIn: "root", factory: Nb }), n })(); function Ul(n, t, e, i, r = !1) { for (; null !== e;) { const s = t[e.index]; if (null !== s && i.push(Ke(s)), bn(s)) for (let a = 10; a < s.length; a++) { const l = s[a], c = l[1].firstChild; null !== c && Ul(l[1], l, c, i) } const o = e.type; if (8 & o) Ul(n, t, e.child, i); else if (32 & o) { const a = Td(e, t); let l; for (; l = a();)i.push(l) } else if (16 & o) { const a = O_(t, e); if (Array.isArray(a)) i.push(...a); else { const l = No(t[16]); Ul(l[1], l, a, i, !0) } } e = r ? e.projectionNext : e.next } return i } class Qo { constructor(t, e) { this._lView = t, this._cdRefInjectingView = e, this._appRef = null, this._attachedToViewContainer = !1 } get rootNodes() { const t = this._lView, e = t[1]; return Ul(e, t, e.firstChild, []) } get context() { return this._lView[8] } set context(t) { this._lView[8] = t } get destroyed() { return 256 == (256 & this._lView[2]) } destroy() { if (this._appRef) this._appRef.detachView(this); else if (this._attachedToViewContainer) { const t = this._lView[3]; if (bn(t)) { const e = t[8], i = e ? e.indexOf(this) : -1; i > -1 && (Od(t, i), lr(e, i)) } this._attachedToViewContainer = !1 } x_(this._lView[1], this._lView) } onDestroy(t) { sy(this._lView[1], this._lView, null, t) } markForCheck() { tf(this._cdRefInjectingView || this._lView) } detach() { this._lView[2] &= -129 } reattach() { this._lView[2] |= 128 } detectChanges() { rf(this._lView[1], this._lView, this.context) } checkNoChanges() { !function (n, t, e) { Xa(!0); try { rf(n, t, e) } finally { Xa(!1) } }(this._lView[1], this._lView, this.context) } attachToViewContainerRef() { if (this._appRef) throw new Error("This view is already attached directly to the ApplicationRef!"); this._attachedToViewContainer = !0 } detachFromAppRef() { this._appRef = null, function (n, t) { Po(n, t, t[11], 2, null, null) }(this._lView[1], this._lView) } attachToAppRef(t) { if (this._attachedToViewContainer) throw new Error("This view is already attached to a ViewContainer!"); this._appRef = t } } class aO extends Qo { constructor(t) { super(t), this._view = t } detectChanges() { py(this._view) } checkNoChanges() { !function (n) { Xa(!0); try { py(n) } finally { Xa(!1) } }(this._view) } get context() { return null } } const cO = function (n) { return function (n, t, e) { if (Qa(n) && !e) { const i = Gt(n.index, t); return new Qo(i, i) } return 47 & n.type ? new Qo(t[16], t) : null }(it(), w(), 16 == (16 & n)) }; let Is = (() => { class n { } return n.__NG_ELEMENT_ID__ = cO, n })(); const fO = [new kb], pO = new _r([new Ib]), gO = new Li(fO), _O = function () { return zl(it(), w()) }; let Kt = (() => { class n { } return n.__NG_ELEMENT_ID__ = _O, n })(); const yO = Kt, vO = class extends yO { constructor(t, e, i) { super(), this._declarationLView = t, this._declarationTContainer = e, this.elementRef = i } createEmbeddedView(t) { const e = this._declarationTContainer.tViews, i = Lo(this._declarationLView, e, t, 16, null, e.declTNode, null, null, null, null); i[17] = this._declarationLView[this._declarationTContainer.index]; const s = this._declarationLView[19]; return null !== s && (i[19] = s.createEmbeddedView(e)), Vo(e, i, t), new Qo(i) } }; function zl(n, t) { return 4 & n.type ? new vO(t, n, Ts(n, t)) : null } class yr { } const EO = function () { return Vb(it(), w()) }; let Lt = (() => { class n { } return n.__NG_ELEMENT_ID__ = EO, n })(); const xO = Lt, Pb = class extends xO { constructor(t, e, i) { super(), this._lContainer = t, this._hostTNode = e, this._hostLView = i } get element() { return Ts(this._hostTNode, this._hostLView) } get injector() { return new Zr(this._hostTNode, this._hostLView) } get parentInjector() { const t = ll(this._hostTNode, this._hostLView); if (Am(t)) { const e = Jr(t, this._hostLView), i = Yr(t); return new Zr(e[1].data[i + 8], e) } return new Zr(null, this._hostLView) } clear() { for (; this.length > 0;)this.remove(this.length - 1) } get(t) { const e = Lb(this._lContainer); return null !== e && e[t] || null } get length() { return this._lContainer.length - 10 } createEmbeddedView(t, e, i) { const r = t.createEmbeddedView(e || {}); return this.insert(r, i), r } createComponent(t, e, i, r, s) { const o = i || this.parentInjector; if (!s && null == t.ngModule && o) { const l = o.get(yr, null); l && (s = l) } const a = t.create(o, r, void 0, s); return this.insert(a.hostView, e), a } insert(t, e) { const i = t._lView, r = i[1]; if (function (n) { return bn(n[3]) }(i)) { const u = this.indexOf(t); if (-1 !== u) this.detach(u); else { const d = i[3], f = new Pb(d, d[6], d[3]); f.detach(f.indexOf(t)) } } const s = this._adjustIndex(e), o = this._lContainer; !function (n, t, e, i) { const r = 10 + i, s = e.length; i > 0 && (e[r - 1][4] = t), i < s - 10 ? (t[4] = e[r], fl(e, 10 + i, t)) : (e.push(t), t[4] = null), t[3] = e; const o = t[17]; null !== o && e !== o && function (n, t) { const e = n[9]; t[16] !== t[3][3][16] && (n[2] = !0), null === e ? n[9] = [t] : e.push(t) }(o, t); const a = t[19]; null !== a && a.insertView(n), t[2] |= 128 }(r, i, o, s); const a = Ld(s, o), l = i[11], c = Cl(l, o[7]); return null !== c && function (n, t, e, i, r, s) { i[0] = r, i[6] = t, Po(n, i, e, 1, r, s) }(r, o[6], l, i, c, a), t.attachToViewContainerRef(), fl(Lf(o), s, t), t } move(t, e) { return this.insert(t, e) } indexOf(t) { const e = Lb(this._lContainer); return null !== e ? e.indexOf(t) : -1 } remove(t) { const e = this._adjustIndex(t, -1), i = Od(this._lContainer, e); i && (lr(Lf(this._lContainer), e), x_(i[1], i)) } detach(t) { const e = this._adjustIndex(t, -1), i = Od(this._lContainer, e); return i && null != lr(Lf(this._lContainer), e) ? new Qo(i) : null } _adjustIndex(t, e = 0) { return null == t ? this.length + e : t } }; function Lb(n) { return n[8] } function Lf(n) { return n[8] || (n[8] = []) } function Vb(n, t) { let e; const i = t[n.index]; if (bn(i)) e = i; else { let r; if (8 & n.type) r = Ke(i); else { const s = t[11]; r = s.createComment(""); const o = nn(n, t); dr(s, Cl(s, o), r, function (n, t) { return Ve(n) ? n.nextSibling(t) : t.nextSibling }(s, o), !1) } t[n.index] = e = hy(i, t, r, n), Sl(t, e) } return new Pb(e, n, t) } const Os = {}; class rC extends hi { constructor(t) { super(), this.ngModule = t } resolveComponentFactory(t) { const e = Mt(t); return new oC(e, this.ngModule) } } function sC(n) { const t = []; for (let e in n) n.hasOwnProperty(e) && t.push({ propName: n[e], templateName: e }); return t } const CN = new k("SCHEDULER_TOKEN", { providedIn: "root", factory: () => m_ }); class oC extends xb { constructor(t, e) { super(), this.componentDef = t, this.ngModule = e, this.componentType = t.type, this.selector = function (n) { return n.map(hI).join(",") }(t.selectors), this.ngContentSelectors = t.ngContentSelectors ? t.ngContentSelectors : [], this.isBoundToModule = !!e } get inputs() { return sC(this.componentDef.inputs) } get outputs() { return sC(this.componentDef.outputs) } create(t, e, i, r) { const s = (r = r || this.ngModule) ? function (n, t) { return { get: (e, i, r) => { const s = n.get(e, Os, r); return s !== Os || i === Os ? s : t.get(e, i, r) } } }(t, r.injector) : t, o = s.get(mr, dm), a = s.get(Pf, null), l = o.createRenderer(null, this.componentDef), c = this.componentDef.selectors[0][0] || "div", u = i ? function (n, t, e) { if (Ve(n)) return n.selectRootElement(t, e === qe.ShadowDom); let i = "string" == typeof t ? n.querySelector(t) : t; return i.textContent = "", i }(l, i, this.componentDef.encapsulation) : kd(o.createRenderer(null, this.componentDef), c, function (n) { const t = n.toLowerCase(); return "svg" === t ? "http://www.w3.org/2000/svg" : "math" === t ? "http://www.w3.org/1998/MathML/" : null }(c)), d = this.componentDef.onPush ? 576 : 528, f = function (n, t) { return { components: [], scheduler: n || m_, clean: JI, playerHandler: t || null, flags: 0 } }(), h = Al(0, null, null, 1, 0, null, null, null, null, null), p = Lo(null, h, f, d, null, null, o, l, a, s); let y, _; el(p); try { const b = function (n, t, e, i, r, s) { const o = e[1]; e[20] = n; const l = cs(o, 20, 2, "#host", null), c = l.mergedAttrs = t.hostAttrs; null !== c && (Tl(l, c, !0), null !== n && (sl(r, n, c), null !== l.classes && Bd(r, n, l.classes), null !== l.styles && L_(r, n, l.styles))); const u = i.createRenderer(n, t), d = Lo(e, ny(t), null, t.onPush ? 64 : 16, e[20], l, i, u, s || null, null); return o.firstCreatePass && (cl(vo(l, e), o, t.type), uy(o, l), dy(l, e.length, 1)), Sl(e, d), e[20] = d }(u, this.componentDef, p, o, l); if (u) if (i) sl(l, u, ["ng-version", Tb.full]); else { const { attrs: v, classes: S } = function (n) { const t = [], e = []; let i = 1, r = 2; for (; i < n.length;) { let s = n[i]; if ("string" == typeof s) 2 === r ? "" !== s && t.push(s, n[++i]) : 8 === r && e.push(s); else { if (!En(r)) break; r = s } i++ } return { attrs: t, classes: e } }(this.componentDef.selectors[0]); v && sl(l, u, v), S && S.length > 0 && Bd(l, u, S.join(" ")) } if (_ = Yu(h, 20), void 0 !== e) { const v = _.projection = []; for (let S = 0; S < this.ngContentSelectors.length; S++) { const I = e[S]; v.push(null != I ? Array.from(I) : null) } } y = function (n, t, e, i, r) { const s = e[1], o = function (n, t, e) { const i = it(); n.firstCreatePass && (e.providersResolver && e.providersResolver(e), fy(n, i, t, us(n, t, 1, null), e)); const r = bo(t, n, i.directiveStart, i); mt(r, t); const s = nn(i, t); return s && mt(s, t), r }(s, e, t); if (i.components.push(o), n[8] = o, r && r.forEach(l => l(o, t)), t.contentQueries) { const l = it(); t.contentQueries(1, o, l.directiveStart) } const a = it(); return !s.firstCreatePass || null === t.hostBindings && null === t.hostAttrs || (Ii(a.index), ly(e[1], a, 0, a.directiveStart, a.directiveEnd, t), cy(t, o)), o }(b, this.componentDef, p, f, [EF]), Vo(h, p, null) } finally { tl() } return new DN(this.componentType, y, Ts(_, p), p, _) } } class DN extends class { }{ constructor(t, e, i, r, s) { super(), this.location = i, this._rootLView = r, this._tNode = s, this.instance = e, this.hostView = this.changeDetectorRef = new aO(r), this.componentType = t } get injector() { return new Zr(this._tNode, this._rootLView) } destroy() { this.hostView.destroy() } onDestroy(t) { this.hostView.onDestroy(t) } } const Ns = new Map; class AN extends yr { constructor(t, e) { super(), this._parent = e, this._bootstrapComponents = [], this.injector = this, this.destroyCbs = [], this.componentFactoryResolver = new rC(this); const i = Xt(t), r = function (n) { return n[IS] || null }(t); r && Sf(r), this._bootstrapComponents = qn(i.bootstrap), this._r3Injector = wy(t, e, [{ provide: yr, useValue: this }, { provide: hi, useValue: this.componentFactoryResolver }], re(t)), this._r3Injector._resolveInjectorDefTypes(), this.instance = this.get(t) } get(t, e = ce.THROW_IF_NOT_FOUND, i = G.Default) { return t === ce || t === yr || t === fr ? this : this._r3Injector.get(t, e, i) } destroy() { const t = this._r3Injector; !t.destroyed && t.destroy(), this.destroyCbs.forEach(e => e()), this.destroyCbs = null } onDestroy(t) { this.destroyCbs.push(t) } } class Yf extends class { }{ constructor(t) { super(), this.moduleType = t, null !== Xt(t) && function (n) { const t = new Set; !function e(i) { const r = Xt(i, !0), s = r.id; null !== s && (function (n, t, e) { if (t && t !== e) throw new Error(`Duplicate module registered for ${n} - ${re(t)} vs ${re(t.name)}`) }(s, Ns.get(s), i), Ns.set(s, i)); const o = qn(r.imports); for (const a of o) t.has(a) || (t.add(a), e(a)) }(n) }(t) } create(t) { return new AN(this.moduleType, t) } } function Zn(n, t, e) { const i = function () { const n = z.lFrame; let t = n.bindingRootIndex; return -1 === t && (t = n.bindingRootIndex = n.tView.bindingStartIndex), t }() + n, r = w(); return r[i] === q ? function (n, t, e) { return n[t] = e }(r, i, e ? t.call(e) : t()) : function (n, t) { return n[t] }(r, i) } function Jf(n) { return t => { setTimeout(n, void 0, t) } } const ge = class extends ie { constructor(t = !1) { super(), this.__isAsync = t } emit(t) { super.next(t) } subscribe(t, e, i) { var r, s, o; let a = t, l = e || (() => null), c = i; if (t && "object" == typeof t) { const d = t; a = null === (r = d.next) || void 0 === r ? void 0 : r.bind(d), l = null === (s = d.error) || void 0 === s ? void 0 : s.bind(d), c = null === (o = d.complete) || void 0 === o ? void 0 : o.bind(d) } this.__isAsync && (l = Jf(l), a && (a = Jf(a)), c && (c = Jf(c))); const u = super.subscribe({ next: a, error: l, complete: c }); return t instanceof he && t.add(u), u } }; function zN() { return this._results[ps()]() } class Yl { constructor(t = !1) { this._emitDistinctChangesOnly = t, this.dirty = !0, this._results = [], this._changesDetected = !1, this._changes = null, this.length = 0, this.first = void 0, this.last = void 0; const e = ps(), i = Yl.prototype; i[e] || (i[e] = zN) } get changes() { return this._changes || (this._changes = new ge) } get(t) { return this._results[t] } map(t) { return this._results.map(t) } filter(t) { return this._results.filter(t) } find(t) { return this._results.find(t) } reduce(t, e) { return this._results.reduce(t, e) } forEach(t) { this._results.forEach(t) } some(t) { return this._results.some(t) } toArray() { return this._results.slice() } toString() { return this._results.toString() } reset(t, e) { const i = this; i.dirty = !1; const r = rn(t); (this._changesDetected = !function (n, t, e) { if (n.length !== t.length) return !1; for (let i = 0; i < n.length; i++) { let r = n[i], s = t[i]; if (e && (r = e(r), s = e(s)), s !== r) return !1 } return !0 }(i._results, r, e)) && (i._results = r, i.length = r.length, i.last = r[this.length - 1], i.first = r[0]) } notifyOnChanges() { this._changes && (this._changesDetected || !this._emitDistinctChangesOnly) && this._changes.emit(this) } setDirty() { this.dirty = !0 } destroy() { this.changes.complete(), this.changes.unsubscribe() } } Symbol; class Zf { constructor(t) { this.queryList = t, this.matches = null } clone() { return new Zf(this.queryList) } setDirty() { this.queryList.setDirty() } } class Xf { constructor(t = []) { this.queries = t } createEmbeddedView(t) { const e = t.queries; if (null !== e) { const i = null !== t.contentQueries ? t.contentQueries[0] : e.length, r = []; for (let s = 0; s < i; s++) { const o = e.getByIndex(s); r.push(this.queries[o.indexInDeclarationView].clone()) } return new Xf(r) } return null } insertView(t) { this.dirtyQueriesWithMatches(t) } detachView(t) { this.dirtyQueriesWithMatches(t) } dirtyQueriesWithMatches(t) { for (let e = 0; e < this.queries.length; e++)null !== yC(t, e).matches && this.queries[e].setDirty() } } class pC { constructor(t, e, i = null) { this.predicate = t, this.flags = e, this.read = i } } class eh { constructor(t = []) { this.queries = t } elementStart(t, e) { for (let i = 0; i < this.queries.length; i++)this.queries[i].elementStart(t, e) } elementEnd(t) { for (let e = 0; e < this.queries.length; e++)this.queries[e].elementEnd(t) } embeddedTView(t) { let e = null; for (let i = 0; i < this.length; i++) { const r = null !== e ? e.length : 0, s = this.getByIndex(i).embeddedTView(t, r); s && (s.indexInDeclarationView = i, null !== e ? e.push(s) : e = [s]) } return null !== e ? new eh(e) : null } template(t, e) { for (let i = 0; i < this.queries.length; i++)this.queries[i].template(t, e) } getByIndex(t) { return this.queries[t] } get length() { return this.queries.length } track(t) { this.queries.push(t) } } class th { constructor(t, e = -1) { this.metadata = t, this.matches = null, this.indexInDeclarationView = -1, this.crossesNgTemplate = !1, this._appliesToNextNode = !0, this._declarationNodeIndex = e } elementStart(t, e) { this.isApplyingToNode(e) && this.matchTNode(t, e) } elementEnd(t) { this._declarationNodeIndex === t.index && (this._appliesToNextNode = !1) } template(t, e) { this.elementStart(t, e) } embeddedTView(t, e) { return this.isApplyingToNode(t) ? (this.crossesNgTemplate = !0, this.addMatch(-t.index, e), new th(this.metadata)) : null } isApplyingToNode(t) { if (this._appliesToNextNode && 1 != (1 & this.metadata.flags)) { const e = this._declarationNodeIndex; let i = t.parent; for (; null !== i && 8 & i.type && i.index !== e;)i = i.parent; return e === (null !== i ? i.index : -1) } return this._appliesToNextNode } matchTNode(t, e) { const i = this.metadata.predicate; if (Array.isArray(i)) for (let r = 0; r < i.length; r++) { const s = i[r]; this.matchTNodeWithReadOption(t, e, KN(e, s)), this.matchTNodeWithReadOption(t, e, ul(e, t, s, !1, !1)) } else i === Kt ? 4 & e.type && this.matchTNodeWithReadOption(t, e, -1) : this.matchTNodeWithReadOption(t, e, ul(e, t, i, !1, !1)) } matchTNodeWithReadOption(t, e, i) { if (null !== i) { const r = this.metadata.read; if (null !== r) if (r === O || r === Lt || r === Kt && 4 & e.type) this.addMatch(e.index, -2); else { const s = ul(e, t, r, !1, !1); null !== s && this.addMatch(e.index, s) } else this.addMatch(e.index, i) } } addMatch(t, e) { null === this.matches ? this.matches = [t, e] : this.matches.push(t, e) } } function KN(n, t) { const e = n.localNames; if (null !== e) for (let i = 0; i < e.length; i += 2)if (e[i] === t) return e[i + 1]; return null } function YN(n, t, e, i) { return -1 === e ? function (n, t) { return 11 & n.type ? Ts(n, t) : 4 & n.type ? zl(n, t) : null }(t, n) : -2 === e ? function (n, t, e) { return e === O ? Ts(t, n) : e === Kt ? zl(t, n) : e === Lt ? Vb(t, n) : void 0 }(n, t, i) : bo(n, n[1], e, t) } function gC(n, t, e, i) { const r = t[19].queries[i]; if (null === r.matches) { const s = n.data, o = e.matches, a = []; for (let l = 0; l < o.length; l += 2) { const c = o[l]; a.push(c < 0 ? null : YN(t, s[c], o[l + 1], e.metadata.read)) } r.matches = a } return r.matches } function nh(n, t, e, i) { const r = n.queries.getByIndex(e), s = r.matches; if (null !== s) { const o = gC(n, t, r, e); for (let a = 0; a < s.length; a += 2) { const l = s[a]; if (l > 0) i.push(o[a / 2]); else { const c = s[a + 1], u = t[-l]; for (let d = 10; d < u.length; d++) { const f = u[d]; f[17] === f[3] && nh(f[1], f, c, i) } if (null !== u[9]) { const d = u[9]; for (let f = 0; f < d.length; f++) { const h = d[f]; nh(h[1], h, c, i) } } } } } return i } function ct(n) { const t = w(), e = ue(), i = ym(); id(i + 1); const r = yC(e, i); if (n.dirty && fm(t) === (2 == (2 & r.metadata.flags))) { if (null === r.matches) n.reset([]); else { const s = r.crossesNgTemplate ? nh(e, t, i, []) : gC(e, t, r, i); n.reset(s, Sb), n.notifyOnChanges() } return !0 } return !1 } function Bi(n, t, e) { const i = ue(); i.firstCreatePass && (_C(i, new pC(n, t, e), -1), 2 == (2 & t) && (i.staticViewQueries = !0)), mC(i, w(), t) } function Fn(n, t, e, i) { const r = ue(); if (r.firstCreatePass) { const s = it(); _C(r, new pC(t, e, i), s.index), function (n, t) { const e = n.contentQueries || (n.contentQueries = []); t !== (e.length ? e[e.length - 1] : -1) && e.push(n.queries.length - 1, t) }(r, n), 2 == (2 & e) && (r.staticContentQueries = !0) } mC(r, w(), e) } function ut() { return function (n, t) { return n[19].queries[t].queryList }(w(), ym()) } function mC(n, t, e) { const i = new Yl(4 == (4 & e)); sy(n, t, i, i.destroy), null === t[19] && (t[19] = new Xf), t[19].queries.push(new Zf(i)) } function _C(n, t, e) { null === n.queries && (n.queries = new eh), n.queries.track(new th(t, e)) } function yC(n, t) { return n.queries.getByIndex(t) } const Xl = new k("Application Initializer"); let Ls = (() => { class n { constructor(e) { this.appInits = e, this.resolve = $l, this.reject = $l, this.initialized = !1, this.done = !1, this.donePromise = new Promise((i, r) => { this.resolve = i, this.reject = r }) } runInitializers() { if (this.initialized) return; const e = [], i = () => { this.done = !0, this.resolve() }; if (this.appInits) for (let r = 0; r < this.appInits.length; r++) { const s = this.appInits[r](); if (Nl(s)) e.push(s); else if (Cf(s)) { const o = new Promise((a, l) => { s.subscribe({ complete: a, error: l }) }); e.push(o) } } Promise.all(e).then(() => { i() }).catch(r => { this.reject(r) }), 0 === e.length && i(), this.initialized = !0 } } return n.\u0275fac = function (e) { return new (e || n)(m(Xl, 8)) }, n.\u0275prov = E({ token: n, factory: n.\u0275fac }), n })(); const aa = new k("AppId"), A1 = { provide: aa, useFactory: function () { return `${lh()}${lh()}${lh()}` }, deps: [] }; function lh() { return String.fromCharCode(97 + Math.floor(25 * Math.random())) } const PC = new k("Platform Initializer"), bt = new k("Platform ID"), LC = new k("appBootstrapListener"); let ch = (() => { class n { log(e) { console.log(e) } warn(e) { console.warn(e) } } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275prov = E({ token: n, factory: n.\u0275fac }), n })(); const gi = new k("LocaleId"), VC = new k("DefaultCurrencyCode"); class T1 { constructor(t, e) { this.ngModuleFactory = t, this.componentFactories = e } } const uh = function (n) { return new Yf(n) }, I1 = uh, F1 = function (n) { return Promise.resolve(uh(n)) }, BC = function (n) { const t = uh(n), i = qn(Xt(n).declarations).reduce((r, s) => { const o = Mt(s); return o && r.push(new oC(o)), r }, []); return new T1(t, i) }, R1 = BC, k1 = function (n) { return Promise.resolve(BC(n)) }; let tc = (() => { class n { constructor() { this.compileModuleSync = I1, this.compileModuleAsync = F1, this.compileModuleAndAllComponentsSync = R1, this.compileModuleAndAllComponentsAsync = k1 } clearCache() { } clearCacheFor(e) { } getModuleId(e) { } } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275prov = E({ token: n, factory: n.\u0275fac }), n })(); const P1 = (() => Promise.resolve(0))(); function dh(n) { "undefined" == typeof Zone ? P1.then(() => { n && n.apply(null, null) }) : Zone.current.scheduleMicroTask("scheduleMicrotask", n) } class H { constructor({ enableLongStackTrace: t = !1, shouldCoalesceEventChangeDetection: e = !1, shouldCoalesceRunChangeDetection: i = !1 }) { if (this.hasPendingMacrotasks = !1, this.hasPendingMicrotasks = !1, this.isStable = !0, this.onUnstable = new ge(!1), this.onMicrotaskEmpty = new ge(!1), this.onStable = new ge(!1), this.onError = new ge(!1), "undefined" == typeof Zone) throw new Error("In this configuration Angular requires Zone.js"); Zone.assertZonePatched(); const r = this; r._nesting = 0, r._outer = r._inner = Zone.current, Zone.TaskTrackingZoneSpec && (r._inner = r._inner.fork(new Zone.TaskTrackingZoneSpec)), t && Zone.longStackTraceZoneSpec && (r._inner = r._inner.fork(Zone.longStackTraceZoneSpec)), r.shouldCoalesceEventChangeDetection = !i && e, r.shouldCoalesceRunChangeDetection = i, r.lastRequestAnimationFrameId = -1, r.nativeRequestAnimationFrame = function () { let n = _e.requestAnimationFrame, t = _e.cancelAnimationFrame; if ("undefined" != typeof Zone && n && t) { const e = n[Zone.__symbol__("OriginalDelegate")]; e && (n = e); const i = t[Zone.__symbol__("OriginalDelegate")]; i && (t = i) } return { nativeRequestAnimationFrame: n, nativeCancelAnimationFrame: t } }().nativeRequestAnimationFrame, function (n) { const t = () => { !function (n) { n.isCheckStableRunning || -1 !== n.lastRequestAnimationFrameId || (n.lastRequestAnimationFrameId = n.nativeRequestAnimationFrame.call(_e, () => { n.fakeTopEventTask || (n.fakeTopEventTask = Zone.root.scheduleEventTask("fakeTopEventTask", () => { n.lastRequestAnimationFrameId = -1, hh(n), n.isCheckStableRunning = !0, fh(n), n.isCheckStableRunning = !1 }, void 0, () => { }, () => { })), n.fakeTopEventTask.invoke() }), hh(n)) }(n) }; n._inner = n._inner.fork({ name: "angular", properties: { isAngularZone: !0 }, onInvokeTask: (e, i, r, s, o, a) => { try { return HC(n), e.invokeTask(r, s, o, a) } finally { (n.shouldCoalesceEventChangeDetection && "eventTask" === s.type || n.shouldCoalesceRunChangeDetection) && t(), jC(n) } }, onInvoke: (e, i, r, s, o, a, l) => { try { return HC(n), e.invoke(r, s, o, a, l) } finally { n.shouldCoalesceRunChangeDetection && t(), jC(n) } }, onHasTask: (e, i, r, s) => { e.hasTask(r, s), i === r && ("microTask" == s.change ? (n._hasPendingMicrotasks = s.microTask, hh(n), fh(n)) : "macroTask" == s.change && (n.hasPendingMacrotasks = s.macroTask)) }, onHandleError: (e, i, r, s) => (e.handleError(r, s), n.runOutsideAngular(() => n.onError.emit(s)), !1) }) }(r) } static isInAngularZone() { return !0 === Zone.current.get("isAngularZone") } static assertInAngularZone() { if (!H.isInAngularZone()) throw new Error("Expected to be in Angular Zone, but it is not!") } static assertNotInAngularZone() { if (H.isInAngularZone()) throw new Error("Expected to not be in Angular Zone, but it is!") } run(t, e, i) { return this._inner.run(t, e, i) } runTask(t, e, i, r) { const s = this._inner, o = s.scheduleEventTask("NgZoneEvent: " + r, t, V1, $l, $l); try { return s.runTask(o, e, i) } finally { s.cancelTask(o) } } runGuarded(t, e, i) { return this._inner.runGuarded(t, e, i) } runOutsideAngular(t) { return this._outer.run(t) } } const V1 = {}; function fh(n) { if (0 == n._nesting && !n.hasPendingMicrotasks && !n.isStable) try { n._nesting++, n.onMicrotaskEmpty.emit(null) } finally { if (n._nesting--, !n.hasPendingMicrotasks) try { n.runOutsideAngular(() => n.onStable.emit(null)) } finally { n.isStable = !0 } } } function hh(n) { n.hasPendingMicrotasks = !!(n._hasPendingMicrotasks || (n.shouldCoalesceEventChangeDetection || n.shouldCoalesceRunChangeDetection) && -1 !== n.lastRequestAnimationFrameId) } function HC(n) { n._nesting++, n.isStable && (n.isStable = !1, n.onUnstable.emit(null)) } function jC(n) { n._nesting--, fh(n) } class j1 { constructor() { this.hasPendingMicrotasks = !1, this.hasPendingMacrotasks = !1, this.isStable = !0, this.onUnstable = new ge, this.onMicrotaskEmpty = new ge, this.onStable = new ge, this.onError = new ge } run(t, e, i) { return t.apply(e, i) } runGuarded(t, e, i) { return t.apply(e, i) } runOutsideAngular(t) { return t() } runTask(t, e, i, r) { return t.apply(e, i) } } let ph = (() => { class n { constructor(e) { this._ngZone = e, this._pendingCount = 0, this._isZoneStable = !0, this._didWork = !1, this._callbacks = [], this.taskTrackingZone = null, this._watchAngularEvents(), e.run(() => { this.taskTrackingZone = "undefined" == typeof Zone ? null : Zone.current.get("TaskTrackingZone") }) } _watchAngularEvents() { this._ngZone.onUnstable.subscribe({ next: () => { this._didWork = !0, this._isZoneStable = !1 } }), this._ngZone.runOutsideAngular(() => { this._ngZone.onStable.subscribe({ next: () => { H.assertNotInAngularZone(), dh(() => { this._isZoneStable = !0, this._runCallbacksIfReady() }) } }) }) } increasePendingRequestCount() { return this._pendingCount += 1, this._didWork = !0, this._pendingCount } decreasePendingRequestCount() { if (this._pendingCount -= 1, this._pendingCount < 0) throw new Error("pending async requests below zero"); return this._runCallbacksIfReady(), this._pendingCount } isStable() { return this._isZoneStable && 0 === this._pendingCount && !this._ngZone.hasPendingMacrotasks } _runCallbacksIfReady() { if (this.isStable()) dh(() => { for (; 0 !== this._callbacks.length;) { let e = this._callbacks.pop(); clearTimeout(e.timeoutId), e.doneCb(this._didWork) } this._didWork = !1 }); else { let e = this.getPendingTasks(); this._callbacks = this._callbacks.filter(i => !i.updateCb || !i.updateCb(e) || (clearTimeout(i.timeoutId), !1)), this._didWork = !0 } } getPendingTasks() { return this.taskTrackingZone ? this.taskTrackingZone.macroTasks.map(e => ({ source: e.source, creationLocation: e.creationLocation, data: e.data })) : [] } addCallback(e, i, r) { let s = -1; i && i > 0 && (s = setTimeout(() => { this._callbacks = this._callbacks.filter(o => o.timeoutId !== s), e(this._didWork, this.getPendingTasks()) }, i)), this._callbacks.push({ doneCb: e, timeoutId: s, updateCb: r }) } whenStable(e, i, r) { if (r && !this.taskTrackingZone) throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/plugins/task-tracking" loaded?'); this.addCallback(e, i, r), this._runCallbacksIfReady() } getPendingRequestCount() { return this._pendingCount } findProviders(e, i, r) { return [] } } return n.\u0275fac = function (e) { return new (e || n)(m(H)) }, n.\u0275prov = E({ token: n, factory: n.\u0275fac }), n })(), GC = (() => { class n { constructor() { this._applications = new Map, gh.addToWindow(this) } registerApplication(e, i) { this._applications.set(e, i) } unregisterApplication(e) { this._applications.delete(e) } unregisterAllApplications() { this._applications.clear() } getTestability(e) { return this._applications.get(e) || null } getAllTestabilities() { return Array.from(this._applications.values()) } getAllRootElements() { return Array.from(this._applications.keys()) } findTestabilityInTree(e, i = !0) { return gh.findTestabilityInTree(this, e, i) } } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275prov = E({ token: n, factory: n.\u0275fac }), n })(); class G1 { addToWindow(t) { } findTestabilityInTree(t, e, i) { return null } } let gh = new G1, $C = !0, UC = !1; function mh() { return UC = !0, $C } let Rn; const zC = new k("AllowMultipleToken"); function WC(n, t, e = []) { const i = `Platform: ${t}`, r = new k(i); return (s = []) => { let o = qC(); if (!o || o.injector.get(zC, !1)) if (n) n(e.concat(s).concat({ provide: r, useValue: !0 })); else { const a = e.concat(s).concat({ provide: r, useValue: !0 }, { provide: Bo, useValue: "platform" }); !function (n) { if (Rn && !Rn.destroyed && !Rn.injector.get(zC, !1)) throw new Error("There can be only one platform. Destroy the previous one to create a new one."); Rn = n.get(KC); const t = n.get(PC, null); t && t.forEach(e => e()) }(ce.create({ providers: a, name: i })) } return function (n) { const t = qC(); if (!t) throw new Error("No platform exists!"); if (!t.injector.get(n, null)) throw new Error("A platform with a different configuration has been created. Please destroy it first."); return t }(r) } } function qC() { return Rn && !Rn.destroyed ? Rn : null } let KC = (() => { class n { constructor(e) { this._injector = e, this._modules = [], this._destroyListeners = [], this._destroyed = !1 } bootstrapModuleFactory(e, i) { const a = function (n, t) { let e; return e = "noop" === n ? new j1 : ("zone.js" === n ? void 0 : n) || new H({ enableLongStackTrace: mh(), shouldCoalesceEventChangeDetection: !!(null == t ? void 0 : t.ngZoneEventCoalescing), shouldCoalesceRunChangeDetection: !!(null == t ? void 0 : t.ngZoneRunCoalescing) }), e }(i ? i.ngZone : void 0, { ngZoneEventCoalescing: i && i.ngZoneEventCoalescing || !1, ngZoneRunCoalescing: i && i.ngZoneRunCoalescing || !1 }), l = [{ provide: H, useValue: a }]; return a.run(() => { const c = ce.create({ providers: l, parent: this.injector, name: e.moduleType.name }), u = e.create(c), d = u.injector.get(wn, null); if (!d) throw new Error("No ErrorHandler. Is platform module (BrowserModule) included?"); return a.runOutsideAngular(() => { const f = a.onError.subscribe({ next: h => { d.handleError(h) } }); u.onDestroy(() => { _h(this._modules, u), f.unsubscribe() }) }), function (n, t, e) { try { const i = e(); return Nl(i) ? i.catch(r => { throw t.runOutsideAngular(() => n.handleError(r)), r }) : i } catch (i) { throw t.runOutsideAngular(() => n.handleError(i)), i } }(d, a, () => { const f = u.injector.get(Ls); return f.runInitializers(), f.donePromise.then(() => (Sf(u.injector.get(gi, Vl) || Vl), this._moduleDoBootstrap(u), u)) }) }) } bootstrapModule(e, i = []) { const r = QC({}, i); return function (n, t, e) { const i = new Yf(e); return Promise.resolve(i) }(0, 0, e).then(s => this.bootstrapModuleFactory(s, r)) } _moduleDoBootstrap(e) { const i = e.injector.get(Vs); if (e._bootstrapComponents.length > 0) e._bootstrapComponents.forEach(r => i.bootstrap(r)); else { if (!e.instance.ngDoBootstrap) throw new Error(`The module ${re(e.instance.constructor)} was bootstrapped, but it does not declare "@NgModule.bootstrap" components nor a "ngDoBootstrap" method. Please define one of these.`); e.instance.ngDoBootstrap(i) } this._modules.push(e) } onDestroy(e) { this._destroyListeners.push(e) } get injector() { return this._injector } destroy() { if (this._destroyed) throw new Error("The platform has already been destroyed!"); this._modules.slice().forEach(e => e.destroy()), this._destroyListeners.forEach(e => e()), this._destroyed = !0 } get destroyed() { return this._destroyed } } return n.\u0275fac = function (e) { return new (e || n)(m(ce)) }, n.\u0275prov = E({ token: n, factory: n.\u0275fac }), n })(); function QC(n, t) { return Array.isArray(t) ? t.reduce(QC, n) : Object.assign(Object.assign({}, n), t) } let Vs = (() => { class n { constructor(e, i, r, s, o) { this._zone = e, this._injector = i, this._exceptionHandler = r, this._componentFactoryResolver = s, this._initStatus = o, this._bootstrapListeners = [], this._views = [], this._runningTick = !1, this._stable = !0, this.componentTypes = [], this.components = [], this._onMicrotaskEmptySubscription = this._zone.onMicrotaskEmpty.subscribe({ next: () => { this._zone.run(() => { this.tick() }) } }); const a = new me(c => { this._stable = this._zone.isStable && !this._zone.hasPendingMacrotasks && !this._zone.hasPendingMicrotasks, this._zone.runOutsideAngular(() => { c.next(this._stable), c.complete() }) }), l = new me(c => { let u; this._zone.runOutsideAngular(() => { u = this._zone.onStable.subscribe(() => { H.assertNotInAngularZone(), dh(() => { !this._stable && !this._zone.hasPendingMacrotasks && !this._zone.hasPendingMicrotasks && (this._stable = !0, c.next(!0)) }) }) }); const d = this._zone.onUnstable.subscribe(() => { H.assertInAngularZone(), this._stable && (this._stable = !1, this._zone.runOutsideAngular(() => { c.next(!1) })) }); return () => { u.unsubscribe(), d.unsubscribe() } }); this.isStable = uo(a, l.pipe(qg())) } bootstrap(e, i) { if (!this._initStatus.done) throw new Error("Cannot bootstrap as there are still asynchronous initializers running. Bootstrap components in the `ngDoBootstrap` method of the root module."); let r; r = e instanceof xb ? e : this._componentFactoryResolver.resolveComponentFactory(e), this.componentTypes.push(r.componentType); const s = function (n) { return n.isBoundToModule }(r) ? void 0 : this._injector.get(yr), a = r.create(ce.NULL, [], i || r.selector, s), l = a.location.nativeElement, c = a.injector.get(ph, null), u = c && a.injector.get(GC); return c && u && u.registerApplication(l, c), a.onDestroy(() => { this.detachView(a.hostView), _h(this.components, a), u && u.unregisterApplication(l) }), this._loadComponent(a), a } tick() { if (this._runningTick) throw new Error("ApplicationRef.tick is called recursively"); try { this._runningTick = !0; for (let e of this._views) e.detectChanges() } catch (e) { this._zone.runOutsideAngular(() => this._exceptionHandler.handleError(e)) } finally { this._runningTick = !1 } } attachView(e) { const i = e; this._views.push(i), i.attachToAppRef(this) } detachView(e) { const i = e; _h(this._views, i), i.detachFromAppRef() } _loadComponent(e) { this.attachView(e.hostView), this.tick(), this.components.push(e), this._injector.get(LC, []).concat(this._bootstrapListeners).forEach(r => r(e)) } ngOnDestroy() { this._views.slice().forEach(e => e.destroy()), this._onMicrotaskEmptySubscription.unsubscribe() } get viewCount() { return this._views.length } } return n.\u0275fac = function (e) { return new (e || n)(m(H), m(ce), m(wn), m(hi), m(Ls)) }, n.\u0275prov = E({ token: n, factory: n.\u0275fac }), n })(); function _h(n, t) { const e = n.indexOf(t); e > -1 && n.splice(e, 1) } const gP = WC(null, "core", [{ provide: bt, useValue: "unknown" }, { provide: KC, deps: [ce] }, { provide: GC, deps: [] }, { provide: ch, deps: [] }]), bP = [{ provide: Vs, useClass: Vs, deps: [H, ce, wn, hi, Ls] }, { provide: CN, deps: [H], useFactory: function (n) { let t = []; return n.onStable.subscribe(() => { for (; t.length;)t.pop()() }), function (e) { t.push(e) } } }, { provide: Ls, useClass: Ls, deps: [[new Ut, Xl]] }, { provide: tc, useClass: tc, deps: [] }, A1, { provide: _r, useFactory: function () { return pO }, deps: [] }, { provide: Li, useFactory: function () { return gO }, deps: [] }, { provide: gi, useFactory: function (n) { return Sf(n = n || "undefined" != typeof $localize && $localize.locale || Vl), n }, deps: [[new To(gi), new Ut, new ki]] }, { provide: VC, useValue: "USD" }]; let wP = (() => { class n { constructor(e) { } } return n.\u0275fac = function (e) { return new (e || n)(m(Vs)) }, n.\u0275mod = ee({ type: n }), n.\u0275inj = X({ providers: bP }), n })(), dc = null; function Xn() { return dc } const N = new k("DocumentToken"); let fa = (() => { class n { historyGo(e) { throw new Error("Not implemented") } } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275prov = E({ factory: CL, token: n, providedIn: "platform" }), n })(); function CL() { return m(Ew) } let Ew = (() => { class n extends fa { constructor(e) { super(), this._doc = e, this._init() } _init() { this.location = window.location, this._history = window.history } getBaseHrefFromDOM() { return Xn().getBaseHref(this._doc) } onPopState(e) { const i = Xn().getGlobalEventTarget(this._doc, "window"); return i.addEventListener("popstate", e, !1), () => i.removeEventListener("popstate", e) } onHashChange(e) { const i = Xn().getGlobalEventTarget(this._doc, "window"); return i.addEventListener("hashchange", e, !1), () => i.removeEventListener("hashchange", e) } get href() { return this.location.href } get protocol() { return this.location.protocol } get hostname() { return this.location.hostname } get port() { return this.location.port } get pathname() { return this.location.pathname } get search() { return this.location.search } get hash() { return this.location.hash } set pathname(e) { this.location.pathname = e } pushState(e, i, r) { Dw() ? this._history.pushState(e, i, r) : this.location.hash = r } replaceState(e, i, r) { Dw() ? this._history.replaceState(e, i, r) : this.location.hash = r } forward() { this._history.forward() } back() { this._history.back() } historyGo(e = 0) { this._history.go(e) } getState() { return this._history.state } } return n.\u0275fac = function (e) { return new (e || n)(m(N)) }, n.\u0275prov = E({ factory: wL, token: n, providedIn: "platform" }), n })(); function Dw() { return !!window.history.pushState } function wL() { return new Ew(m(N)) } function xw(n, t) { if (0 == n.length) return t; if (0 == t.length) return n; let e = 0; return n.endsWith("/") && e++, t.startsWith("/") && e++, 2 == e ? n + t.substring(1) : 1 == e ? n + t : n + "/" + t } function Mw(n) { const t = n.match(/#|\?|$/), e = t && t.index || n.length; return n.slice(0, e - ("/" === n[e - 1] ? 1 : 0)) + n.slice(e) } function Er(n) { return n && "?" !== n[0] ? "?" + n : n } let Rh = (() => { class n { historyGo(e) { throw new Error("Not implemented") } } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275prov = E({ factory: EL, token: n, providedIn: "root" }), n })(); function EL(n) { const t = m(N).location; return new xL(m(fa), t && t.origin || "") } const DL = new k("appBaseHref"); let xL = (() => { class n extends Rh { constructor(e, i) { if (super(), this._platformLocation = e, this._removeListenerFns = [], null == i && (i = this._platformLocation.getBaseHrefFromDOM()), null == i) throw new Error("No base href set. Please provide a value for the APP_BASE_HREF token or add a base element to the document."); this._baseHref = i } ngOnDestroy() { for (; this._removeListenerFns.length;)this._removeListenerFns.pop()() } onPopState(e) { this._removeListenerFns.push(this._platformLocation.onPopState(e), this._platformLocation.onHashChange(e)) } getBaseHref() { return this._baseHref } prepareExternalUrl(e) { return xw(this._baseHref, e) } path(e = !1) { const i = this._platformLocation.pathname + Er(this._platformLocation.search), r = this._platformLocation.hash; return r && e ? `${i}${r}` : i } pushState(e, i, r, s) { const o = this.prepareExternalUrl(r + Er(s)); this._platformLocation.pushState(e, i, o) } replaceState(e, i, r, s) { const o = this.prepareExternalUrl(r + Er(s)); this._platformLocation.replaceState(e, i, o) } forward() { this._platformLocation.forward() } back() { this._platformLocation.back() } historyGo(e = 0) { var i, r; null === (r = (i = this._platformLocation).historyGo) || void 0 === r || r.call(i, e) } } return n.\u0275fac = function (e) { return new (e || n)(m(fa), m(DL, 8)) }, n.\u0275prov = E({ token: n, factory: n.\u0275fac }), n })(), Aw = (() => { class n { constructor(e, i) { this._subject = new ge, this._urlChangeListeners = [], this._platformStrategy = e; const r = this._platformStrategy.getBaseHref(); this._platformLocation = i, this._baseHref = Mw(Sw(r)), this._platformStrategy.onPopState(s => { this._subject.emit({ url: this.path(!0), pop: !0, state: s.state, type: s.type }) }) } path(e = !1) { return this.normalize(this._platformStrategy.path(e)) } getState() { return this._platformLocation.getState() } isCurrentPathEqualTo(e, i = "") { return this.path() == this.normalize(e + Er(i)) } normalize(e) { return n.stripTrailingSlash(function (n, t) { return n && t.startsWith(n) ? t.substring(n.length) : t }(this._baseHref, Sw(e))) } prepareExternalUrl(e) { return e && "/" !== e[0] && (e = "/" + e), this._platformStrategy.prepareExternalUrl(e) } go(e, i = "", r = null) { this._platformStrategy.pushState(r, "", e, i), this._notifyUrlChangeListeners(this.prepareExternalUrl(e + Er(i)), r) } replaceState(e, i = "", r = null) { this._platformStrategy.replaceState(r, "", e, i), this._notifyUrlChangeListeners(this.prepareExternalUrl(e + Er(i)), r) } forward() { this._platformStrategy.forward() } back() { this._platformStrategy.back() } historyGo(e = 0) { var i, r; null === (r = (i = this._platformStrategy).historyGo) || void 0 === r || r.call(i, e) } onUrlChange(e) { this._urlChangeListeners.push(e), this._urlChangeSubscription || (this._urlChangeSubscription = this.subscribe(i => { this._notifyUrlChangeListeners(i.url, i.state) })) } _notifyUrlChangeListeners(e = "", i) { this._urlChangeListeners.forEach(r => r(e, i)) } subscribe(e, i, r) { return this._subject.subscribe({ next: e, error: i, complete: r }) } } return n.\u0275fac = function (e) { return new (e || n)(m(Rh), m(fa)) }, n.normalizeQueryParams = Er, n.joinWithSlash = xw, n.stripTrailingSlash = Mw, n.\u0275prov = E({ factory: ML, token: n, providedIn: "root" }), n })(); function ML() { return new Aw(m(Rh), m(fa)) } function Sw(n) { return n.replace(/\/index.html$/, "") } var Je = (() => ((Je = Je || {})[Je.Zero = 0] = "Zero", Je[Je.One = 1] = "One", Je[Je.Two = 2] = "Two", Je[Je.Few = 3] = "Few", Je[Je.Many = 4] = "Many", Je[Je.Other = 5] = "Other", Je))(); const OL = function (n) { return function (n) { const t = function (n) { return n.toLowerCase().replace(/_/g, "-") }(n); let e = Xv(t); if (e) return e; const i = t.split("-")[0]; if (e = Xv(i), e) return e; if ("en" === i) return WR; throw new Error(`Missing locale data for the locale "${n}".`) }(n)[F.PluralCase] }; class Cc { } let cV = (() => { class n extends Cc { constructor(e) { super(), this.locale = e } getPluralCategory(e, i) { switch (OL(i || this.locale)(e)) { case Je.Zero: return "zero"; case Je.One: return "one"; case Je.Two: return "two"; case Je.Few: return "few"; case Je.Many: return "many"; default: return "other" } } } return n.\u0275fac = function (e) { return new (e || n)(m(gi)) }, n.\u0275prov = E({ token: n, factory: n.\u0275fac }), n })(); let jh = (() => { class n { constructor(e, i, r, s) { this._iterableDiffers = e, this._keyValueDiffers = i, this._ngEl = r, this._renderer = s, this._iterableDiffer = null, this._keyValueDiffer = null, this._initialClasses = [], this._rawClass = null } set klass(e) { this._removeClasses(this._initialClasses), this._initialClasses = "string" == typeof e ? e.split(/\s+/) : [], this._applyClasses(this._initialClasses), this._applyClasses(this._rawClass) } set ngClass(e) { this._removeClasses(this._rawClass), this._applyClasses(this._initialClasses), this._iterableDiffer = null, this._keyValueDiffer = null, this._rawClass = "string" == typeof e ? e.split(/\s+/) : e, this._rawClass && (Go(this._rawClass) ? this._iterableDiffer = this._iterableDiffers.find(this._rawClass).create() : this._keyValueDiffer = this._keyValueDiffers.find(this._rawClass).create()) } ngDoCheck() { if (this._iterableDiffer) { const e = this._iterableDiffer.diff(this._rawClass); e && this._applyIterableChanges(e) } else if (this._keyValueDiffer) { const e = this._keyValueDiffer.diff(this._rawClass); e && this._applyKeyValueChanges(e) } } _applyKeyValueChanges(e) { e.forEachAddedItem(i => this._toggleClass(i.key, i.currentValue)), e.forEachChangedItem(i => this._toggleClass(i.key, i.currentValue)), e.forEachRemovedItem(i => { i.previousValue && this._toggleClass(i.key, !1) }) } _applyIterableChanges(e) { e.forEachAddedItem(i => { if ("string" != typeof i.item) throw new Error(`NgClass can only toggle CSS classes expressed as strings, got ${re(i.item)}`); this._toggleClass(i.item, !0) }), e.forEachRemovedItem(i => this._toggleClass(i.item, !1)) } _applyClasses(e) { e && (Array.isArray(e) || e instanceof Set ? e.forEach(i => this._toggleClass(i, !0)) : Object.keys(e).forEach(i => this._toggleClass(i, !!e[i]))) } _removeClasses(e) { e && (Array.isArray(e) || e instanceof Set ? e.forEach(i => this._toggleClass(i, !1)) : Object.keys(e).forEach(i => this._toggleClass(i, !1))) } _toggleClass(e, i) { (e = e.trim()) && e.split(/\s+/g).forEach(r => { i ? this._renderer.addClass(this._ngEl.nativeElement, r) : this._renderer.removeClass(this._ngEl.nativeElement, r) }) } } return n.\u0275fac = function (e) { return new (e || n)(g(_r), g(Li), g(O), g(pi)) }, n.\u0275dir = C({ type: n, selectors: [["", "ngClass", ""]], inputs: { klass: ["class", "klass"], ngClass: "ngClass" } }), n })(), js = (() => { class n { constructor(e, i) { this._viewContainer = e, this._context = new pV, this._thenTemplateRef = null, this._elseTemplateRef = null, this._thenViewRef = null, this._elseViewRef = null, this._thenTemplateRef = i } set ngIf(e) { this._context.$implicit = this._context.ngIf = e, this._updateView() } set ngIfThen(e) { Bw("ngIfThen", e), this._thenTemplateRef = e, this._thenViewRef = null, this._updateView() } set ngIfElse(e) { Bw("ngIfElse", e), this._elseTemplateRef = e, this._elseViewRef = null, this._updateView() } _updateView() { this._context.$implicit ? this._thenViewRef || (this._viewContainer.clear(), this._elseViewRef = null, this._thenTemplateRef && (this._thenViewRef = this._viewContainer.createEmbeddedView(this._thenTemplateRef, this._context))) : this._elseViewRef || (this._viewContainer.clear(), this._thenViewRef = null, this._elseTemplateRef && (this._elseViewRef = this._viewContainer.createEmbeddedView(this._elseTemplateRef, this._context))) } static ngTemplateContextGuard(e, i) { return !0 } } return n.\u0275fac = function (e) { return new (e || n)(g(Lt), g(Kt)) }, n.\u0275dir = C({ type: n, selectors: [["", "ngIf", ""]], inputs: { ngIf: "ngIf", ngIfThen: "ngIfThen", ngIfElse: "ngIfElse" } }), n })(); class pV { constructor() { this.$implicit = null, this.ngIf = null } } function Bw(n, t) { if (t && !t.createEmbeddedView) throw new Error(`${n} must be a TemplateRef, but received '${re(t)}'.`) } class Gh { constructor(t, e) { this._viewContainerRef = t, this._templateRef = e, this._created = !1 } create() { this._created = !0, this._viewContainerRef.createEmbeddedView(this._templateRef) } destroy() { this._created = !1, this._viewContainerRef.clear() } enforceState(t) { t && !this._created ? this.create() : !t && this._created && this.destroy() } } let wc = (() => { class n { constructor() { this._defaultUsed = !1, this._caseCount = 0, this._lastCaseCheckIndex = 0, this._lastCasesMatched = !1 } set ngSwitch(e) { this._ngSwitch = e, 0 === this._caseCount && this._updateDefaultCases(!0) } _addCase() { return this._caseCount++ } _addDefault(e) { this._defaultViews || (this._defaultViews = []), this._defaultViews.push(e) } _matchCase(e) { const i = e == this._ngSwitch; return this._lastCasesMatched = this._lastCasesMatched || i, this._lastCaseCheckIndex++, this._lastCaseCheckIndex === this._caseCount && (this._updateDefaultCases(!this._lastCasesMatched), this._lastCaseCheckIndex = 0, this._lastCasesMatched = !1), i } _updateDefaultCases(e) { if (this._defaultViews && e !== this._defaultUsed) { this._defaultUsed = e; for (let i = 0; i < this._defaultViews.length; i++)this._defaultViews[i].enforceState(e) } } } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275dir = C({ type: n, selectors: [["", "ngSwitch", ""]], inputs: { ngSwitch: "ngSwitch" } }), n })(), Hw = (() => { class n { constructor(e, i, r) { this.ngSwitch = r, r._addCase(), this._view = new Gh(e, i) } ngDoCheck() { this._view.enforceState(this.ngSwitch._matchCase(this.ngSwitchCase)) } } return n.\u0275fac = function (e) { return new (e || n)(g(Lt), g(Kt), g(wc, 9)) }, n.\u0275dir = C({ type: n, selectors: [["", "ngSwitchCase", ""]], inputs: { ngSwitchCase: "ngSwitchCase" } }), n })(), Ec = (() => { class n { } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275mod = ee({ type: n }), n.\u0275inj = X({ providers: [{ provide: Cc, useClass: cV }] }), n })(); const $w = "browser"; function Dr(n) { return n === $w } function Gs(n) { return "server" === n } class Wh extends class extends class { }{ constructor() { super(...arguments), this.supportsDOMEvents = !0 } }{ static makeCurrent() { !function (n) { dc || (dc = n) }(new Wh) } onAndCancel(t, e, i) { return t.addEventListener(e, i, !1), () => { t.removeEventListener(e, i, !1) } } dispatchEvent(t, e) { t.dispatchEvent(e) } remove(t) { t.parentNode && t.parentNode.removeChild(t) } createElement(t, e) { return (e = e || this.getDefaultDocument()).createElement(t) } createHtmlDocument() { return document.implementation.createHTMLDocument("fakeTitle") } getDefaultDocument() { return document } isElementNode(t) { return t.nodeType === Node.ELEMENT_NODE } isShadowRoot(t) { return t instanceof DocumentFragment } getGlobalEventTarget(t, e) { return "window" === e ? window : "document" === e ? t : "body" === e ? t.body : null } getBaseHref(t) { const e = (ga = ga || document.querySelector("base"), ga ? ga.getAttribute("href") : null); return null == e ? null : function (n) { Dc = Dc || document.createElement("a"), Dc.setAttribute("href", n); const t = Dc.pathname; return "/" === t.charAt(0) ? t : `/${t}` }(e) } resetBaseElement() { ga = null } getUserAgent() { return window.navigator.userAgent } getCookie(t) { return function (n, t) { t = encodeURIComponent(t); for (const e of n.split(";")) { const i = e.indexOf("="), [r, s] = -1 == i ? [e, ""] : [e.slice(0, i), e.slice(i + 1)]; if (r.trim() === t) return decodeURIComponent(s) } return null }(document.cookie, t) } } let Dc, ga = null; const Ww = new k("TRANSITION_ID"), WV = [{ provide: Xl, useFactory: function (n, t, e) { return () => { e.get(Ls).donePromise.then(() => { const i = Xn(); Array.prototype.slice.apply(t.querySelectorAll("style[ng-transition]")).filter(s => s.getAttribute("ng-transition") === n).forEach(s => i.remove(s)) }) } }, deps: [Ww, N, ce], multi: !0 }]; class qh { static init() { !function (n) { gh = n }(new qh) } addToWindow(t) { _e.getAngularTestability = (i, r = !0) => { const s = t.findTestabilityInTree(i, r); if (null == s) throw new Error("Could not find testability for element."); return s }, _e.getAllAngularTestabilities = () => t.getAllTestabilities(), _e.getAllAngularRootElements = () => t.getAllRootElements(), _e.frameworkStabilizers || (_e.frameworkStabilizers = []), _e.frameworkStabilizers.push(i => { const r = _e.getAllAngularTestabilities(); let s = r.length, o = !1; const a = function (l) { o = o || l, s--, 0 == s && i(o) }; r.forEach(function (l) { l.whenStable(a) }) }) } findTestabilityInTree(t, e, i) { if (null == e) return null; const r = t.getTestability(e); return null != r ? r : i ? Xn().isShadowRoot(e) ? this.findTestabilityInTree(t, e.host, !0) : this.findTestabilityInTree(t, e.parentElement, !0) : null } } let qV = (() => { class n { build() { return new XMLHttpRequest } } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275prov = E({ token: n, factory: n.\u0275fac }), n })(); const ma = new k("EventManagerPlugins"); let Mc = (() => { class n { constructor(e, i) { this._zone = i, this._eventNameToPlugin = new Map, e.forEach(r => r.manager = this), this._plugins = e.slice().reverse() } addEventListener(e, i, r) { return this._findPluginFor(i).addEventListener(e, i, r) } addGlobalEventListener(e, i, r) { return this._findPluginFor(i).addGlobalEventListener(e, i, r) } getZone() { return this._zone } _findPluginFor(e) { const i = this._eventNameToPlugin.get(e); if (i) return i; const r = this._plugins; for (let s = 0; s < r.length; s++) { const o = r[s]; if (o.supports(e)) return this._eventNameToPlugin.set(e, o), o } throw new Error(`No event manager plugin found for event ${e}`) } } return n.\u0275fac = function (e) { return new (e || n)(m(ma), m(H)) }, n.\u0275prov = E({ token: n, factory: n.\u0275fac }), n })(); class Kh { constructor(t) { this._doc = t } addGlobalEventListener(t, e, i) { const r = Xn().getGlobalEventTarget(this._doc, t); if (!r) throw new Error(`Unsupported event target ${r} for event ${e}`); return this.addEventListener(r, e, i) } } let Kw = (() => { class n { constructor() { this._stylesSet = new Set } addStyles(e) { const i = new Set; e.forEach(r => { this._stylesSet.has(r) || (this._stylesSet.add(r), i.add(r)) }), this.onStylesAdded(i) } onStylesAdded(e) { } getAllStyles() { return Array.from(this._stylesSet) } } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275prov = E({ token: n, factory: n.\u0275fac }), n })(), _a = (() => { class n extends Kw { constructor(e) { super(), this._doc = e, this._hostNodes = new Map, this._hostNodes.set(e.head, []) } _addStylesToHost(e, i, r) { e.forEach(s => { const o = this._doc.createElement("style"); o.textContent = s, r.push(i.appendChild(o)) }) } addHost(e) { const i = []; this._addStylesToHost(this._stylesSet, e, i), this._hostNodes.set(e, i) } removeHost(e) { const i = this._hostNodes.get(e); i && i.forEach(Qw), this._hostNodes.delete(e) } onStylesAdded(e) { this._hostNodes.forEach((i, r) => { this._addStylesToHost(e, r, i) }) } ngOnDestroy() { this._hostNodes.forEach(e => e.forEach(Qw)) } } return n.\u0275fac = function (e) { return new (e || n)(m(N)) }, n.\u0275prov = E({ token: n, factory: n.\u0275fac }), n })(); function Qw(n) { Xn().remove(n) } const Qh = { svg: "http://www.w3.org/2000/svg", xhtml: "http://www.w3.org/1999/xhtml", xlink: "http://www.w3.org/1999/xlink", xml: "http://www.w3.org/XML/1998/namespace", xmlns: "http://www.w3.org/2000/xmlns/" }, Yh = /%COMP%/g; function Ac(n, t, e) { for (let i = 0; i < t.length; i++) { let r = t[i]; Array.isArray(r) ? Ac(n, r, e) : (r = r.replace(Yh, n), e.push(r)) } return e } function Zw(n) { return t => { if ("__ngUnwrap__" === t) return n; !1 === n(t) && (t.preventDefault(), t.returnValue = !1) } } let Sc = (() => { class n { constructor(e, i, r) { this.eventManager = e, this.sharedStylesHost = i, this.appId = r, this.rendererByCompId = new Map, this.defaultRenderer = new Jh(e) } createRenderer(e, i) { if (!e || !i) return this.defaultRenderer; switch (i.encapsulation) { case qe.Emulated: { let r = this.rendererByCompId.get(i.id); return r || (r = new lB(this.eventManager, this.sharedStylesHost, i, this.appId), this.rendererByCompId.set(i.id, r)), r.applyToHost(e), r } case 1: case qe.ShadowDom: return new cB(this.eventManager, this.sharedStylesHost, e, i); default: if (!this.rendererByCompId.has(i.id)) { const r = Ac(i.id, i.styles, []); this.sharedStylesHost.addStyles(r), this.rendererByCompId.set(i.id, this.defaultRenderer) } return this.defaultRenderer } } begin() { } end() { } } return n.\u0275fac = function (e) { return new (e || n)(m(Mc), m(_a), m(aa)) }, n.\u0275prov = E({ token: n, factory: n.\u0275fac }), n })(); class Jh { constructor(t) { this.eventManager = t, this.data = Object.create(null) } destroy() { } createElement(t, e) { return e ? document.createElementNS(Qh[e] || e, t) : document.createElement(t) } createComment(t) { return document.createComment(t) } createText(t) { return document.createTextNode(t) } appendChild(t, e) { t.appendChild(e) } insertBefore(t, e, i) { t && t.insertBefore(e, i) } removeChild(t, e) { t && t.removeChild(e) } selectRootElement(t, e) { let i = "string" == typeof t ? document.querySelector(t) : t; if (!i) throw new Error(`The selector "${t}" did not match any elements`); return e || (i.textContent = ""), i } parentNode(t) { return t.parentNode } nextSibling(t) { return t.nextSibling } setAttribute(t, e, i, r) { if (r) { e = r + ":" + e; const s = Qh[r]; s ? t.setAttributeNS(s, e, i) : t.setAttribute(e, i) } else t.setAttribute(e, i) } removeAttribute(t, e, i) { if (i) { const r = Qh[i]; r ? t.removeAttributeNS(r, e) : t.removeAttribute(`${i}:${e}`) } else t.removeAttribute(e) } addClass(t, e) { t.classList.add(e) } removeClass(t, e) { t.classList.remove(e) } setStyle(t, e, i, r) { r & (Wt.DashCase | Wt.Important) ? t.style.setProperty(e, i, r & Wt.Important ? "important" : "") : t.style[e] = i } removeStyle(t, e, i) { i & Wt.DashCase ? t.style.removeProperty(e) : t.style[e] = "" } setProperty(t, e, i) { t[e] = i } setValue(t, e) { t.nodeValue = e } listen(t, e, i) { return "string" == typeof t ? this.eventManager.addGlobalEventListener(t, e, Zw(i)) : this.eventManager.addEventListener(t, e, Zw(i)) } } class lB extends Jh { constructor(t, e, i, r) { super(t), this.component = i; const s = Ac(r + "-" + i.id, i.styles, []); e.addStyles(s), this.contentAttr = function (n) { return "_ngcontent-%COMP%".replace(Yh, n) }(r + "-" + i.id), this.hostAttr = function (n) { return "_nghost-%COMP%".replace(Yh, n) }(r + "-" + i.id) } applyToHost(t) { super.setAttribute(t, this.hostAttr, "") } createElement(t, e) { const i = super.createElement(t, e); return super.setAttribute(i, this.contentAttr, ""), i } } class cB extends Jh { constructor(t, e, i, r) { super(t), this.sharedStylesHost = e, this.hostEl = i, this.shadowRoot = i.attachShadow({ mode: "open" }), this.sharedStylesHost.addHost(this.shadowRoot); const s = Ac(r.id, r.styles, []); for (let o = 0; o < s.length; o++) { const a = document.createElement("style"); a.textContent = s[o], this.shadowRoot.appendChild(a) } } nodeOrShadowRoot(t) { return t === this.hostEl ? this.shadowRoot : t } destroy() { this.sharedStylesHost.removeHost(this.shadowRoot) } appendChild(t, e) { return super.appendChild(this.nodeOrShadowRoot(t), e) } insertBefore(t, e, i) { return super.insertBefore(this.nodeOrShadowRoot(t), e, i) } removeChild(t, e) { return super.removeChild(this.nodeOrShadowRoot(t), e) } parentNode(t) { return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(t))) } } let uB = (() => { class n extends Kh { constructor(e) { super(e) } supports(e) { return !0 } addEventListener(e, i, r) { return e.addEventListener(i, r, !1), () => this.removeEventListener(e, i, r) } removeEventListener(e, i, r) { return e.removeEventListener(i, r) } } return n.\u0275fac = function (e) { return new (e || n)(m(N)) }, n.\u0275prov = E({ token: n, factory: n.\u0275fac }), n })(); const tE = ["alt", "control", "meta", "shift"], _B = { "\b": "Backspace", "\t": "Tab", "\x7f": "Delete", "\x1b": "Escape", Del: "Delete", Esc: "Escape", Left: "ArrowLeft", Right: "ArrowRight", Up: "ArrowUp", Down: "ArrowDown", Menu: "ContextMenu", Scroll: "ScrollLock", Win: "OS" }, nE = { A: "1", B: "2", C: "3", D: "4", E: "5", F: "6", G: "7", H: "8", I: "9", J: "*", K: "+", M: "-", N: ".", O: "/", "`": "0", "\x90": "NumLock" }, yB = { alt: n => n.altKey, control: n => n.ctrlKey, meta: n => n.metaKey, shift: n => n.shiftKey }; let vB = (() => { class n extends Kh { constructor(e) { super(e) } supports(e) { return null != n.parseEventName(e) } addEventListener(e, i, r) { const s = n.parseEventName(i), o = n.eventCallback(s.fullKey, r, this.manager.getZone()); return this.manager.getZone().runOutsideAngular(() => Xn().onAndCancel(e, s.domEventName, o)) } static parseEventName(e) { const i = e.toLowerCase().split("."), r = i.shift(); if (0 === i.length || "keydown" !== r && "keyup" !== r) return null; const s = n._normalizeKey(i.pop()); let o = ""; if (tE.forEach(l => { const c = i.indexOf(l); c > -1 && (i.splice(c, 1), o += l + ".") }), o += s, 0 != i.length || 0 === s.length) return null; const a = {}; return a.domEventName = r, a.fullKey = o, a } static getEventFullKey(e) { let i = "", r = function (n) { let t = n.key; if (null == t) { if (t = n.keyIdentifier, null == t) return "Unidentified"; t.startsWith("U+") && (t = String.fromCharCode(parseInt(t.substring(2), 16)), 3 === n.location && nE.hasOwnProperty(t) && (t = nE[t])) } return _B[t] || t }(e); return r = r.toLowerCase(), " " === r ? r = "space" : "." === r && (r = "dot"), tE.forEach(s => { s != r && yB[s](e) && (i += s + ".") }), i += r, i } static eventCallback(e, i, r) { return s => { n.getEventFullKey(s) === e && r.runGuarded(() => i(s)) } } static _normalizeKey(e) { switch (e) { case "esc": return "escape"; default: return e } } } return n.\u0275fac = function (e) { return new (e || n)(m(N)) }, n.\u0275prov = E({ token: n, factory: n.\u0275fac }), n })(), xr = (() => { class n { } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275prov = E({ factory: function () { return m(Xh) }, token: n, providedIn: "root" }), n })(), Xh = (() => { class n extends xr { constructor(e) { super(), this._doc = e } sanitize(e, i) { if (null == i) return null; switch (e) { case de.NONE: return i; case de.HTML: return zn(i, "HTML") ? zt(i) : i_(this._doc, String(i)).toString(); case de.STYLE: return zn(i, "Style") ? zt(i) : i; case de.SCRIPT: if (zn(i, "Script")) return zt(i); throw new Error("unsafe value used in a script context"); case de.URL: return Qm(i), zn(i, "URL") ? zt(i) : Fo(String(i)); case de.RESOURCE_URL: if (zn(i, "ResourceURL")) return zt(i); throw new Error("unsafe value used in a resource URL context (see https://g.co/ng/security#xss)"); default: throw new Error(`Unexpected SecurityContext ${e} (see https://g.co/ng/security#xss)`) } } bypassSecurityTrustHtml(e) { return function (n) { return new Z0(n) }(e) } bypassSecurityTrustStyle(e) { return function (n) { return new X0(n) }(e) } bypassSecurityTrustScript(e) { return function (n) { return new eT(n) }(e) } bypassSecurityTrustUrl(e) { return function (n) { return new tT(n) }(e) } bypassSecurityTrustResourceUrl(e) { return function (n) { return new nT(n) }(e) } } return n.\u0275fac = function (e) { return new (e || n)(m(N)) }, n.\u0275prov = E({ factory: function () { return function (n) { return new Xh(n.get(N)) }(m(fr)) }, token: n, providedIn: "root" }), n })(); const AB = WC(gP, "browser", [{ provide: bt, useValue: $w }, { provide: PC, useValue: function () { Wh.makeCurrent(), qh.init() }, multi: !0 }, { provide: N, useFactory: function () { return function (n) { Ku = n }(document), document }, deps: [] }]), SB = [[], { provide: Bo, useValue: "root" }, { provide: wn, useFactory: function () { return new wn }, deps: [] }, { provide: ma, useClass: uB, multi: !0, deps: [N, H, bt] }, { provide: ma, useClass: vB, multi: !0, deps: [N] }, [], { provide: Sc, useClass: Sc, deps: [Mc, _a, aa] }, { provide: mr, useExisting: Sc }, { provide: Kw, useExisting: _a }, { provide: _a, useClass: _a, deps: [N] }, { provide: ph, useClass: ph, deps: [H] }, { provide: Mc, useClass: Mc, deps: [ma, H] }, { provide: class { }, useClass: qV, deps: [] }, []]; let ep = (() => { class n { constructor(e) { if (e) throw new Error("BrowserModule has already been loaded. If you need access to common directives such as NgIf and NgFor from a lazy loaded module, import CommonModule instead.") } static withServerTransition(e) { return { ngModule: n, providers: [{ provide: aa, useValue: e.appId }, { provide: Ww, useExisting: aa }, WV] } } } return n.\u0275fac = function (e) { return new (e || n)(m(n, 12)) }, n.\u0275mod = ee({ type: n }), n.\u0275inj = X({ providers: SB, imports: [Ec, wP] }), n })(); function rE(...n) { if (1 === n.length) { const t = n[0]; if (jr(t)) return Tc(t, null); if (Fu(t) && Object.getPrototypeOf(t) === Object.prototype) { const e = Object.keys(t); return Tc(e.map(i => t[i]), e) } } if ("function" == typeof n[n.length - 1]) { const t = n.pop(); return Tc(n = 1 === n.length && jr(n[0]) ? n[0] : n, null).pipe(Dt(e => t(...e))) } return Tc(n, null) } function Tc(n, t) { return new me(e => { const i = n.length; if (0 === i) return void e.complete(); const r = new Array(i); let s = 0, o = 0; for (let a = 0; a < i; a++) { const l = Ga(n[a]); let c = !1; e.add(l.subscribe({ next: u => { c || (c = !0, o++), r[a] = u }, error: u => e.error(u), complete: () => { s++, (s === i || !c) && (o === i && e.next(t ? t.reduce((u, d, f) => (u[d] = r[f], u), {}) : r), e.complete()) } })) } }) } "undefined" != typeof window && window; let sE = (() => { class n { constructor(e, i) { this._renderer = e, this._elementRef = i, this.onChange = r => { }, this.onTouched = () => { } } setProperty(e, i) { this._renderer.setProperty(this._elementRef.nativeElement, e, i) } registerOnTouched(e) { this.onTouched = e } registerOnChange(e) { this.onChange = e } setDisabledState(e) { this.setProperty("disabled", e) } } return n.\u0275fac = function (e) { return new (e || n)(g(pi), g(O)) }, n.\u0275dir = C({ type: n }), n })(), Mr = (() => { class n extends sE { } return n.\u0275fac = function () { let t; return function (i) { return (t || (t = P(n)))(i || n) } }(), n.\u0275dir = C({ type: n, features: [D] }), n })(); const ei = new k("NgValueAccessor"), LB = { provide: ei, useExisting: xe(() => Ic), multi: !0 }, BB = new k("CompositionEventMode"); let Ic = (() => { class n extends sE { constructor(e, i, r) { super(e, i), this._compositionMode = r, this._composing = !1, null == this._compositionMode && (this._compositionMode = !function () { const n = Xn() ? Xn().getUserAgent() : ""; return /android (\d+)/.test(n.toLowerCase()) }()) } writeValue(e) { this.setProperty("value", null == e ? "" : e) } _handleInput(e) { (!this._compositionMode || this._compositionMode && !this._composing) && this.onChange(e) } _compositionStart() { this._composing = !0 } _compositionEnd(e) { this._composing = !1, this._compositionMode && this.onChange(e) } } return n.\u0275fac = function (e) { return new (e || n)(g(pi), g(O), g(BB, 8)) }, n.\u0275dir = C({ type: n, selectors: [["input", "formControlName", "", 3, "type", "checkbox"], ["textarea", "formControlName", ""], ["input", "formControl", "", 3, "type", "checkbox"], ["textarea", "formControl", ""], ["input", "ngModel", "", 3, "type", "checkbox"], ["textarea", "ngModel", ""], ["", "ngDefaultControl", ""]], hostBindings: function (e, i) { 1 & e && ye("input", function (s) { return i._handleInput(s.target.value) })("blur", function () { return i.onTouched() })("compositionstart", function () { return i._compositionStart() })("compositionend", function (s) { return i._compositionEnd(s.target.value) }) }, features: [ae([LB]), D] }), n })(); const Ct = new k("NgValidators"), $i = new k("NgAsyncValidators"); function mE(n) { return null != n } function _E(n) { const t = Nl(n) ? Ga(n) : n; return Cf(t), t } function yE(n) { let t = {}; return n.forEach(e => { t = null != e ? Object.assign(Object.assign({}, t), e) : t }), 0 === Object.keys(t).length ? null : t } function vE(n, t) { return t.map(e => e(n)) } function bE(n) { return n.map(t => function (n) { return !n.validate }(t) ? t : e => t.validate(e)) } function np(n) { return null != n ? function (n) { if (!n) return null; const t = n.filter(mE); return 0 == t.length ? null : function (e) { return yE(vE(e, t)) } }(bE(n)) : null } function ip(n) { return null != n ? function (n) { if (!n) return null; const t = n.filter(mE); return 0 == t.length ? null : function (e) { return rE(vE(e, t).map(_E)).pipe(Dt(yE)) } }(bE(n)) : null } function EE(n, t) { return null === n ? [t] : Array.isArray(n) ? [...n, t] : [n, t] } function DE(n) { return n._rawValidators } function xE(n) { return n._rawAsyncValidators } function rp(n) { return n ? Array.isArray(n) ? n : [n] : [] } function Fc(n, t) { return Array.isArray(n) ? n.includes(t) : n === t } function ME(n, t) { const e = rp(t); return rp(n).forEach(r => { Fc(e, r) || e.push(r) }), e } function AE(n, t) { return rp(t).filter(e => !Fc(n, e)) } let SE = (() => { class n { constructor() { this._rawValidators = [], this._rawAsyncValidators = [], this._onDestroyCallbacks = [] } get value() { return this.control ? this.control.value : null } get valid() { return this.control ? this.control.valid : null } get invalid() { return this.control ? this.control.invalid : null } get pending() { return this.control ? this.control.pending : null } get disabled() { return this.control ? this.control.disabled : null } get enabled() { return this.control ? this.control.enabled : null } get errors() { return this.control ? this.control.errors : null } get pristine() { return this.control ? this.control.pristine : null } get dirty() { return this.control ? this.control.dirty : null } get touched() { return this.control ? this.control.touched : null } get status() { return this.control ? this.control.status : null } get untouched() { return this.control ? this.control.untouched : null } get statusChanges() { return this.control ? this.control.statusChanges : null } get valueChanges() { return this.control ? this.control.valueChanges : null } get path() { return null } _setValidators(e) { this._rawValidators = e || [], this._composedValidatorFn = np(this._rawValidators) } _setAsyncValidators(e) { this._rawAsyncValidators = e || [], this._composedAsyncValidatorFn = ip(this._rawAsyncValidators) } get validator() { return this._composedValidatorFn || null } get asyncValidator() { return this._composedAsyncValidatorFn || null } _registerOnDestroy(e) { this._onDestroyCallbacks.push(e) } _invokeOnDestroyCallbacks() { this._onDestroyCallbacks.forEach(e => e()), this._onDestroyCallbacks = [] } reset(e) { this.control && this.control.reset(e) } hasError(e, i) { return !!this.control && this.control.hasError(e, i) } getError(e, i) { return this.control ? this.control.getError(e, i) : null } } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275dir = C({ type: n }), n })(), kt = (() => { class n extends SE { get formDirective() { return null } get path() { return null } } return n.\u0275fac = function () { let t; return function (i) { return (t || (t = P(n)))(i || n) } }(), n.\u0275dir = C({ type: n, features: [D] }), n })(); class yi extends SE { constructor() { super(...arguments), this._parent = null, this.name = null, this.valueAccessor = null } } class TE { constructor(t) { this._cd = t } is(t) { var e, i, r; return "submitted" === t ? !!(null === (e = this._cd) || void 0 === e ? void 0 : e.submitted) : !!(null === (r = null === (i = this._cd) || void 0 === i ? void 0 : i.control) || void 0 === r ? void 0 : r[t]) } } let IE = (() => { class n extends TE { constructor(e) { super(e) } } return n.\u0275fac = function (e) { return new (e || n)(g(yi, 2)) }, n.\u0275dir = C({ type: n, selectors: [["", "formControlName", ""], ["", "ngModel", ""], ["", "formControl", ""]], hostVars: 14, hostBindings: function (e, i) { 2 & e && je("ng-untouched", i.is("untouched"))("ng-touched", i.is("touched"))("ng-pristine", i.is("pristine"))("ng-dirty", i.is("dirty"))("ng-valid", i.is("valid"))("ng-invalid", i.is("invalid"))("ng-pending", i.is("pending")) }, features: [D] }), n })(), FE = (() => { class n extends TE { constructor(e) { super(e) } } return n.\u0275fac = function (e) { return new (e || n)(g(kt, 10)) }, n.\u0275dir = C({ type: n, selectors: [["", "formGroupName", ""], ["", "formArrayName", ""], ["", "ngModelGroup", ""], ["", "formGroup", ""], ["form", 3, "ngNoForm", ""], ["", "ngForm", ""]], hostVars: 16, hostBindings: function (e, i) { 2 & e && je("ng-untouched", i.is("untouched"))("ng-touched", i.is("touched"))("ng-pristine", i.is("pristine"))("ng-dirty", i.is("dirty"))("ng-valid", i.is("valid"))("ng-invalid", i.is("invalid"))("ng-pending", i.is("pending"))("ng-submitted", i.is("submitted")) }, features: [D] }), n })(); function ya(n, t) { sp(n, t), t.valueAccessor.writeValue(n.value), function (n, t) { t.valueAccessor.registerOnChange(e => { n._pendingValue = e, n._pendingChange = !0, n._pendingDirty = !0, "change" === n.updateOn && RE(n, t) }) }(n, t), function (n, t) { const e = (i, r) => { t.valueAccessor.writeValue(i), r && t.viewToModelUpdate(i) }; n.registerOnChange(e), t._registerOnDestroy(() => { n._unregisterOnChange(e) }) }(n, t), function (n, t) { t.valueAccessor.registerOnTouched(() => { n._pendingTouched = !0, "blur" === n.updateOn && n._pendingChange && RE(n, t), "submit" !== n.updateOn && n.markAsTouched() }) }(n, t), function (n, t) { if (t.valueAccessor.setDisabledState) { const e = i => { t.valueAccessor.setDisabledState(i) }; n.registerOnDisabledChange(e), t._registerOnDestroy(() => { n._unregisterOnDisabledChange(e) }) } }(n, t) } function kc(n, t, e = !0) { const i = () => { }; t.valueAccessor && (t.valueAccessor.registerOnChange(i), t.valueAccessor.registerOnTouched(i)), Nc(n, t), n && (t._invokeOnDestroyCallbacks(), n._registerOnCollectionChange(() => { })) } function Oc(n, t) { n.forEach(e => { e.registerOnValidatorChange && e.registerOnValidatorChange(t) }) } function sp(n, t) { const e = DE(n); null !== t.validator ? n.setValidators(EE(e, t.validator)) : "function" == typeof e && n.setValidators([e]); const i = xE(n); null !== t.asyncValidator ? n.setAsyncValidators(EE(i, t.asyncValidator)) : "function" == typeof i && n.setAsyncValidators([i]); const r = () => n.updateValueAndValidity(); Oc(t._rawValidators, r), Oc(t._rawAsyncValidators, r) } function Nc(n, t) { let e = !1; if (null !== n) { if (null !== t.validator) { const r = DE(n); if (Array.isArray(r) && r.length > 0) { const s = r.filter(o => o !== t.validator); s.length !== r.length && (e = !0, n.setValidators(s)) } } if (null !== t.asyncValidator) { const r = xE(n); if (Array.isArray(r) && r.length > 0) { const s = r.filter(o => o !== t.asyncValidator); s.length !== r.length && (e = !0, n.setAsyncValidators(s)) } } } const i = () => { }; return Oc(t._rawValidators, i), Oc(t._rawAsyncValidators, i), e } function RE(n, t) { n._pendingDirty && n.markAsDirty(), n.setValue(n._pendingValue, { emitModelToViewChange: !1 }), t.viewToModelUpdate(n._pendingValue), n._pendingChange = !1 } function kE(n, t) { sp(n, t) } function OE(n, t) { n._syncPendingControls(), t.forEach(e => { const i = e.control; "submit" === i.updateOn && i._pendingChange && (e.viewToModelUpdate(i._pendingValue), i._pendingChange = !1) }) } function Pc(n, t) { const e = n.indexOf(t); e > -1 && n.splice(e, 1) } const va = "VALID", Lc = "INVALID", $s = "PENDING", ba = "DISABLED"; function lp(n) { return (up(n) ? n.validators : n) || null } function NE(n) { return Array.isArray(n) ? np(n) : n || null } function cp(n, t) { return (up(t) ? t.asyncValidators : n) || null } function PE(n) { return Array.isArray(n) ? ip(n) : n || null } function up(n) { return null != n && !Array.isArray(n) && "object" == typeof n } class dp { constructor(t, e) { this._hasOwnPendingAsyncValidator = !1, this._onCollectionChange = () => { }, this._parent = null, this.pristine = !0, this.touched = !1, this._onDisabledChange = [], this._rawValidators = t, this._rawAsyncValidators = e, this._composedValidatorFn = NE(this._rawValidators), this._composedAsyncValidatorFn = PE(this._rawAsyncValidators) } get validator() { return this._composedValidatorFn } set validator(t) { this._rawValidators = this._composedValidatorFn = t } get asyncValidator() { return this._composedAsyncValidatorFn } set asyncValidator(t) { this._rawAsyncValidators = this._composedAsyncValidatorFn = t } get parent() { return this._parent } get valid() { return this.status === va } get invalid() { return this.status === Lc } get pending() { return this.status == $s } get disabled() { return this.status === ba } get enabled() { return this.status !== ba } get dirty() { return !this.pristine } get untouched() { return !this.touched } get updateOn() { return this._updateOn ? this._updateOn : this.parent ? this.parent.updateOn : "change" } setValidators(t) { this._rawValidators = t, this._composedValidatorFn = NE(t) } setAsyncValidators(t) { this._rawAsyncValidators = t, this._composedAsyncValidatorFn = PE(t) } addValidators(t) { this.setValidators(ME(t, this._rawValidators)) } addAsyncValidators(t) { this.setAsyncValidators(ME(t, this._rawAsyncValidators)) } removeValidators(t) { this.setValidators(AE(t, this._rawValidators)) } removeAsyncValidators(t) { this.setAsyncValidators(AE(t, this._rawAsyncValidators)) } hasValidator(t) { return Fc(this._rawValidators, t) } hasAsyncValidator(t) { return Fc(this._rawAsyncValidators, t) } clearValidators() { this.validator = null } clearAsyncValidators() { this.asyncValidator = null } markAsTouched(t = {}) { this.touched = !0, this._parent && !t.onlySelf && this._parent.markAsTouched(t) } markAllAsTouched() { this.markAsTouched({ onlySelf: !0 }), this._forEachChild(t => t.markAllAsTouched()) } markAsUntouched(t = {}) { this.touched = !1, this._pendingTouched = !1, this._forEachChild(e => { e.markAsUntouched({ onlySelf: !0 }) }), this._parent && !t.onlySelf && this._parent._updateTouched(t) } markAsDirty(t = {}) { this.pristine = !1, this._parent && !t.onlySelf && this._parent.markAsDirty(t) } markAsPristine(t = {}) { this.pristine = !0, this._pendingDirty = !1, this._forEachChild(e => { e.markAsPristine({ onlySelf: !0 }) }), this._parent && !t.onlySelf && this._parent._updatePristine(t) } markAsPending(t = {}) { this.status = $s, !1 !== t.emitEvent && this.statusChanges.emit(this.status), this._parent && !t.onlySelf && this._parent.markAsPending(t) } disable(t = {}) { const e = this._parentMarkedDirty(t.onlySelf); this.status = ba, this.errors = null, this._forEachChild(i => { i.disable(Object.assign(Object.assign({}, t), { onlySelf: !0 })) }), this._updateValue(), !1 !== t.emitEvent && (this.valueChanges.emit(this.value), this.statusChanges.emit(this.status)), this._updateAncestors(Object.assign(Object.assign({}, t), { skipPristineCheck: e })), this._onDisabledChange.forEach(i => i(!0)) } enable(t = {}) { const e = this._parentMarkedDirty(t.onlySelf); this.status = va, this._forEachChild(i => { i.enable(Object.assign(Object.assign({}, t), { onlySelf: !0 })) }), this.updateValueAndValidity({ onlySelf: !0, emitEvent: t.emitEvent }), this._updateAncestors(Object.assign(Object.assign({}, t), { skipPristineCheck: e })), this._onDisabledChange.forEach(i => i(!1)) } _updateAncestors(t) { this._parent && !t.onlySelf && (this._parent.updateValueAndValidity(t), t.skipPristineCheck || this._parent._updatePristine(), this._parent._updateTouched()) } setParent(t) { this._parent = t } updateValueAndValidity(t = {}) { this._setInitialStatus(), this._updateValue(), this.enabled && (this._cancelExistingSubscription(), this.errors = this._runValidator(), this.status = this._calculateStatus(), (this.status === va || this.status === $s) && this._runAsyncValidator(t.emitEvent)), !1 !== t.emitEvent && (this.valueChanges.emit(this.value), this.statusChanges.emit(this.status)), this._parent && !t.onlySelf && this._parent.updateValueAndValidity(t) } _updateTreeValidity(t = { emitEvent: !0 }) { this._forEachChild(e => e._updateTreeValidity(t)), this.updateValueAndValidity({ onlySelf: !0, emitEvent: t.emitEvent }) } _setInitialStatus() { this.status = this._allControlsDisabled() ? ba : va } _runValidator() { return this.validator ? this.validator(this) : null } _runAsyncValidator(t) { if (this.asyncValidator) { this.status = $s, this._hasOwnPendingAsyncValidator = !0; const e = _E(this.asyncValidator(this)); this._asyncValidationSubscription = e.subscribe(i => { this._hasOwnPendingAsyncValidator = !1, this.setErrors(i, { emitEvent: t }) }) } } _cancelExistingSubscription() { this._asyncValidationSubscription && (this._asyncValidationSubscription.unsubscribe(), this._hasOwnPendingAsyncValidator = !1) } setErrors(t, e = {}) { this.errors = t, this._updateControlsErrors(!1 !== e.emitEvent) } get(t) { return function (n, t, e) { if (null == t || (Array.isArray(t) || (t = t.split(".")), Array.isArray(t) && 0 === t.length)) return null; let i = n; return t.forEach(r => { i = i instanceof fp ? i.controls.hasOwnProperty(r) ? i.controls[r] : null : i instanceof JB && i.at(r) || null }), i }(this, t) } getError(t, e) { const i = e ? this.get(e) : this; return i && i.errors ? i.errors[t] : null } hasError(t, e) { return !!this.getError(t, e) } get root() { let t = this; for (; t._parent;)t = t._parent; return t } _updateControlsErrors(t) { this.status = this._calculateStatus(), t && this.statusChanges.emit(this.status), this._parent && this._parent._updateControlsErrors(t) } _initObservables() { this.valueChanges = new ge, this.statusChanges = new ge } _calculateStatus() { return this._allControlsDisabled() ? ba : this.errors ? Lc : this._hasOwnPendingAsyncValidator || this._anyControlsHaveStatus($s) ? $s : this._anyControlsHaveStatus(Lc) ? Lc : va } _anyControlsHaveStatus(t) { return this._anyControls(e => e.status === t) } _anyControlsDirty() { return this._anyControls(t => t.dirty) } _anyControlsTouched() { return this._anyControls(t => t.touched) } _updatePristine(t = {}) { this.pristine = !this._anyControlsDirty(), this._parent && !t.onlySelf && this._parent._updatePristine(t) } _updateTouched(t = {}) { this.touched = this._anyControlsTouched(), this._parent && !t.onlySelf && this._parent._updateTouched(t) } _isBoxedValue(t) { return "object" == typeof t && null !== t && 2 === Object.keys(t).length && "value" in t && "disabled" in t } _registerOnCollectionChange(t) { this._onCollectionChange = t } _setUpdateStrategy(t) { up(t) && null != t.updateOn && (this._updateOn = t.updateOn) } _parentMarkedDirty(t) { return !t && !(!this._parent || !this._parent.dirty) && !this._parent._anyControlsDirty() } } class Vc extends dp { constructor(t = null, e, i) { super(lp(e), cp(i, e)), this._onChange = [], this._applyFormState(t), this._setUpdateStrategy(e), this._initObservables(), this.updateValueAndValidity({ onlySelf: !0, emitEvent: !!this.asyncValidator }) } setValue(t, e = {}) { this.value = this._pendingValue = t, this._onChange.length && !1 !== e.emitModelToViewChange && this._onChange.forEach(i => i(this.value, !1 !== e.emitViewToModelChange)), this.updateValueAndValidity(e) } patchValue(t, e = {}) { this.setValue(t, e) } reset(t = null, e = {}) { this._applyFormState(t), this.markAsPristine(e), this.markAsUntouched(e), this.setValue(this.value, e), this._pendingChange = !1 } _updateValue() { } _anyControls(t) { return !1 } _allControlsDisabled() { return this.disabled } registerOnChange(t) { this._onChange.push(t) } _unregisterOnChange(t) { Pc(this._onChange, t) } registerOnDisabledChange(t) { this._onDisabledChange.push(t) } _unregisterOnDisabledChange(t) { Pc(this._onDisabledChange, t) } _forEachChild(t) { } _syncPendingControls() { return !("submit" !== this.updateOn || (this._pendingDirty && this.markAsDirty(), this._pendingTouched && this.markAsTouched(), !this._pendingChange) || (this.setValue(this._pendingValue, { onlySelf: !0, emitModelToViewChange: !1 }), 0)) } _applyFormState(t) { this._isBoxedValue(t) ? (this.value = this._pendingValue = t.value, t.disabled ? this.disable({ onlySelf: !0, emitEvent: !1 }) : this.enable({ onlySelf: !0, emitEvent: !1 })) : this.value = this._pendingValue = t } } class fp extends dp { constructor(t, e, i) { super(lp(e), cp(i, e)), this.controls = t, this._initObservables(), this._setUpdateStrategy(e), this._setUpControls(), this.updateValueAndValidity({ onlySelf: !0, emitEvent: !!this.asyncValidator }) } registerControl(t, e) { return this.controls[t] ? this.controls[t] : (this.controls[t] = e, e.setParent(this), e._registerOnCollectionChange(this._onCollectionChange), e) } addControl(t, e, i = {}) { this.registerControl(t, e), this.updateValueAndValidity({ emitEvent: i.emitEvent }), this._onCollectionChange() } removeControl(t, e = {}) { this.controls[t] && this.controls[t]._registerOnCollectionChange(() => { }), delete this.controls[t], this.updateValueAndValidity({ emitEvent: e.emitEvent }), this._onCollectionChange() } setControl(t, e, i = {}) { this.controls[t] && this.controls[t]._registerOnCollectionChange(() => { }), delete this.controls[t], e && this.registerControl(t, e), this.updateValueAndValidity({ emitEvent: i.emitEvent }), this._onCollectionChange() } contains(t) { return this.controls.hasOwnProperty(t) && this.controls[t].enabled } setValue(t, e = {}) { this._checkAllValuesPresent(t), Object.keys(t).forEach(i => { this._throwIfControlMissing(i), this.controls[i].setValue(t[i], { onlySelf: !0, emitEvent: e.emitEvent }) }), this.updateValueAndValidity(e) } patchValue(t, e = {}) { null != t && (Object.keys(t).forEach(i => { this.controls[i] && this.controls[i].patchValue(t[i], { onlySelf: !0, emitEvent: e.emitEvent }) }), this.updateValueAndValidity(e)) } reset(t = {}, e = {}) { this._forEachChild((i, r) => { i.reset(t[r], { onlySelf: !0, emitEvent: e.emitEvent }) }), this._updatePristine(e), this._updateTouched(e), this.updateValueAndValidity(e) } getRawValue() { return this._reduceChildren({}, (t, e, i) => (t[i] = e instanceof Vc ? e.value : e.getRawValue(), t)) } _syncPendingControls() { let t = this._reduceChildren(!1, (e, i) => !!i._syncPendingControls() || e); return t && this.updateValueAndValidity({ onlySelf: !0 }), t } _throwIfControlMissing(t) { if (!Object.keys(this.controls).length) throw new Error("\n        There are no form controls registered with this group yet. If you're using ngModel,\n        you may want to check next tick (e.g. use setTimeout).\n      "); if (!this.controls[t]) throw new Error(`Cannot find form control with name: ${t}.`) } _forEachChild(t) { Object.keys(this.controls).forEach(e => { const i = this.controls[e]; i && t(i, e) }) } _setUpControls() { this._forEachChild(t => { t.setParent(this), t._registerOnCollectionChange(this._onCollectionChange) }) } _updateValue() { this.value = this._reduceValue() } _anyControls(t) { for (const e of Object.keys(this.controls)) { const i = this.controls[e]; if (this.contains(e) && t(i)) return !0 } return !1 } _reduceValue() { return this._reduceChildren({}, (t, e, i) => ((e.enabled || this.disabled) && (t[i] = e.value), t)) } _reduceChildren(t, e) { let i = t; return this._forEachChild((r, s) => { i = e(i, r, s) }), i } _allControlsDisabled() { for (const t of Object.keys(this.controls)) if (this.controls[t].enabled) return !1; return Object.keys(this.controls).length > 0 || this.disabled } _checkAllValuesPresent(t) { this._forEachChild((e, i) => { if (void 0 === t[i]) throw new Error(`Must supply a value for form control with name: '${i}'.`) }) } } class JB extends dp { constructor(t, e, i) { super(lp(e), cp(i, e)), this.controls = t, this._initObservables(), this._setUpdateStrategy(e), this._setUpControls(), this.updateValueAndValidity({ onlySelf: !0, emitEvent: !!this.asyncValidator }) } at(t) { return this.controls[t] } push(t, e = {}) { this.controls.push(t), this._registerControl(t), this.updateValueAndValidity({ emitEvent: e.emitEvent }), this._onCollectionChange() } insert(t, e, i = {}) { this.controls.splice(t, 0, e), this._registerControl(e), this.updateValueAndValidity({ emitEvent: i.emitEvent }) } removeAt(t, e = {}) { this.controls[t] && this.controls[t]._registerOnCollectionChange(() => { }), this.controls.splice(t, 1), this.updateValueAndValidity({ emitEvent: e.emitEvent }) } setControl(t, e, i = {}) { this.controls[t] && this.controls[t]._registerOnCollectionChange(() => { }), this.controls.splice(t, 1), e && (this.controls.splice(t, 0, e), this._registerControl(e)), this.updateValueAndValidity({ emitEvent: i.emitEvent }), this._onCollectionChange() } get length() { return this.controls.length } setValue(t, e = {}) { this._checkAllValuesPresent(t), t.forEach((i, r) => { this._throwIfControlMissing(r), this.at(r).setValue(i, { onlySelf: !0, emitEvent: e.emitEvent }) }), this.updateValueAndValidity(e) } patchValue(t, e = {}) { null != t && (t.forEach((i, r) => { this.at(r) && this.at(r).patchValue(i, { onlySelf: !0, emitEvent: e.emitEvent }) }), this.updateValueAndValidity(e)) } reset(t = [], e = {}) { this._forEachChild((i, r) => { i.reset(t[r], { onlySelf: !0, emitEvent: e.emitEvent }) }), this._updatePristine(e), this._updateTouched(e), this.updateValueAndValidity(e) } getRawValue() { return this.controls.map(t => t instanceof Vc ? t.value : t.getRawValue()) } clear(t = {}) { this.controls.length < 1 || (this._forEachChild(e => e._registerOnCollectionChange(() => { })), this.controls.splice(0), this.updateValueAndValidity({ emitEvent: t.emitEvent })) } _syncPendingControls() { let t = this.controls.reduce((e, i) => !!i._syncPendingControls() || e, !1); return t && this.updateValueAndValidity({ onlySelf: !0 }), t } _throwIfControlMissing(t) { if (!this.controls.length) throw new Error("\n        There are no form controls registered with this array yet. If you're using ngModel,\n        you may want to check next tick (e.g. use setTimeout).\n      "); if (!this.at(t)) throw new Error(`Cannot find form control at index ${t}`) } _forEachChild(t) { this.controls.forEach((e, i) => { t(e, i) }) } _updateValue() { this.value = this.controls.filter(t => t.enabled || this.disabled).map(t => t.value) } _anyControls(t) { return this.controls.some(e => e.enabled && t(e)) } _setUpControls() { this._forEachChild(t => this._registerControl(t)) } _checkAllValuesPresent(t) { this._forEachChild((e, i) => { if (void 0 === t[i]) throw new Error(`Must supply a value for form control at index: ${i}.`) }) } _allControlsDisabled() { for (const t of this.controls) if (t.enabled) return !1; return this.controls.length > 0 || this.disabled } _registerControl(t) { t.setParent(this), t._registerOnCollectionChange(this._onCollectionChange) } } const ZB = { provide: kt, useExisting: xe(() => wa) }, Ca = (() => Promise.resolve(null))(); let wa = (() => { class n extends kt { constructor(e, i) { super(), this.submitted = !1, this._directives = [], this.ngSubmit = new ge, this.form = new fp({}, np(e), ip(i)) } ngAfterViewInit() { this._setUpdateStrategy() } get formDirective() { return this } get control() { return this.form } get path() { return [] } get controls() { return this.form.controls } addControl(e) { Ca.then(() => { const i = this._findContainer(e.path); e.control = i.registerControl(e.name, e.control), ya(e.control, e), e.control.updateValueAndValidity({ emitEvent: !1 }), this._directives.push(e) }) } getControl(e) { return this.form.get(e.path) } removeControl(e) { Ca.then(() => { const i = this._findContainer(e.path); i && i.removeControl(e.name), Pc(this._directives, e) }) } addFormGroup(e) { Ca.then(() => { const i = this._findContainer(e.path), r = new fp({}); kE(r, e), i.registerControl(e.name, r), r.updateValueAndValidity({ emitEvent: !1 }) }) } removeFormGroup(e) { Ca.then(() => { const i = this._findContainer(e.path); i && i.removeControl(e.name) }) } getFormGroup(e) { return this.form.get(e.path) } updateModel(e, i) { Ca.then(() => { this.form.get(e.path).setValue(i) }) } setValue(e) { this.control.setValue(e) } onSubmit(e) { return this.submitted = !0, OE(this.form, this._directives), this.ngSubmit.emit(e), !1 } onReset() { this.resetForm() } resetForm(e) { this.form.reset(e), this.submitted = !1 } _setUpdateStrategy() { this.options && null != this.options.updateOn && (this.form._updateOn = this.options.updateOn) } _findContainer(e) { return e.pop(), e.length ? this.form.get(e) : this.form } } return n.\u0275fac = function (e) { return new (e || n)(g(Ct, 10), g($i, 10)) }, n.\u0275dir = C({ type: n, selectors: [["form", 3, "ngNoForm", "", 3, "formGroup", ""], ["ng-form"], ["", "ngForm", ""]], hostBindings: function (e, i) { 1 & e && ye("submit", function (s) { return i.onSubmit(s) })("reset", function () { return i.onReset() }) }, inputs: { options: ["ngFormOptions", "options"] }, outputs: { ngSubmit: "ngSubmit" }, exportAs: ["ngForm"], features: [ae([ZB]), D] }), n })(); const e2 = { provide: yi, useExisting: xe(() => hp) }, BE = (() => Promise.resolve(null))(); let hp = (() => { class n extends yi { constructor(e, i, r, s) { super(), this.control = new Vc, this._registered = !1, this.update = new ge, this._parent = e, this._setValidators(i), this._setAsyncValidators(r), this.valueAccessor = function (n, t) { if (!t) return null; let e, i, r; return Array.isArray(t), t.forEach(s => { s.constructor === Ic ? e = s : function (n) { return Object.getPrototypeOf(n.constructor) === Mr }(s) ? i = s : r = s }), r || i || e || null }(0, s) } ngOnChanges(e) { this._checkForErrors(), this._registered || this._setUpControl(), "isDisabled" in e && this._updateDisabled(e), function (n, t) { if (!n.hasOwnProperty("model")) return !1; const e = n.model; return !!e.isFirstChange() || !Object.is(t, e.currentValue) }(e, this.viewModel) && (this._updateValue(this.model), this.viewModel = this.model) } ngOnDestroy() { this.formDirective && this.formDirective.removeControl(this) } get path() { return this._parent ? function (n, t) { return [...t.path, n] }(this.name, this._parent) : [this.name] } get formDirective() { return this._parent ? this._parent.formDirective : null } viewToModelUpdate(e) { this.viewModel = e, this.update.emit(e) } _setUpControl() { this._setUpdateStrategy(), this._isStandalone() ? this._setUpStandalone() : this.formDirective.addControl(this), this._registered = !0 } _setUpdateStrategy() { this.options && null != this.options.updateOn && (this.control._updateOn = this.options.updateOn) } _isStandalone() { return !this._parent || !(!this.options || !this.options.standalone) } _setUpStandalone() { ya(this.control, this), this.control.updateValueAndValidity({ emitEvent: !1 }) } _checkForErrors() { this._isStandalone() || this._checkParentType(), this._checkName() } _checkParentType() { } _checkName() { this.options && this.options.name && (this.name = this.options.name), this._isStandalone() } _updateValue(e) { BE.then(() => { this.control.setValue(e, { emitViewToModelChange: !1 }) }) } _updateDisabled(e) { const i = e.isDisabled.currentValue, r = "" === i || i && "false" !== i; BE.then(() => { r && !this.control.disabled ? this.control.disable() : !r && this.control.disabled && this.control.enable() }) } } return n.\u0275fac = function (e) { return new (e || n)(g(kt, 9), g(Ct, 10), g($i, 10), g(ei, 10)) }, n.\u0275dir = C({ type: n, selectors: [["", "ngModel", "", 3, "formControlName", "", 3, "formControl", ""]], inputs: { name: "name", isDisabled: ["disabled", "isDisabled"], model: ["ngModel", "model"], options: ["ngModelOptions", "options"] }, outputs: { update: "ngModelChange" }, exportAs: ["ngModel"], features: [ae([e2]), D, nt] }), n })(), HE = (() => { class n { } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275dir = C({ type: n, selectors: [["form", 3, "ngNoForm", "", 3, "ngNativeValidate", ""]], hostAttrs: ["novalidate", ""] }), n })(); const t2 = { provide: ei, useExisting: xe(() => pp), multi: !0 }; let pp = (() => { class n extends Mr { writeValue(e) { this.setProperty("value", null == e ? "" : e) } registerOnChange(e) { this.onChange = i => { e("" == i ? null : parseFloat(i)) } } } return n.\u0275fac = function () { let t; return function (i) { return (t || (t = P(n)))(i || n) } }(), n.\u0275dir = C({ type: n, selectors: [["input", "type", "number", "formControlName", ""], ["input", "type", "number", "formControl", ""], ["input", "type", "number", "ngModel", ""]], hostBindings: function (e, i) { 1 & e && ye("input", function (s) { return i.onChange(s.target.value) })("blur", function () { return i.onTouched() }) }, features: [ae([t2]), D] }), n })(), jE = (() => { class n { } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275mod = ee({ type: n }), n.\u0275inj = X({}), n })(); const a2 = { provide: kt, useExisting: xe(() => Bc) }; let Bc = (() => { class n extends kt { constructor(e, i) { super(), this.validators = e, this.asyncValidators = i, this.submitted = !1, this._onCollectionChange = () => this._updateDomValue(), this.directives = [], this.form = null, this.ngSubmit = new ge, this._setValidators(e), this._setAsyncValidators(i) } ngOnChanges(e) { this._checkFormPresent(), e.hasOwnProperty("form") && (this._updateValidators(), this._updateDomValue(), this._updateRegistrations(), this._oldForm = this.form) } ngOnDestroy() { this.form && (Nc(this.form, this), this.form._onCollectionChange === this._onCollectionChange && this.form._registerOnCollectionChange(() => { })) } get formDirective() { return this } get control() { return this.form } get path() { return [] } addControl(e) { const i = this.form.get(e.path); return ya(i, e), i.updateValueAndValidity({ emitEvent: !1 }), this.directives.push(e), i } getControl(e) { return this.form.get(e.path) } removeControl(e) { kc(e.control || null, e, !1), Pc(this.directives, e) } addFormGroup(e) { this._setUpFormContainer(e) } removeFormGroup(e) { this._cleanUpFormContainer(e) } getFormGroup(e) { return this.form.get(e.path) } addFormArray(e) { this._setUpFormContainer(e) } removeFormArray(e) { this._cleanUpFormContainer(e) } getFormArray(e) { return this.form.get(e.path) } updateModel(e, i) { this.form.get(e.path).setValue(i) } onSubmit(e) { return this.submitted = !0, OE(this.form, this.directives), this.ngSubmit.emit(e), !1 } onReset() { this.resetForm() } resetForm(e) { this.form.reset(e), this.submitted = !1 } _updateDomValue() { this.directives.forEach(e => { const i = e.control, r = this.form.get(e.path); i !== r && (kc(i || null, e), r instanceof Vc && (ya(r, e), e.control = r)) }), this.form._updateTreeValidity({ emitEvent: !1 }) } _setUpFormContainer(e) { const i = this.form.get(e.path); kE(i, e), i.updateValueAndValidity({ emitEvent: !1 }) } _cleanUpFormContainer(e) { if (this.form) { const i = this.form.get(e.path); i && function (n, t) { return Nc(n, t) }(i, e) && i.updateValueAndValidity({ emitEvent: !1 }) } } _updateRegistrations() { this.form._registerOnCollectionChange(this._onCollectionChange), this._oldForm && this._oldForm._registerOnCollectionChange(() => { }) } _updateValidators() { sp(this.form, this), this._oldForm && Nc(this._oldForm, this) } _checkFormPresent() { } } return n.\u0275fac = function (e) { return new (e || n)(g(Ct, 10), g($i, 10)) }, n.\u0275dir = C({ type: n, selectors: [["", "formGroup", ""]], hostBindings: function (e, i) { 1 & e && ye("submit", function (s) { return i.onSubmit(s) })("reset", function () { return i.onReset() }) }, inputs: { form: ["formGroup", "form"] }, outputs: { ngSubmit: "ngSubmit" }, exportAs: ["ngForm"], features: [ae([a2]), D, nt] }), n })(), rD = (() => { class n { } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275mod = ee({ type: n }), n.\u0275inj = X({ imports: [[jE]] }), n })(), x2 = (() => { class n { } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275mod = ee({ type: n }), n.\u0275inj = X({ imports: [rD] }), n })(); class M2 { constructor(t) { this.type = t } set(t) { this.type = t } get() { return this.type } } function Te(n) { return null != n && "false" != `${n}` } function Hc(n) { return Array.isArray(n) ? n : [n] } function Xe(n) { return null == n ? "" : "string" == typeof n ? n : `${n}px` } function vi(n) { return n instanceof O ? n.nativeElement : n } function pn(...n) { let t = n[n.length - 1]; return Gr(t) ? (n.pop(), ku(n, t)) : Nu(n) } function Ea(n, t, e, i) { return Hn(e) && (i = e, e = void 0), i ? Ea(n, t, e).pipe(Dt(r => jr(r) ? i(...r) : i(r))) : new me(r => { sD(n, t, function (o) { r.next(arguments.length > 1 ? Array.prototype.slice.call(arguments) : o) }, r, e) }) } function sD(n, t, e, i, r) { let s; if (function (n) { return n && "function" == typeof n.addEventListener && "function" == typeof n.removeEventListener }(n)) { const o = n; n.addEventListener(t, e, r), s = () => o.removeEventListener(t, e, r) } else if (function (n) { return n && "function" == typeof n.on && "function" == typeof n.off }(n)) { const o = n; n.on(t, e), s = () => o.off(t, e) } else if (function (n) { return n && "function" == typeof n.addListener && "function" == typeof n.removeListener }(n)) { const o = n; n.addListener(t, e), s = () => o.removeListener(t, e) } else { if (!n || !n.length) throw new TypeError("Invalid event target"); for (let o = 0, a = n.length; o < a; o++)sD(n[o], t, e, i, r) } i.add(s) } class F2 extends he { constructor(t, e) { super() } schedule(t, e = 0) { return this } } class jc extends F2 { constructor(t, e) { super(t, e), this.scheduler = t, this.work = e, this.pending = !1 } schedule(t, e = 0) { if (this.closed) return this; this.state = t; const i = this.id, r = this.scheduler; return null != i && (this.id = this.recycleAsyncId(r, i, e)), this.pending = !0, this.delay = e, this.id = this.id || this.requestAsyncId(r, this.id, e), this } requestAsyncId(t, e, i = 0) { return setInterval(t.flush.bind(t, this), i) } recycleAsyncId(t, e, i = 0) { if (null !== i && this.delay === i && !1 === this.pending) return e; clearInterval(e) } execute(t, e) { if (this.closed) return new Error("executing a cancelled action"); this.pending = !1; const i = this._execute(t, e); if (i) return i; !1 === this.pending && null != this.id && (this.id = this.recycleAsyncId(this.scheduler, this.id, null)) } _execute(t, e) { let r, i = !1; try { this.work(t) } catch (s) { i = !0, r = !!s && s || new Error(s) } if (i) return this.unsubscribe(), r } _unsubscribe() { const t = this.id, e = this.scheduler, i = e.actions, r = i.indexOf(this); this.work = null, this.state = null, this.pending = !1, this.scheduler = null, -1 !== r && i.splice(r, 1), null != t && (this.id = this.recycleAsyncId(e, t, null)), this.delay = null } } let oD = (() => { class n { constructor(e, i = n.now) { this.SchedulerAction = e, this.now = i } schedule(e, i = 0, r) { return new this.SchedulerAction(this, e).schedule(r, i) } } return n.now = () => Date.now(), n })(); class Ln extends oD { constructor(t, e = oD.now) { super(t, () => Ln.delegate && Ln.delegate !== this ? Ln.delegate.now() : e()), this.actions = [], this.active = !1, this.scheduled = void 0 } schedule(t, e = 0, i) { return Ln.delegate && Ln.delegate !== this ? Ln.delegate.schedule(t, e, i) : super.schedule(t, e, i) } flush(t) { const { actions: e } = this; if (this.active) return void e.push(t); let i; this.active = !0; do { if (i = t.execute(t.state, t.delay)) break } while (t = e.shift()); if (this.active = !1, i) { for (; t = e.shift();)t.unsubscribe(); throw i } } } new class extends Ln { flush(t) { this.active = !0, this.scheduled = void 0; const { actions: e } = this; let i, r = -1, s = e.length; t = t || e.shift(); do { if (i = t.execute(t.state, t.delay)) break } while (++r < s && (t = e.shift())); if (this.active = !1, i) { for (; ++r < s && (t = e.shift());)t.unsubscribe(); throw i } } }(class extends jc { constructor(t, e) { super(t, e), this.scheduler = t, this.work = e } requestAsyncId(t, e, i = 0) { return null !== i && i > 0 ? super.requestAsyncId(t, e, i) : (t.actions.push(this), t.scheduled || (t.scheduled = requestAnimationFrame(() => t.flush(null)))) } recycleAsyncId(t, e, i = 0) { if (null !== i && i > 0 || null === i && this.delay > 0) return super.recycleAsyncId(t, e, i); 0 === t.actions.length && (cancelAnimationFrame(e), t.scheduled = void 0) } }); let N2 = 1; const P2 = Promise.resolve(), Gc = {}; function aD(n) { return n in Gc && (delete Gc[n], !0) } const lD = { setImmediate(n) { const t = N2++; return Gc[t] = !0, P2.then(() => aD(t) && n()), t }, clearImmediate(n) { aD(n) } }; new class extends Ln { flush(t) { this.active = !0, this.scheduled = void 0; const { actions: e } = this; let i, r = -1, s = e.length; t = t || e.shift(); do { if (i = t.execute(t.state, t.delay)) break } while (++r < s && (t = e.shift())); if (this.active = !1, i) { for (; ++r < s && (t = e.shift());)t.unsubscribe(); throw i } } }(class extends jc { constructor(t, e) { super(t, e), this.scheduler = t, this.work = e } requestAsyncId(t, e, i = 0) { return null !== i && i > 0 ? super.requestAsyncId(t, e, i) : (t.actions.push(this), t.scheduled || (t.scheduled = lD.setImmediate(t.flush.bind(t, null)))) } recycleAsyncId(t, e, i = 0) { if (null !== i && i > 0 || null === i && this.delay > 0) return super.recycleAsyncId(t, e, i); 0 === t.actions.length && (lD.clearImmediate(e), t.scheduled = void 0) } }); class H2 { constructor(t, e) { this.compare = t, this.keySelector = e } call(t, e) { return e.subscribe(new j2(t, this.compare, this.keySelector)) } } class j2 extends Ie { constructor(t, e, i) { super(t), this.keySelector = i, this.hasKey = !1, "function" == typeof e && (this.compare = e) } compare(t, e) { return t === e } _next(t) { let e; try { const { keySelector: r } = this; e = r ? r(t) : t } catch (r) { return this.destination.error(r) } let i = !1; if (this.hasKey) try { const { compare: r } = this; i = r(this.key, e) } catch (r) { return this.destination.error(r) } else this.hasKey = !0; i || (this.key = e, this.destination.next(t)) } } const Cp = new Ln(jc); class $2 { constructor(t) { this.durationSelector = t } call(t, e) { return e.subscribe(new U2(t, this.durationSelector)) } } class U2 extends lo { constructor(t, e) { super(t), this.durationSelector = e, this.hasValue = !1 } _next(t) { if (this.value = t, this.hasValue = !0, !this.throttled) { let e; try { const { durationSelector: r } = this; e = r(t) } catch (r) { return this.destination.error(r) } const i = co(e, new ao(this)); !i || i.closed ? this.clearThrottle() : this.add(this.throttled = i) } } clearThrottle() { const { value: t, hasValue: e, throttled: i } = this; i && (this.remove(i), this.throttled = void 0, i.unsubscribe()), e && (this.value = void 0, this.hasValue = !1, this.destination.next(t)) } notifyNext() { this.clearThrottle() } notifyComplete() { this.clearThrottle() } } function dD(n) { return !jr(n) && n - parseFloat(n) + 1 >= 0 } function W2(n) { const { index: t, period: e, subscriber: i } = n; if (i.next(t), !i.closed) { if (-1 === e) return i.complete(); n.index = t + 1, this.schedule(n, e) } } function $c(n, t = Cp) { return function (n) { return function (e) { return e.lift(new $2(n)) } }(() => function (n = 0, t, e) { let i = -1; return dD(t) ? i = Number(t) < 1 ? 1 : Number(t) : Gr(t) && (e = t), Gr(e) || (e = Cp), new me(r => { const s = dD(n) ? n : +n - e.now(); return e.schedule(W2, s, { index: 0, period: i, subscriber: r }) }) }(n, t)) } function Da(n, t) { return function (i) { return i.lift(new q2(n, t)) } } class q2 { constructor(t, e) { this.predicate = t, this.thisArg = e } call(t, e) { return e.subscribe(new K2(t, this.predicate, this.thisArg)) } } class K2 extends Ie { constructor(t, e, i) { super(t), this.predicate = e, this.thisArg = i, this.count = 0 } _next(t) { let e; try { e = this.predicate.call(this.thisArg, t, this.count++) } catch (i) { return void this.destination.error(i) } e && this.destination.next(t) } } function pt(n) { return t => t.lift(new Q2(n)) } class Q2 { constructor(t) { this.notifier = t } call(t, e) { const i = new Y2(t), r = co(this.notifier, new ao(i)); return r && !i.seenValue ? (i.add(r), e.subscribe(i)) : i } } class Y2 extends lo { constructor(t) { super(t), this.seenValue = !1 } notifyNext() { this.seenValue = !0, this.complete() } notifyComplete() { } } function wp(...n) { return zg(1)(pn(...n)) } function Us(...n) { const t = n[n.length - 1]; return Gr(t) ? (n.pop(), e => wp(n, e, t)) : e => wp(n, e) } new class extends Ln { }(class extends jc { constructor(t, e) { super(t, e), this.scheduler = t, this.work = e } schedule(t, e = 0) { return e > 0 ? super.schedule(t, e) : (this.delay = e, this.state = t, this.scheduler.flush(this), this) } execute(t, e) { return e > 0 || this.closed ? super.execute(t, e) : this._execute(t, e) } requestAsyncId(t, e, i = 0) { return null !== i && i > 0 || null === i && this.delay > 0 ? super.requestAsyncId(t, e, i) : t.flush(this) } }); const hD = new me(n => n.complete()); function pD(n) { return n ? function (n) { return new me(t => n.schedule(() => t.complete())) }(n) : hD } function gD(n, t) { return new me(t ? e => t.schedule(aH, 0, { error: n, subscriber: e }) : e => e.error(n)) } function aH({ error: n, subscriber: t }) { t.error(n) } class gn { constructor(t, e, i) { this.kind = t, this.value = e, this.error = i, this.hasValue = "N" === t } observe(t) { switch (this.kind) { case "N": return t.next && t.next(this.value); case "E": return t.error && t.error(this.error); case "C": return t.complete && t.complete() } } do(t, e, i) { switch (this.kind) { case "N": return t && t(this.value); case "E": return e && e(this.error); case "C": return i && i() } } accept(t, e, i) { return t && "function" == typeof t.next ? this.observe(t) : this.do(t, e, i) } toObservable() { switch (this.kind) { case "N": return pn(this.value); case "E": return gD(this.error); case "C": return pD() }throw new Error("unexpected notification kind value") } static createNext(t) { return void 0 !== t ? new gn("N", t) : gn.undefinedValueNotification } static createError(t) { return new gn("E", void 0, t) } static createComplete() { return gn.completeNotification } } let Ep; gn.completeNotification = new gn("C"), gn.undefinedValueNotification = new gn("N", void 0); try { Ep = "undefined" != typeof Intl && Intl.v8BreakIterator } catch (n) { Ep = !1 } let zs, Ce = (() => { class n { constructor(e) { this._platformId = e, this.isBrowser = this._platformId ? Dr(this._platformId) : "object" == typeof document && !!document, this.EDGE = this.isBrowser && /(edge)/i.test(navigator.userAgent), this.TRIDENT = this.isBrowser && /(msie|trident)/i.test(navigator.userAgent), this.BLINK = this.isBrowser && !(!window.chrome && !Ep) && "undefined" != typeof CSS && !this.EDGE && !this.TRIDENT, this.WEBKIT = this.isBrowser && /AppleWebKit/i.test(navigator.userAgent) && !this.BLINK && !this.EDGE && !this.TRIDENT, this.IOS = this.isBrowser && /iPad|iPhone|iPod/.test(navigator.userAgent) && !("MSStream" in window), this.FIREFOX = this.isBrowser && /(firefox|minefield)/i.test(navigator.userAgent), this.ANDROID = this.isBrowser && /android/i.test(navigator.userAgent) && !this.TRIDENT, this.SAFARI = this.isBrowser && /safari/i.test(navigator.userAgent) && this.WEBKIT } } return n.\u0275fac = function (e) { return new (e || n)(m(bt)) }, n.\u0275prov = E({ factory: function () { return new n(m(bt)) }, token: n, providedIn: "root" }), n })(), xa = (() => { class n { } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275mod = ee({ type: n }), n.\u0275inj = X({}), n })(); const mD = ["color", "button", "checkbox", "date", "datetime-local", "email", "file", "hidden", "image", "month", "number", "password", "radio", "range", "reset", "search", "submit", "tel", "text", "time", "url", "week"]; function _D() { if (zs) return zs; if ("object" != typeof document || !document) return zs = new Set(mD), zs; let n = document.createElement("input"); return zs = new Set(mD.filter(t => (n.setAttribute("type", t), n.type === t))), zs } let Ma, Sr, Dp; function zc(n) { return function () { if (null == Ma && "undefined" != typeof window) try { window.addEventListener("test", null, Object.defineProperty({}, "passive", { get: () => Ma = !0 })) } finally { Ma = Ma || !1 } return Ma }() ? n : !!n.capture } function yD() { if (null == Sr) { if ("object" != typeof document || !document || "function" != typeof Element || !Element) return Sr = !1, Sr; if ("scrollBehavior" in document.documentElement.style) Sr = !0; else { const n = Element.prototype.scrollTo; Sr = !!n && !/\{\s*\[native code\]\s*\}/.test(n.toString()) } } return Sr } function Ws(n) { return n.composedPath ? n.composedPath()[0] : n.target } const vD = new k("cdk-dir-doc", { providedIn: "root", factory: function () { return Ao(N) } }); let zi = (() => { class n { constructor(e) { if (this.value = "ltr", this.change = new ge, e) { const r = e.documentElement ? e.documentElement.dir : null, s = (e.body ? e.body.dir : null) || r; this.value = "ltr" === s || "rtl" === s ? s : "ltr" } } ngOnDestroy() { this.change.complete() } } return n.\u0275fac = function (e) { return new (e || n)(m(vD, 8)) }, n.\u0275prov = E({ factory: function () { return new n(m(vD, 8)) }, token: n, providedIn: "root" }), n })(), qs = (() => { class n { } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275mod = ee({ type: n }), n.\u0275inj = X({}), n })(), qc = (() => { class n { constructor(e, i, r) { this._ngZone = e, this._platform = i, this._scrolled = new ie, this._globalSubscription = null, this._scrolledCount = 0, this.scrollContainers = new Map, this._document = r } register(e) { this.scrollContainers.has(e) || this.scrollContainers.set(e, e.elementScrolled().subscribe(() => this._scrolled.next(e))) } deregister(e) { const i = this.scrollContainers.get(e); i && (i.unsubscribe(), this.scrollContainers.delete(e)) } scrolled(e = 20) { return this._platform.isBrowser ? new me(i => { this._globalSubscription || this._addGlobalListener(); const r = e > 0 ? this._scrolled.pipe($c(e)).subscribe(i) : this._scrolled.subscribe(i); return this._scrolledCount++, () => { r.unsubscribe(), this._scrolledCount--, this._scrolledCount || this._removeGlobalListener() } }) : pn() } ngOnDestroy() { this._removeGlobalListener(), this.scrollContainers.forEach((e, i) => this.deregister(i)), this._scrolled.complete() } ancestorScrolled(e, i) { const r = this.getAncestorScrollContainers(e); return this.scrolled(i).pipe(Da(s => !s || r.indexOf(s) > -1)) } getAncestorScrollContainers(e) { const i = []; return this.scrollContainers.forEach((r, s) => { this._scrollableContainsElement(s, e) && i.push(s) }), i } _getWindow() { return this._document.defaultView || window } _scrollableContainsElement(e, i) { let r = vi(i), s = e.getElementRef().nativeElement; do { if (r == s) return !0 } while (r = r.parentElement); return !1 } _addGlobalListener() { this._globalSubscription = this._ngZone.runOutsideAngular(() => Ea(this._getWindow().document, "scroll").subscribe(() => this._scrolled.next())) } _removeGlobalListener() { this._globalSubscription && (this._globalSubscription.unsubscribe(), this._globalSubscription = null) } } return n.\u0275fac = function (e) { return new (e || n)(m(H), m(Ce), m(N, 8)) }, n.\u0275prov = E({ factory: function () { return new n(m(H), m(Ce), m(N, 8)) }, token: n, providedIn: "root" }), n })(), Sa = (() => { class n { constructor(e, i, r) { this._platform = e, this._change = new ie, this._changeListener = s => { this._change.next(s) }, this._document = r, i.runOutsideAngular(() => { if (e.isBrowser) { const s = this._getWindow(); s.addEventListener("resize", this._changeListener), s.addEventListener("orientationchange", this._changeListener) } this.change().subscribe(() => this._viewportSize = null) }) } ngOnDestroy() { if (this._platform.isBrowser) { const e = this._getWindow(); e.removeEventListener("resize", this._changeListener), e.removeEventListener("orientationchange", this._changeListener) } this._change.complete() } getViewportSize() { this._viewportSize || this._updateViewportSize(); const e = { width: this._viewportSize.width, height: this._viewportSize.height }; return this._platform.isBrowser || (this._viewportSize = null), e } getViewportRect() { const e = this.getViewportScrollPosition(), { width: i, height: r } = this.getViewportSize(); return { top: e.top, left: e.left, bottom: e.top + r, right: e.left + i, height: r, width: i } } getViewportScrollPosition() { if (!this._platform.isBrowser) return { top: 0, left: 0 }; const e = this._document, i = this._getWindow(), r = e.documentElement, s = r.getBoundingClientRect(); return { top: -s.top || e.body.scrollTop || i.scrollY || r.scrollTop || 0, left: -s.left || e.body.scrollLeft || i.scrollX || r.scrollLeft || 0 } } change(e = 20) { return e > 0 ? this._change.pipe($c(e)) : this._change } _getWindow() { return this._document.defaultView || window } _updateViewportSize() { const e = this._getWindow(); this._viewportSize = this._platform.isBrowser ? { width: e.innerWidth, height: e.innerHeight } : { width: 0, height: 0 } } } return n.\u0275fac = function (e) { return new (e || n)(m(Ce), m(H), m(N, 8)) }, n.\u0275prov = E({ factory: function () { return new n(m(Ce), m(H), m(N, 8)) }, token: n, providedIn: "root" }), n })(), DD = (() => { class n { } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275mod = ee({ type: n }), n.\u0275inj = X({}), n })(), xD = (() => { class n { } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275mod = ee({ type: n }), n.\u0275inj = X({ imports: [[qs, xa, DD], qs, DD] }), n })(); class xp { attach(t) { return this._attachedHost = t, t.attach(this) } detach() { let t = this._attachedHost; null != t && (this._attachedHost = null, t.detach()) } get isAttached() { return null != this._attachedHost } setAttachedHost(t) { this._attachedHost = t } } class Mp extends xp { constructor(t, e, i, r) { super(), this.component = t, this.viewContainerRef = e, this.injector = i, this.componentFactoryResolver = r } } class Kc extends xp { constructor(t, e, i) { super(), this.templateRef = t, this.viewContainerRef = e, this.context = i } get origin() { return this.templateRef.elementRef } attach(t, e = this.context) { return this.context = e, super.attach(t) } detach() { return this.context = void 0, super.detach() } } class RH extends xp { constructor(t) { super(), this.element = t instanceof O ? t.nativeElement : t } } class Ap { constructor() { this._isDisposed = !1, this.attachDomPortal = null } hasAttached() { return !!this._attachedPortal } attach(t) { return t instanceof Mp ? (this._attachedPortal = t, this.attachComponentPortal(t)) : t instanceof Kc ? (this._attachedPortal = t, this.attachTemplatePortal(t)) : this.attachDomPortal && t instanceof RH ? (this._attachedPortal = t, this.attachDomPortal(t)) : void 0 } detach() { this._attachedPortal && (this._attachedPortal.setAttachedHost(null), this._attachedPortal = null), this._invokeDisposeFn() } dispose() { this.hasAttached() && this.detach(), this._invokeDisposeFn(), this._isDisposed = !0 } setDisposeFn(t) { this._disposeFn = t } _invokeDisposeFn() { this._disposeFn && (this._disposeFn(), this._disposeFn = null) } } class kH extends Ap { constructor(t, e, i, r, s) { super(), this.outletElement = t, this._componentFactoryResolver = e, this._appRef = i, this._defaultInjector = r, this.attachDomPortal = o => { const a = o.element, l = this._document.createComment("dom-portal"); a.parentNode.insertBefore(l, a), this.outletElement.appendChild(a), this._attachedPortal = o, super.setDisposeFn(() => { l.parentNode && l.parentNode.replaceChild(a, l) }) }, this._document = s } attachComponentPortal(t) { const i = (t.componentFactoryResolver || this._componentFactoryResolver).resolveComponentFactory(t.component); let r; return t.viewContainerRef ? (r = t.viewContainerRef.createComponent(i, t.viewContainerRef.length, t.injector || t.viewContainerRef.injector), this.setDisposeFn(() => r.destroy())) : (r = i.create(t.injector || this._defaultInjector), this._appRef.attachView(r.hostView), this.setDisposeFn(() => { this._appRef.detachView(r.hostView), r.destroy() })), this.outletElement.appendChild(this._getComponentRootNode(r)), this._attachedPortal = t, r } attachTemplatePortal(t) { let e = t.viewContainerRef, i = e.createEmbeddedView(t.templateRef, t.context); return i.rootNodes.forEach(r => this.outletElement.appendChild(r)), i.detectChanges(), this.setDisposeFn(() => { let r = e.indexOf(i); -1 !== r && e.remove(r) }), this._attachedPortal = t, i } dispose() { super.dispose(), null != this.outletElement.parentNode && this.outletElement.parentNode.removeChild(this.outletElement) } _getComponentRootNode(t) { return t.hostView.rootNodes[0] } } let Qc = (() => { class n extends Ap { constructor(e, i, r) { super(), this._componentFactoryResolver = e, this._viewContainerRef = i, this._isInitialized = !1, this.attached = new ge, this.attachDomPortal = s => { const o = s.element, a = this._document.createComment("dom-portal"); s.setAttachedHost(this), o.parentNode.insertBefore(a, o), this._getRootNode().appendChild(o), this._attachedPortal = s, super.setDisposeFn(() => { a.parentNode && a.parentNode.replaceChild(o, a) }) }, this._document = r } get portal() { return this._attachedPortal } set portal(e) { this.hasAttached() && !e && !this._isInitialized || (this.hasAttached() && super.detach(), e && super.attach(e), this._attachedPortal = e) } get attachedRef() { return this._attachedRef } ngOnInit() { this._isInitialized = !0 } ngOnDestroy() { super.dispose(), this._attachedPortal = null, this._attachedRef = null } attachComponentPortal(e) { e.setAttachedHost(this); const i = null != e.viewContainerRef ? e.viewContainerRef : this._viewContainerRef, s = (e.componentFactoryResolver || this._componentFactoryResolver).resolveComponentFactory(e.component), o = i.createComponent(s, i.length, e.injector || i.injector); return i !== this._viewContainerRef && this._getRootNode().appendChild(o.hostView.rootNodes[0]), super.setDisposeFn(() => o.destroy()), this._attachedPortal = e, this._attachedRef = o, this.attached.emit(o), o } attachTemplatePortal(e) { e.setAttachedHost(this); const i = this._viewContainerRef.createEmbeddedView(e.templateRef, e.context); return super.setDisposeFn(() => this._viewContainerRef.clear()), this._attachedPortal = e, this._attachedRef = i, this.attached.emit(i), i } _getRootNode() { const e = this._viewContainerRef.element.nativeElement; return e.nodeType === e.ELEMENT_NODE ? e : e.parentNode } } return n.\u0275fac = function (e) { return new (e || n)(g(hi), g(Lt), g(N)) }, n.\u0275dir = C({ type: n, selectors: [["", "cdkPortalOutlet", ""]], inputs: { portal: ["cdkPortalOutlet", "portal"] }, outputs: { attached: "attached" }, exportAs: ["cdkPortalOutlet"], features: [D] }), n })(), AD = (() => { class n { } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275mod = ee({ type: n }), n.\u0275inj = X({}), n })(); const OH = (() => { function n() { return Error.call(this), this.message = "argument out of range", this.name = "ArgumentOutOfRangeError", this } return n.prototype = Object.create(Error.prototype), n })(); function Ks(n) { return t => 0 === n ? pD() : t.lift(new NH(n)) } class NH { constructor(t) { if (this.total = t, this.total < 0) throw new OH } call(t, e) { return e.subscribe(new PH(t, this.total)) } } class PH extends Ie { constructor(t, e) { super(t), this.total = e, this.count = 0 } _next(t) { const e = this.total, i = ++this.count; i <= e && (this.destination.next(t), i === e && (this.destination.complete(), this.unsubscribe())) } } const TD = yD(); class KH { constructor(t, e) { this._viewportRuler = t, this._previousHTMLStyles = { top: "", left: "" }, this._isEnabled = !1, this._document = e } attach() { } enable() { if (this._canBeEnabled()) { const t = this._document.documentElement; this._previousScrollPosition = this._viewportRuler.getViewportScrollPosition(), this._previousHTMLStyles.left = t.style.left || "", this._previousHTMLStyles.top = t.style.top || "", t.style.left = Xe(-this._previousScrollPosition.left), t.style.top = Xe(-this._previousScrollPosition.top), t.classList.add("cdk-global-scrollblock"), this._isEnabled = !0 } } disable() { if (this._isEnabled) { const t = this._document.documentElement, i = t.style, r = this._document.body.style, s = i.scrollBehavior || "", o = r.scrollBehavior || ""; this._isEnabled = !1, i.left = this._previousHTMLStyles.left, i.top = this._previousHTMLStyles.top, t.classList.remove("cdk-global-scrollblock"), TD && (i.scrollBehavior = r.scrollBehavior = "auto"), window.scroll(this._previousScrollPosition.left, this._previousScrollPosition.top), TD && (i.scrollBehavior = s, r.scrollBehavior = o) } } _canBeEnabled() { if (this._document.documentElement.classList.contains("cdk-global-scrollblock") || this._isEnabled) return !1; const e = this._document.body, i = this._viewportRuler.getViewportSize(); return e.scrollHeight > i.height || e.scrollWidth > i.width } } class QH { constructor(t, e, i, r) { this._scrollDispatcher = t, this._ngZone = e, this._viewportRuler = i, this._config = r, this._scrollSubscription = null, this._detach = () => { this.disable(), this._overlayRef.hasAttached() && this._ngZone.run(() => this._overlayRef.detach()) } } attach(t) { this._overlayRef = t } enable() { if (this._scrollSubscription) return; const t = this._scrollDispatcher.scrolled(0); this._config && this._config.threshold && this._config.threshold > 1 ? (this._initialScrollPosition = this._viewportRuler.getViewportScrollPosition().top, this._scrollSubscription = t.subscribe(() => { const e = this._viewportRuler.getViewportScrollPosition().top; Math.abs(e - this._initialScrollPosition) > this._config.threshold ? this._detach() : this._overlayRef.updatePosition() })) : this._scrollSubscription = t.subscribe(this._detach) } disable() { this._scrollSubscription && (this._scrollSubscription.unsubscribe(), this._scrollSubscription = null) } detach() { this.disable(), this._overlayRef = null } } class ID { enable() { } disable() { } attach() { } } function Sp(n, t) { return t.some(e => n.bottom < e.top || n.top > e.bottom || n.right < e.left || n.left > e.right) } function FD(n, t) { return t.some(e => n.top < e.top || n.bottom > e.bottom || n.left < e.left || n.right > e.right) } class YH { constructor(t, e, i, r) { this._scrollDispatcher = t, this._viewportRuler = e, this._ngZone = i, this._config = r, this._scrollSubscription = null } attach(t) { this._overlayRef = t } enable() { this._scrollSubscription || (this._scrollSubscription = this._scrollDispatcher.scrolled(this._config ? this._config.scrollThrottle : 0).subscribe(() => { if (this._overlayRef.updatePosition(), this._config && this._config.autoClose) { const e = this._overlayRef.overlayElement.getBoundingClientRect(), { width: i, height: r } = this._viewportRuler.getViewportSize(); Sp(e, [{ width: i, height: r, bottom: r, right: i, top: 0, left: 0 }]) && (this.disable(), this._ngZone.run(() => this._overlayRef.detach())) } })) } disable() { this._scrollSubscription && (this._scrollSubscription.unsubscribe(), this._scrollSubscription = null) } detach() { this.disable(), this._overlayRef = null } } let JH = (() => { class n { constructor(e, i, r, s) { this._scrollDispatcher = e, this._viewportRuler = i, this._ngZone = r, this.noop = () => new ID, this.close = o => new QH(this._scrollDispatcher, this._ngZone, this._viewportRuler, o), this.block = () => new KH(this._viewportRuler, this._document), this.reposition = o => new YH(this._scrollDispatcher, this._viewportRuler, this._ngZone, o), this._document = s } } return n.\u0275fac = function (e) { return new (e || n)(m(qc), m(Sa), m(H), m(N)) }, n.\u0275prov = E({ factory: function () { return new n(m(qc), m(Sa), m(H), m(N)) }, token: n, providedIn: "root" }), n })(); class Tp { constructor(t) { if (this.scrollStrategy = new ID, this.panelClass = "", this.hasBackdrop = !1, this.backdropClass = "cdk-overlay-dark-backdrop", this.disposeOnNavigation = !1, t) { const e = Object.keys(t); for (const i of e) void 0 !== t[i] && (this[i] = t[i]) } } } class ZH { constructor(t, e, i, r, s) { this.offsetX = i, this.offsetY = r, this.panelClass = s, this.originX = t.originX, this.originY = t.originY, this.overlayX = e.overlayX, this.overlayY = e.overlayY } } class XH { constructor(t, e) { this.connectionPair = t, this.scrollableViewProperties = e } } let RD = (() => { class n { constructor(e) { this._attachedOverlays = [], this._document = e } ngOnDestroy() { this.detach() } add(e) { this.remove(e), this._attachedOverlays.push(e) } remove(e) { const i = this._attachedOverlays.indexOf(e); i > -1 && this._attachedOverlays.splice(i, 1), 0 === this._attachedOverlays.length && this.detach() } } return n.\u0275fac = function (e) { return new (e || n)(m(N)) }, n.\u0275prov = E({ factory: function () { return new n(m(N)) }, token: n, providedIn: "root" }), n })(), ej = (() => { class n extends RD { constructor(e) { super(e), this._keydownListener = i => { const r = this._attachedOverlays; for (let s = r.length - 1; s > -1; s--)if (r[s]._keydownEvents.observers.length > 0) { r[s]._keydownEvents.next(i); break } } } add(e) { super.add(e), this._isAttached || (this._document.body.addEventListener("keydown", this._keydownListener), this._isAttached = !0) } detach() { this._isAttached && (this._document.body.removeEventListener("keydown", this._keydownListener), this._isAttached = !1) } } return n.\u0275fac = function (e) { return new (e || n)(m(N)) }, n.\u0275prov = E({ factory: function () { return new n(m(N)) }, token: n, providedIn: "root" }), n })(), tj = (() => { class n extends RD { constructor(e, i) { super(e), this._platform = i, this._cursorStyleIsSet = !1, this._clickListener = r => { const s = Ws(r), o = this._attachedOverlays.slice(); for (let a = o.length - 1; a > -1; a--) { const l = o[a]; if (!(l._outsidePointerEvents.observers.length < 1) && l.hasAttached()) { if (l.overlayElement.contains(s)) break; l._outsidePointerEvents.next(r) } } } } add(e) { if (super.add(e), !this._isAttached) { const i = this._document.body; i.addEventListener("click", this._clickListener, !0), i.addEventListener("auxclick", this._clickListener, !0), i.addEventListener("contextmenu", this._clickListener, !0), this._platform.IOS && !this._cursorStyleIsSet && (this._cursorOriginalValue = i.style.cursor, i.style.cursor = "pointer", this._cursorStyleIsSet = !0), this._isAttached = !0 } } detach() { if (this._isAttached) { const e = this._document.body; e.removeEventListener("click", this._clickListener, !0), e.removeEventListener("auxclick", this._clickListener, !0), e.removeEventListener("contextmenu", this._clickListener, !0), this._platform.IOS && this._cursorStyleIsSet && (e.style.cursor = this._cursorOriginalValue, this._cursorStyleIsSet = !1), this._isAttached = !1 } } } return n.\u0275fac = function (e) { return new (e || n)(m(N), m(Ce)) }, n.\u0275prov = E({ factory: function () { return new n(m(N), m(Ce)) }, token: n, providedIn: "root" }), n })(); const Wi = "undefined" != typeof window ? window : {}, kD = void 0 !== Wi.__karma__ && !!Wi.__karma__ || void 0 !== Wi.jasmine && !!Wi.jasmine || void 0 !== Wi.jest && !!Wi.jest || void 0 !== Wi.Mocha && !!Wi.Mocha; let Ip = (() => { class n { constructor(e, i) { this._platform = i, this._document = e } ngOnDestroy() { const e = this._containerElement; e && e.parentNode && e.parentNode.removeChild(e) } getContainerElement() { return this._containerElement || this._createContainer(), this._containerElement } _createContainer() { const e = "cdk-overlay-container"; if (this._platform.isBrowser || kD) { const r = this._document.querySelectorAll(`.${e}[platform="server"], .${e}[platform="test"]`); for (let s = 0; s < r.length; s++)r[s].parentNode.removeChild(r[s]) } const i = this._document.createElement("div"); i.classList.add(e), kD ? i.setAttribute("platform", "test") : this._platform.isBrowser || i.setAttribute("platform", "server"), this._document.body.appendChild(i), this._containerElement = i } } return n.\u0275fac = function (e) { return new (e || n)(m(N), m(Ce)) }, n.\u0275prov = E({ factory: function () { return new n(m(N), m(Ce)) }, token: n, providedIn: "root" }), n })(); class nj { constructor(t, e, i, r, s, o, a, l, c) { this._portalOutlet = t, this._host = e, this._pane = i, this._config = r, this._ngZone = s, this._keyboardDispatcher = o, this._document = a, this._location = l, this._outsideClickDispatcher = c, this._backdropElement = null, this._backdropClick = new ie, this._attachments = new ie, this._detachments = new ie, this._locationChanges = he.EMPTY, this._backdropClickHandler = u => this._backdropClick.next(u), this._keydownEvents = new ie, this._outsidePointerEvents = new ie, r.scrollStrategy && (this._scrollStrategy = r.scrollStrategy, this._scrollStrategy.attach(this)), this._positionStrategy = r.positionStrategy } get overlayElement() { return this._pane } get backdropElement() { return this._backdropElement } get hostElement() { return this._host } attach(t) { let e = this._portalOutlet.attach(t); return !this._host.parentElement && this._previousHostParent && this._previousHostParent.appendChild(this._host), this._positionStrategy && this._positionStrategy.attach(this), this._updateStackingOrder(), this._updateElementSize(), this._updateElementDirection(), this._scrollStrategy && this._scrollStrategy.enable(), this._ngZone.onStable.pipe(Ks(1)).subscribe(() => { this.hasAttached() && this.updatePosition() }), this._togglePointerEvents(!0), this._config.hasBackdrop && this._attachBackdrop(), this._config.panelClass && this._toggleClasses(this._pane, this._config.panelClass, !0), this._attachments.next(), this._keyboardDispatcher.add(this), this._config.disposeOnNavigation && (this._locationChanges = this._location.subscribe(() => this.dispose())), this._outsideClickDispatcher.add(this), e } detach() { if (!this.hasAttached()) return; this.detachBackdrop(), this._togglePointerEvents(!1), this._positionStrategy && this._positionStrategy.detach && this._positionStrategy.detach(), this._scrollStrategy && this._scrollStrategy.disable(); const t = this._portalOutlet.detach(); return this._detachments.next(), this._keyboardDispatcher.remove(this), this._detachContentWhenStable(), this._locationChanges.unsubscribe(), this._outsideClickDispatcher.remove(this), t } dispose() { const t = this.hasAttached(); this._positionStrategy && this._positionStrategy.dispose(), this._disposeScrollStrategy(), this.detachBackdrop(), this._locationChanges.unsubscribe(), this._keyboardDispatcher.remove(this), this._portalOutlet.dispose(), this._attachments.complete(), this._backdropClick.complete(), this._keydownEvents.complete(), this._outsidePointerEvents.complete(), this._outsideClickDispatcher.remove(this), this._host && this._host.parentNode && (this._host.parentNode.removeChild(this._host), this._host = null), this._previousHostParent = this._pane = null, t && this._detachments.next(), this._detachments.complete() } hasAttached() { return this._portalOutlet.hasAttached() } backdropClick() { return this._backdropClick } attachments() { return this._attachments } detachments() { return this._detachments } keydownEvents() { return this._keydownEvents } outsidePointerEvents() { return this._outsidePointerEvents } getConfig() { return this._config } updatePosition() { this._positionStrategy && this._positionStrategy.apply() } updatePositionStrategy(t) { t !== this._positionStrategy && (this._positionStrategy && this._positionStrategy.dispose(), this._positionStrategy = t, this.hasAttached() && (t.attach(this), this.updatePosition())) } updateSize(t) { this._config = Object.assign(Object.assign({}, this._config), t), this._updateElementSize() } setDirection(t) { this._config = Object.assign(Object.assign({}, this._config), { direction: t }), this._updateElementDirection() } addPanelClass(t) { this._pane && this._toggleClasses(this._pane, t, !0) } removePanelClass(t) { this._pane && this._toggleClasses(this._pane, t, !1) } getDirection() { const t = this._config.direction; return t ? "string" == typeof t ? t : t.value : "ltr" } updateScrollStrategy(t) { t !== this._scrollStrategy && (this._disposeScrollStrategy(), this._scrollStrategy = t, this.hasAttached() && (t.attach(this), t.enable())) } _updateElementDirection() { this._host.setAttribute("dir", this.getDirection()) } _updateElementSize() { if (!this._pane) return; const t = this._pane.style; t.width = Xe(this._config.width), t.height = Xe(this._config.height), t.minWidth = Xe(this._config.minWidth), t.minHeight = Xe(this._config.minHeight), t.maxWidth = Xe(this._config.maxWidth), t.maxHeight = Xe(this._config.maxHeight) } _togglePointerEvents(t) { this._pane.style.pointerEvents = t ? "" : "none" } _attachBackdrop() { const t = "cdk-overlay-backdrop-showing"; this._backdropElement = this._document.createElement("div"), this._backdropElement.classList.add("cdk-overlay-backdrop"), this._config.backdropClass && this._toggleClasses(this._backdropElement, this._config.backdropClass, !0), this._host.parentElement.insertBefore(this._backdropElement, this._host), this._backdropElement.addEventListener("click", this._backdropClickHandler), "undefined" != typeof requestAnimationFrame ? this._ngZone.runOutsideAngular(() => { requestAnimationFrame(() => { this._backdropElement && this._backdropElement.classList.add(t) }) }) : this._backdropElement.classList.add(t) } _updateStackingOrder() { this._host.nextSibling && this._host.parentNode.appendChild(this._host) } detachBackdrop() { let t = this._backdropElement; if (!t) return; let e, i = () => { t && (t.removeEventListener("click", this._backdropClickHandler), t.removeEventListener("transitionend", i), t.parentNode && t.parentNode.removeChild(t)), this._backdropElement == t && (this._backdropElement = null), this._config.backdropClass && this._toggleClasses(t, this._config.backdropClass, !1), clearTimeout(e) }; t.classList.remove("cdk-overlay-backdrop-showing"), this._ngZone.runOutsideAngular(() => { t.addEventListener("transitionend", i) }), t.style.pointerEvents = "none", e = this._ngZone.runOutsideAngular(() => setTimeout(i, 500)) } _toggleClasses(t, e, i) { const r = t.classList; Hc(e).forEach(s => { s && (i ? r.add(s) : r.remove(s)) }) } _detachContentWhenStable() { this._ngZone.runOutsideAngular(() => { const t = this._ngZone.onStable.pipe(pt(uo(this._attachments, this._detachments))).subscribe(() => { (!this._pane || !this._host || 0 === this._pane.children.length) && (this._pane && this._config.panelClass && this._toggleClasses(this._pane, this._config.panelClass, !1), this._host && this._host.parentElement && (this._previousHostParent = this._host.parentElement, this._previousHostParent.removeChild(this._host)), t.unsubscribe()) }) }) } _disposeScrollStrategy() { const t = this._scrollStrategy; t && (t.disable(), t.detach && t.detach()) } } const OD = "cdk-overlay-connected-position-bounding-box", ij = /([A-Za-z%]+)$/; class ND { constructor(t, e, i, r, s) { this._viewportRuler = e, this._document = i, this._platform = r, this._overlayContainer = s, this._lastBoundingBoxSize = { width: 0, height: 0 }, this._isPushed = !1, this._canPush = !0, this._growAfterOpen = !1, this._hasFlexibleDimensions = !0, this._positionLocked = !1, this._viewportMargin = 0, this._scrollables = [], this._preferredPositions = [], this._positionChanges = new ie, this._resizeSubscription = he.EMPTY, this._offsetX = 0, this._offsetY = 0, this._appliedPanelClasses = [], this.positionChanges = this._positionChanges, this.setOrigin(t) } get positions() { return this._preferredPositions } attach(t) { this._validatePositions(), t.hostElement.classList.add(OD), this._overlayRef = t, this._boundingBox = t.hostElement, this._pane = t.overlayElement, this._isDisposed = !1, this._isInitialRender = !0, this._lastPosition = null, this._resizeSubscription.unsubscribe(), this._resizeSubscription = this._viewportRuler.change().subscribe(() => { this._isInitialRender = !0, this.apply() }) } apply() { if (this._isDisposed || !this._platform.isBrowser) return; if (!this._isInitialRender && this._positionLocked && this._lastPosition) return void this.reapplyLastPosition(); this._clearPanelClasses(), this._resetOverlayElementStyles(), this._resetBoundingBoxStyles(), this._viewportRect = this._getNarrowedViewportRect(), this._originRect = this._getOriginRect(), this._overlayRect = this._pane.getBoundingClientRect(); const t = this._originRect, e = this._overlayRect, i = this._viewportRect, r = []; let s; for (let o of this._preferredPositions) { let a = this._getOriginPoint(t, o), l = this._getOverlayPoint(a, e, o), c = this._getOverlayFit(l, e, i, o); if (c.isCompletelyWithinViewport) return this._isPushed = !1, void this._applyPosition(o, a); this._canFitWithFlexibleDimensions(c, l, i) ? r.push({ position: o, origin: a, overlayRect: e, boundingBoxRect: this._calculateBoundingBoxRect(a, o) }) : (!s || s.overlayFit.visibleArea < c.visibleArea) && (s = { overlayFit: c, overlayPoint: l, originPoint: a, position: o, overlayRect: e }) } if (r.length) { let o = null, a = -1; for (const l of r) { const c = l.boundingBoxRect.width * l.boundingBoxRect.height * (l.position.weight || 1); c > a && (a = c, o = l) } return this._isPushed = !1, void this._applyPosition(o.position, o.origin) } if (this._canPush) return this._isPushed = !0, void this._applyPosition(s.position, s.originPoint); this._applyPosition(s.position, s.originPoint) } detach() { this._clearPanelClasses(), this._lastPosition = null, this._previousPushAmount = null, this._resizeSubscription.unsubscribe() } dispose() { this._isDisposed || (this._boundingBox && Tr(this._boundingBox.style, { top: "", left: "", right: "", bottom: "", height: "", width: "", alignItems: "", justifyContent: "" }), this._pane && this._resetOverlayElementStyles(), this._overlayRef && this._overlayRef.hostElement.classList.remove(OD), this.detach(), this._positionChanges.complete(), this._overlayRef = this._boundingBox = null, this._isDisposed = !0) } reapplyLastPosition() { if (!this._isDisposed && (!this._platform || this._platform.isBrowser)) { this._originRect = this._getOriginRect(), this._overlayRect = this._pane.getBoundingClientRect(), this._viewportRect = this._getNarrowedViewportRect(); const t = this._lastPosition || this._preferredPositions[0], e = this._getOriginPoint(this._originRect, t); this._applyPosition(t, e) } } withScrollableContainers(t) { return this._scrollables = t, this } withPositions(t) { return this._preferredPositions = t, -1 === t.indexOf(this._lastPosition) && (this._lastPosition = null), this._validatePositions(), this } withViewportMargin(t) { return this._viewportMargin = t, this } withFlexibleDimensions(t = !0) { return this._hasFlexibleDimensions = t, this } withGrowAfterOpen(t = !0) { return this._growAfterOpen = t, this } withPush(t = !0) { return this._canPush = t, this } withLockedPosition(t = !0) { return this._positionLocked = t, this } setOrigin(t) { return this._origin = t, this } withDefaultOffsetX(t) { return this._offsetX = t, this } withDefaultOffsetY(t) { return this._offsetY = t, this } withTransformOriginOn(t) { return this._transformOriginSelector = t, this } _getOriginPoint(t, e) { let i, r; if ("center" == e.originX) i = t.left + t.width / 2; else { const s = this._isRtl() ? t.right : t.left, o = this._isRtl() ? t.left : t.right; i = "start" == e.originX ? s : o } return r = "center" == e.originY ? t.top + t.height / 2 : "top" == e.originY ? t.top : t.bottom, { x: i, y: r } } _getOverlayPoint(t, e, i) { let r, s; return r = "center" == i.overlayX ? -e.width / 2 : "start" === i.overlayX ? this._isRtl() ? -e.width : 0 : this._isRtl() ? 0 : -e.width, s = "center" == i.overlayY ? -e.height / 2 : "top" == i.overlayY ? 0 : -e.height, { x: t.x + r, y: t.y + s } } _getOverlayFit(t, e, i, r) { const s = LD(e); let { x: o, y: a } = t, l = this._getOffset(r, "x"), c = this._getOffset(r, "y"); l && (o += l), c && (a += c); let f = 0 - a, h = a + s.height - i.height, p = this._subtractOverflows(s.width, 0 - o, o + s.width - i.width), y = this._subtractOverflows(s.height, f, h), _ = p * y; return { visibleArea: _, isCompletelyWithinViewport: s.width * s.height === _, fitsInViewportVertically: y === s.height, fitsInViewportHorizontally: p == s.width } } _canFitWithFlexibleDimensions(t, e, i) { if (this._hasFlexibleDimensions) { const r = i.bottom - e.y, s = i.right - e.x, o = PD(this._overlayRef.getConfig().minHeight), a = PD(this._overlayRef.getConfig().minWidth), c = t.fitsInViewportHorizontally || null != a && a <= s; return (t.fitsInViewportVertically || null != o && o <= r) && c } return !1 } _pushOverlayOnScreen(t, e, i) { if (this._previousPushAmount && this._positionLocked) return { x: t.x + this._previousPushAmount.x, y: t.y + this._previousPushAmount.y }; const r = LD(e), s = this._viewportRect, o = Math.max(t.x + r.width - s.width, 0), a = Math.max(t.y + r.height - s.height, 0), l = Math.max(s.top - i.top - t.y, 0), c = Math.max(s.left - i.left - t.x, 0); let u = 0, d = 0; return u = r.width <= s.width ? c || -o : t.x < this._viewportMargin ? s.left - i.left - t.x : 0, d = r.height <= s.height ? l || -a : t.y < this._viewportMargin ? s.top - i.top - t.y : 0, this._previousPushAmount = { x: u, y: d }, { x: t.x + u, y: t.y + d } } _applyPosition(t, e) { if (this._setTransformOrigin(t), this._setOverlayElementStyles(e, t), this._setBoundingBoxStyles(e, t), t.panelClass && this._addPanelClasses(t.panelClass), this._lastPosition = t, this._positionChanges.observers.length) { const i = this._getScrollVisibility(), r = new XH(t, i); this._positionChanges.next(r) } this._isInitialRender = !1 } _setTransformOrigin(t) { if (!this._transformOriginSelector) return; const e = this._boundingBox.querySelectorAll(this._transformOriginSelector); let i, r = t.overlayY; i = "center" === t.overlayX ? "center" : this._isRtl() ? "start" === t.overlayX ? "right" : "left" : "start" === t.overlayX ? "left" : "right"; for (let s = 0; s < e.length; s++)e[s].style.transformOrigin = `${i} ${r}` } _calculateBoundingBoxRect(t, e) { const i = this._viewportRect, r = this._isRtl(); let s, o, a, u, d, f; if ("top" === e.overlayY) o = t.y, s = i.height - o + this._viewportMargin; else if ("bottom" === e.overlayY) a = i.height - t.y + 2 * this._viewportMargin, s = i.height - a + this._viewportMargin; else { const h = Math.min(i.bottom - t.y + i.top, t.y), p = this._lastBoundingBoxSize.height; s = 2 * h, o = t.y - h, s > p && !this._isInitialRender && !this._growAfterOpen && (o = t.y - p / 2) } if ("end" === e.overlayX && !r || "start" === e.overlayX && r) f = i.width - t.x + this._viewportMargin, u = t.x - this._viewportMargin; else if ("start" === e.overlayX && !r || "end" === e.overlayX && r) d = t.x, u = i.right - t.x; else { const h = Math.min(i.right - t.x + i.left, t.x), p = this._lastBoundingBoxSize.width; u = 2 * h, d = t.x - h, u > p && !this._isInitialRender && !this._growAfterOpen && (d = t.x - p / 2) } return { top: o, left: d, bottom: a, right: f, width: u, height: s } } _setBoundingBoxStyles(t, e) { const i = this._calculateBoundingBoxRect(t, e); !this._isInitialRender && !this._growAfterOpen && (i.height = Math.min(i.height, this._lastBoundingBoxSize.height), i.width = Math.min(i.width, this._lastBoundingBoxSize.width)); const r = {}; if (this._hasExactPosition()) r.top = r.left = "0", r.bottom = r.right = r.maxHeight = r.maxWidth = "", r.width = r.height = "100%"; else { const s = this._overlayRef.getConfig().maxHeight, o = this._overlayRef.getConfig().maxWidth; r.height = Xe(i.height), r.top = Xe(i.top), r.bottom = Xe(i.bottom), r.width = Xe(i.width), r.left = Xe(i.left), r.right = Xe(i.right), r.alignItems = "center" === e.overlayX ? "center" : "end" === e.overlayX ? "flex-end" : "flex-start", r.justifyContent = "center" === e.overlayY ? "center" : "bottom" === e.overlayY ? "flex-end" : "flex-start", s && (r.maxHeight = Xe(s)), o && (r.maxWidth = Xe(o)) } this._lastBoundingBoxSize = i, Tr(this._boundingBox.style, r) } _resetBoundingBoxStyles() { Tr(this._boundingBox.style, { top: "0", left: "0", right: "0", bottom: "0", height: "", width: "", alignItems: "", justifyContent: "" }) } _resetOverlayElementStyles() { Tr(this._pane.style, { top: "", left: "", bottom: "", right: "", position: "", transform: "" }) } _setOverlayElementStyles(t, e) { const i = {}, r = this._hasExactPosition(), s = this._hasFlexibleDimensions, o = this._overlayRef.getConfig(); if (r) { const u = this._viewportRuler.getViewportScrollPosition(); Tr(i, this._getExactOverlayY(e, t, u)), Tr(i, this._getExactOverlayX(e, t, u)) } else i.position = "static"; let a = "", l = this._getOffset(e, "x"), c = this._getOffset(e, "y"); l && (a += `translateX(${l}px) `), c && (a += `translateY(${c}px)`), i.transform = a.trim(), o.maxHeight && (r ? i.maxHeight = Xe(o.maxHeight) : s && (i.maxHeight = "")), o.maxWidth && (r ? i.maxWidth = Xe(o.maxWidth) : s && (i.maxWidth = "")), Tr(this._pane.style, i) } _getExactOverlayY(t, e, i) { let r = { top: "", bottom: "" }, s = this._getOverlayPoint(e, this._overlayRect, t); this._isPushed && (s = this._pushOverlayOnScreen(s, this._overlayRect, i)); let o = this._overlayContainer.getContainerElement().getBoundingClientRect().top; return s.y -= o, "bottom" === t.overlayY ? r.bottom = this._document.documentElement.clientHeight - (s.y + this._overlayRect.height) + "px" : r.top = Xe(s.y), r } _getExactOverlayX(t, e, i) { let o, r = { left: "", right: "" }, s = this._getOverlayPoint(e, this._overlayRect, t); return this._isPushed && (s = this._pushOverlayOnScreen(s, this._overlayRect, i)), o = this._isRtl() ? "end" === t.overlayX ? "left" : "right" : "end" === t.overlayX ? "right" : "left", "right" === o ? r.right = this._document.documentElement.clientWidth - (s.x + this._overlayRect.width) + "px" : r.left = Xe(s.x), r } _getScrollVisibility() { const t = this._getOriginRect(), e = this._pane.getBoundingClientRect(), i = this._scrollables.map(r => r.getElementRef().nativeElement.getBoundingClientRect()); return { isOriginClipped: FD(t, i), isOriginOutsideView: Sp(t, i), isOverlayClipped: FD(e, i), isOverlayOutsideView: Sp(e, i) } } _subtractOverflows(t, ...e) { return e.reduce((i, r) => i - Math.max(r, 0), t) } _getNarrowedViewportRect() { const t = this._document.documentElement.clientWidth, e = this._document.documentElement.clientHeight, i = this._viewportRuler.getViewportScrollPosition(); return { top: i.top + this._viewportMargin, left: i.left + this._viewportMargin, right: i.left + t - this._viewportMargin, bottom: i.top + e - this._viewportMargin, width: t - 2 * this._viewportMargin, height: e - 2 * this._viewportMargin } } _isRtl() { return "rtl" === this._overlayRef.getDirection() } _hasExactPosition() { return !this._hasFlexibleDimensions || this._isPushed } _getOffset(t, e) { return "x" === e ? null == t.offsetX ? this._offsetX : t.offsetX : null == t.offsetY ? this._offsetY : t.offsetY } _validatePositions() { } _addPanelClasses(t) { this._pane && Hc(t).forEach(e => { "" !== e && -1 === this._appliedPanelClasses.indexOf(e) && (this._appliedPanelClasses.push(e), this._pane.classList.add(e)) }) } _clearPanelClasses() { this._pane && (this._appliedPanelClasses.forEach(t => { this._pane.classList.remove(t) }), this._appliedPanelClasses = []) } _getOriginRect() { const t = this._origin; if (t instanceof O) return t.nativeElement.getBoundingClientRect(); if (t instanceof Element) return t.getBoundingClientRect(); const e = t.width || 0, i = t.height || 0; return { top: t.y, bottom: t.y + i, left: t.x, right: t.x + e, height: i, width: e } } } function Tr(n, t) { for (let e in t) t.hasOwnProperty(e) && (n[e] = t[e]); return n } function PD(n) { if ("number" != typeof n && null != n) { const [t, e] = n.split(ij); return e && "px" !== e ? null : parseFloat(t) } return n || null } function LD(n) { return { top: Math.floor(n.top), right: Math.floor(n.right), bottom: Math.floor(n.bottom), left: Math.floor(n.left), width: Math.floor(n.width), height: Math.floor(n.height) } } class rj { constructor(t, e, i, r, s, o, a) { this._preferredPositions = [], this._positionStrategy = new ND(i, r, s, o, a).withFlexibleDimensions(!1).withPush(!1).withViewportMargin(0), this.withFallbackPosition(t, e), this.onPositionChange = this._positionStrategy.positionChanges } get positions() { return this._preferredPositions } attach(t) { this._overlayRef = t, this._positionStrategy.attach(t), this._direction && (t.setDirection(this._direction), this._direction = null) } dispose() { this._positionStrategy.dispose() } detach() { this._positionStrategy.detach() } apply() { this._positionStrategy.apply() } recalculateLastPosition() { this._positionStrategy.reapplyLastPosition() } withScrollableContainers(t) { this._positionStrategy.withScrollableContainers(t) } withFallbackPosition(t, e, i, r) { const s = new ZH(t, e, i, r); return this._preferredPositions.push(s), this._positionStrategy.withPositions(this._preferredPositions), this } withDirection(t) { return this._overlayRef ? this._overlayRef.setDirection(t) : this._direction = t, this } withOffsetX(t) { return this._positionStrategy.withDefaultOffsetX(t), this } withOffsetY(t) { return this._positionStrategy.withDefaultOffsetY(t), this } withLockedPosition(t) { return this._positionStrategy.withLockedPosition(t), this } withPositions(t) { return this._preferredPositions = t.slice(), this._positionStrategy.withPositions(this._preferredPositions), this } setOrigin(t) { return this._positionStrategy.setOrigin(t), this } } const VD = "cdk-global-overlay-wrapper"; class sj { constructor() { this._cssPosition = "static", this._topOffset = "", this._bottomOffset = "", this._leftOffset = "", this._rightOffset = "", this._alignItems = "", this._justifyContent = "", this._width = "", this._height = "" } attach(t) { const e = t.getConfig(); this._overlayRef = t, this._width && !e.width && t.updateSize({ width: this._width }), this._height && !e.height && t.updateSize({ height: this._height }), t.hostElement.classList.add(VD), this._isDisposed = !1 } top(t = "") { return this._bottomOffset = "", this._topOffset = t, this._alignItems = "flex-start", this } left(t = "") { return this._rightOffset = "", this._leftOffset = t, this._justifyContent = "flex-start", this } bottom(t = "") { return this._topOffset = "", this._bottomOffset = t, this._alignItems = "flex-end", this } right(t = "") { return this._leftOffset = "", this._rightOffset = t, this._justifyContent = "flex-end", this } width(t = "") { return this._overlayRef ? this._overlayRef.updateSize({ width: t }) : this._width = t, this } height(t = "") { return this._overlayRef ? this._overlayRef.updateSize({ height: t }) : this._height = t, this } centerHorizontally(t = "") { return this.left(t), this._justifyContent = "center", this } centerVertically(t = "") { return this.top(t), this._alignItems = "center", this } apply() { if (!this._overlayRef || !this._overlayRef.hasAttached()) return; const t = this._overlayRef.overlayElement.style, e = this._overlayRef.hostElement.style, i = this._overlayRef.getConfig(), { width: r, height: s, maxWidth: o, maxHeight: a } = i, l = !("100%" !== r && "100vw" !== r || o && "100%" !== o && "100vw" !== o), c = !("100%" !== s && "100vh" !== s || a && "100%" !== a && "100vh" !== a); t.position = this._cssPosition, t.marginLeft = l ? "0" : this._leftOffset, t.marginTop = c ? "0" : this._topOffset, t.marginBottom = this._bottomOffset, t.marginRight = this._rightOffset, l ? e.justifyContent = "flex-start" : "center" === this._justifyContent ? e.justifyContent = "center" : "rtl" === this._overlayRef.getConfig().direction ? "flex-start" === this._justifyContent ? e.justifyContent = "flex-end" : "flex-end" === this._justifyContent && (e.justifyContent = "flex-start") : e.justifyContent = this._justifyContent, e.alignItems = c ? "flex-start" : this._alignItems } dispose() { if (this._isDisposed || !this._overlayRef) return; const t = this._overlayRef.overlayElement.style, e = this._overlayRef.hostElement, i = e.style; e.classList.remove(VD), i.justifyContent = i.alignItems = t.marginTop = t.marginBottom = t.marginLeft = t.marginRight = t.position = "", this._overlayRef = null, this._isDisposed = !0 } } let oj = (() => { class n { constructor(e, i, r, s) { this._viewportRuler = e, this._document = i, this._platform = r, this._overlayContainer = s } global() { return new sj } connectedTo(e, i, r) { return new rj(i, r, e, this._viewportRuler, this._document, this._platform, this._overlayContainer) } flexibleConnectedTo(e) { return new ND(e, this._viewportRuler, this._document, this._platform, this._overlayContainer) } } return n.\u0275fac = function (e) { return new (e || n)(m(Sa), m(N), m(Ce), m(Ip)) }, n.\u0275prov = E({ factory: function () { return new n(m(Sa), m(N), m(Ce), m(Ip)) }, token: n, providedIn: "root" }), n })(), aj = 0, Ta = (() => { class n { constructor(e, i, r, s, o, a, l, c, u, d, f) { this.scrollStrategies = e, this._overlayContainer = i, this._componentFactoryResolver = r, this._positionBuilder = s, this._keyboardDispatcher = o, this._injector = a, this._ngZone = l, this._document = c, this._directionality = u, this._location = d, this._outsideClickDispatcher = f } create(e) { const i = this._createHostElement(), r = this._createPaneElement(i), s = this._createPortalOutlet(r), o = new Tp(e); return o.direction = o.direction || this._directionality.value, new nj(s, i, r, o, this._ngZone, this._keyboardDispatcher, this._document, this._location, this._outsideClickDispatcher) } position() { return this._positionBuilder } _createPaneElement(e) { const i = this._document.createElement("div"); return i.id = "cdk-overlay-" + aj++, i.classList.add("cdk-overlay-pane"), e.appendChild(i), i } _createHostElement() { const e = this._document.createElement("div"); return this._overlayContainer.getContainerElement().appendChild(e), e } _createPortalOutlet(e) { return this._appRef || (this._appRef = this._injector.get(Vs)), new kH(e, this._componentFactoryResolver, this._appRef, this._injector, this._document) } } return n.\u0275fac = function (e) { return new (e || n)(m(JH), m(Ip), m(hi), m(oj), m(ej), m(ce), m(H), m(N), m(zi), m(Aw), m(tj)) }, n.\u0275prov = E({ token: n, factory: n.\u0275fac }), n })(); const uj = { provide: new k("cdk-connected-overlay-scroll-strategy"), deps: [Ta], useFactory: function (n) { return () => n.scrollStrategies.reposition() } }; let dj = (() => { class n { } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275mod = ee({ type: n }), n.\u0275inj = X({ providers: [Ta, uj], imports: [[qs, AD, xD], xD] }), n })(); class HD extends ie { constructor(t) { super(), this._value = t } get value() { return this.getValue() } _subscribe(t) { const e = super._subscribe(t); return e && !e.closed && t.next(this._value), e } getValue() { if (this.hasError) throw this.thrownError; if (this.closed) throw new er; return this._value } next(t) { super.next(this._value = t) } } function jD(n) { return t => t.lift(new fj(n)) } class fj { constructor(t) { this.total = t } call(t, e) { return e.subscribe(new hj(t, this.total)) } } class hj extends Ie { constructor(t, e) { super(t), this.total = e, this.count = 0 } _next(t) { ++this.count > this.total && this.destination.next(t) } } function GD(n, t = Cp) { return e => e.lift(new pj(n, t)) } class pj { constructor(t, e) { this.dueTime = t, this.scheduler = e } call(t, e) { return e.subscribe(new gj(t, this.dueTime, this.scheduler)) } } class gj extends Ie { constructor(t, e, i) { super(t), this.dueTime = e, this.scheduler = i, this.debouncedSubscription = null, this.lastValue = null, this.hasValue = !1 } _next(t) { this.clearDebounce(), this.lastValue = t, this.hasValue = !0, this.add(this.debouncedSubscription = this.scheduler.schedule(mj, this.dueTime, this)) } _complete() { this.debouncedNext(), this.destination.complete() } debouncedNext() { if (this.clearDebounce(), this.hasValue) { const { lastValue: t } = this; this.lastValue = null, this.hasValue = !1, this.destination.next(t) } } clearDebounce() { const t = this.debouncedSubscription; null !== t && (this.remove(t), t.unsubscribe(), this.debouncedSubscription = null) } } function mj(n) { n.debouncedNext() } let Fp = (() => { class n { create(e) { return "undefined" == typeof MutationObserver ? null : new MutationObserver(e) } } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275prov = E({ factory: function () { return new n }, token: n, providedIn: "root" }), n })(), $D = (() => { class n { constructor(e) { this._mutationObserverFactory = e, this._observedElements = new Map } ngOnDestroy() { this._observedElements.forEach((e, i) => this._cleanupObserver(i)) } observe(e) { const i = vi(e); return new me(r => { const o = this._observeElement(i).subscribe(r); return () => { o.unsubscribe(), this._unobserveElement(i) } }) } _observeElement(e) { if (this._observedElements.has(e)) this._observedElements.get(e).count++; else { const i = new ie, r = this._mutationObserverFactory.create(s => i.next(s)); r && r.observe(e, { characterData: !0, childList: !0, subtree: !0 }), this._observedElements.set(e, { observer: r, stream: i, count: 1 }) } return this._observedElements.get(e).stream } _unobserveElement(e) { this._observedElements.has(e) && (this._observedElements.get(e).count--, this._observedElements.get(e).count || this._cleanupObserver(e)) } _cleanupObserver(e) { if (this._observedElements.has(e)) { const { observer: i, stream: r } = this._observedElements.get(e); i && i.disconnect(), r.complete(), this._observedElements.delete(e) } } } return n.\u0275fac = function (e) { return new (e || n)(m(Fp)) }, n.\u0275prov = E({ factory: function () { return new n(m(Fp)) }, token: n, providedIn: "root" }), n })(), _j = (() => { class n { constructor(e, i, r) { this._contentObserver = e, this._elementRef = i, this._ngZone = r, this.event = new ge, this._disabled = !1, this._currentSubscription = null } get disabled() { return this._disabled } set disabled(e) { this._disabled = Te(e), this._disabled ? this._unsubscribe() : this._subscribe() } get debounce() { return this._debounce } set debounce(e) { this._debounce = function (n, t = 0) { return function (n) { return !isNaN(parseFloat(n)) && !isNaN(Number(n)) }(n) ? Number(n) : t }(e), this._subscribe() } ngAfterContentInit() { !this._currentSubscription && !this.disabled && this._subscribe() } ngOnDestroy() { this._unsubscribe() } _subscribe() { this._unsubscribe(); const e = this._contentObserver.observe(this._elementRef); this._ngZone.runOutsideAngular(() => { this._currentSubscription = (this.debounce ? e.pipe(GD(this.debounce)) : e).subscribe(this.event) }) } _unsubscribe() { var e; null === (e = this._currentSubscription) || void 0 === e || e.unsubscribe() } } return n.\u0275fac = function (e) { return new (e || n)(g($D), g(O), g(H)) }, n.\u0275dir = C({ type: n, selectors: [["", "cdkObserveContent", ""]], inputs: { disabled: ["cdkObserveContentDisabled", "disabled"], debounce: "debounce" }, outputs: { event: "cdkObserveContent" }, exportAs: ["cdkObserveContent"] }), n })(), UD = (() => { class n { } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275mod = ee({ type: n }), n.\u0275inj = X({ providers: [Fp] }), n })(); function YD(n) { return 0 === n.offsetX && 0 === n.offsetY } function JD(n) { const t = n.touches && n.touches[0] || n.changedTouches && n.changedTouches[0]; return !(!t || -1 !== t.identifier || null != t.radiusX && 1 !== t.radiusX || null != t.radiusY && 1 !== t.radiusY) } "undefined" != typeof Element && Element; const ZD = new k("cdk-input-modality-detector-options"), Pj = { ignoreKeys: [18, 17, 224, 91, 16] }, Qs = zc({ passive: !0, capture: !0 }); let ex = (() => { class n { constructor(e, i, r, s) { this._platform = e, this._mostRecentTarget = null, this._modality = new HD(null), this._lastTouchMs = 0, this._onKeydown = o => { var a, l; (null === (l = null === (a = this._options) || void 0 === a ? void 0 : a.ignoreKeys) || void 0 === l ? void 0 : l.some(c => c === o.keyCode)) || (this._modality.next("keyboard"), this._mostRecentTarget = Ws(o)) }, this._onMousedown = o => { Date.now() - this._lastTouchMs < 650 || (this._modality.next(YD(o) ? "keyboard" : "mouse"), this._mostRecentTarget = Ws(o)) }, this._onTouchstart = o => { JD(o) ? this._modality.next("keyboard") : (this._lastTouchMs = Date.now(), this._modality.next("touch"), this._mostRecentTarget = Ws(o)) }, this._options = Object.assign(Object.assign({}, Pj), s), this.modalityDetected = this._modality.pipe(jD(1)), this.modalityChanged = this.modalityDetected.pipe(function (n, t) { return e => e.lift(new H2(n, t)) }()), e.isBrowser && i.runOutsideAngular(() => { r.addEventListener("keydown", this._onKeydown, Qs), r.addEventListener("mousedown", this._onMousedown, Qs), r.addEventListener("touchstart", this._onTouchstart, Qs) }) } get mostRecentModality() { return this._modality.value } ngOnDestroy() { !this._platform.isBrowser || (document.removeEventListener("keydown", this._onKeydown, Qs), document.removeEventListener("mousedown", this._onMousedown, Qs), document.removeEventListener("touchstart", this._onTouchstart, Qs)) } } return n.\u0275fac = function (e) { return new (e || n)(m(Ce), m(H), m(N), m(ZD, 8)) }, n.\u0275prov = E({ factory: function () { return new n(m(Ce), m(H), m(N), m(ZD, 8)) }, token: n, providedIn: "root" }), n })(); const tx = new k("liveAnnouncerElement", { providedIn: "root", factory: function () { return null } }), nx = new k("LIVE_ANNOUNCER_DEFAULT_OPTIONS"); let Rp = (() => { class n { constructor(e, i, r, s) { this._ngZone = i, this._defaultOptions = s, this._document = r, this._liveElement = e || this._createLiveElement() } announce(e, ...i) { const r = this._defaultOptions; let s, o; return 1 === i.length && "number" == typeof i[0] ? o = i[0] : [s, o] = i, this.clear(), clearTimeout(this._previousTimeout), s || (s = r && r.politeness ? r.politeness : "polite"), null == o && r && (o = r.duration), this._liveElement.setAttribute("aria-live", s), this._ngZone.runOutsideAngular(() => new Promise(a => { clearTimeout(this._previousTimeout), this._previousTimeout = setTimeout(() => { this._liveElement.textContent = e, a(), "number" == typeof o && (this._previousTimeout = setTimeout(() => this.clear(), o)) }, 100) })) } clear() { this._liveElement && (this._liveElement.textContent = "") } ngOnDestroy() { clearTimeout(this._previousTimeout), this._liveElement && this._liveElement.parentNode && (this._liveElement.parentNode.removeChild(this._liveElement), this._liveElement = null) } _createLiveElement() { const e = "cdk-live-announcer-element", i = this._document.getElementsByClassName(e), r = this._document.createElement("div"); for (let s = 0; s < i.length; s++)i[s].parentNode.removeChild(i[s]); return r.classList.add(e), r.classList.add("cdk-visually-hidden"), r.setAttribute("aria-atomic", "true"), r.setAttribute("aria-live", "polite"), this._document.body.appendChild(r), r } } return n.\u0275fac = function (e) { return new (e || n)(m(tx, 8), m(H), m(N), m(nx, 8)) }, n.\u0275prov = E({ factory: function () { return new n(m(tx, 8), m(H), m(N), m(nx, 8)) }, token: n, providedIn: "root" }), n })(); const ix = new k("cdk-focus-monitor-default-options"), Yc = zc({ passive: !0, capture: !0 }); let kp = (() => { class n { constructor(e, i, r, s, o) { this._ngZone = e, this._platform = i, this._inputModalityDetector = r, this._origin = null, this._windowFocused = !1, this._originFromTouchInteraction = !1, this._elementInfo = new Map, this._monitoredElementCount = 0, this._rootNodeFocusListenerCount = new Map, this._windowFocusListener = () => { this._windowFocused = !0, this._windowFocusTimeoutId = setTimeout(() => this._windowFocused = !1) }, this._stopInputModalityDetector = new ie, this._rootNodeFocusAndBlurListener = a => { const l = Ws(a), c = "focus" === a.type ? this._onFocus : this._onBlur; for (let u = l; u; u = u.parentElement)c.call(this, a, u) }, this._document = s, this._detectionMode = (null == o ? void 0 : o.detectionMode) || 0 } monitor(e, i = !1) { const r = vi(e); if (!this._platform.isBrowser || 1 !== r.nodeType) return pn(null); const s = function (n) { if (function () { if (null == Dp) { const n = "undefined" != typeof document ? document.head : null; Dp = !(!n || !n.createShadowRoot && !n.attachShadow) } return Dp }()) { const t = n.getRootNode ? n.getRootNode() : null; if ("undefined" != typeof ShadowRoot && ShadowRoot && t instanceof ShadowRoot) return t } return null }(r) || this._getDocument(), o = this._elementInfo.get(r); if (o) return i && (o.checkChildren = !0), o.subject; const a = { checkChildren: i, subject: new ie, rootNode: s }; return this._elementInfo.set(r, a), this._registerGlobalListeners(a), a.subject } stopMonitoring(e) { const i = vi(e), r = this._elementInfo.get(i); r && (r.subject.complete(), this._setClasses(i), this._elementInfo.delete(i), this._removeGlobalListeners(r)) } focusVia(e, i, r) { const s = vi(e); s === this._getDocument().activeElement ? this._getClosestElementsInfo(s).forEach(([a, l]) => this._originChanged(a, i, l)) : (this._setOrigin(i), "function" == typeof s.focus && s.focus(r)) } ngOnDestroy() { this._elementInfo.forEach((e, i) => this.stopMonitoring(i)) } _getDocument() { return this._document || document } _getWindow() { return this._getDocument().defaultView || window } _toggleClass(e, i, r) { r ? e.classList.add(i) : e.classList.remove(i) } _getFocusOrigin(e) { return this._origin ? this._originFromTouchInteraction ? this._shouldBeAttributedToTouch(e) ? "touch" : "program" : this._origin : this._windowFocused && this._lastFocusOrigin ? this._lastFocusOrigin : "program" } _shouldBeAttributedToTouch(e) { return 1 === this._detectionMode || !!(null == e ? void 0 : e.contains(this._inputModalityDetector._mostRecentTarget)) } _setClasses(e, i) { this._toggleClass(e, "cdk-focused", !!i), this._toggleClass(e, "cdk-touch-focused", "touch" === i), this._toggleClass(e, "cdk-keyboard-focused", "keyboard" === i), this._toggleClass(e, "cdk-mouse-focused", "mouse" === i), this._toggleClass(e, "cdk-program-focused", "program" === i) } _setOrigin(e, i = !1) { this._ngZone.runOutsideAngular(() => { this._origin = e, this._originFromTouchInteraction = "touch" === e && i, 0 === this._detectionMode && (clearTimeout(this._originTimeoutId), this._originTimeoutId = setTimeout(() => this._origin = null, this._originFromTouchInteraction ? 650 : 1)) }) } _onFocus(e, i) { const r = this._elementInfo.get(i), s = Ws(e); !r || !r.checkChildren && i !== s || this._originChanged(i, this._getFocusOrigin(s), r) } _onBlur(e, i) { const r = this._elementInfo.get(i); !r || r.checkChildren && e.relatedTarget instanceof Node && i.contains(e.relatedTarget) || (this._setClasses(i), this._emitOrigin(r.subject, null)) } _emitOrigin(e, i) { this._ngZone.run(() => e.next(i)) } _registerGlobalListeners(e) { if (!this._platform.isBrowser) return; const i = e.rootNode, r = this._rootNodeFocusListenerCount.get(i) || 0; r || this._ngZone.runOutsideAngular(() => { i.addEventListener("focus", this._rootNodeFocusAndBlurListener, Yc), i.addEventListener("blur", this._rootNodeFocusAndBlurListener, Yc) }), this._rootNodeFocusListenerCount.set(i, r + 1), 1 == ++this._monitoredElementCount && (this._ngZone.runOutsideAngular(() => { this._getWindow().addEventListener("focus", this._windowFocusListener) }), this._inputModalityDetector.modalityDetected.pipe(pt(this._stopInputModalityDetector)).subscribe(s => { this._setOrigin(s, !0) })) } _removeGlobalListeners(e) { const i = e.rootNode; if (this._rootNodeFocusListenerCount.has(i)) { const r = this._rootNodeFocusListenerCount.get(i); r > 1 ? this._rootNodeFocusListenerCount.set(i, r - 1) : (i.removeEventListener("focus", this._rootNodeFocusAndBlurListener, Yc), i.removeEventListener("blur", this._rootNodeFocusAndBlurListener, Yc), this._rootNodeFocusListenerCount.delete(i)) } --this._monitoredElementCount || (this._getWindow().removeEventListener("focus", this._windowFocusListener), this._stopInputModalityDetector.next(), clearTimeout(this._windowFocusTimeoutId), clearTimeout(this._originTimeoutId)) } _originChanged(e, i, r) { this._setClasses(e, i), this._emitOrigin(r.subject, i), this._lastFocusOrigin = i } _getClosestElementsInfo(e) { const i = []; return this._elementInfo.forEach((r, s) => { (s === e || r.checkChildren && s.contains(e)) && i.push([s, r]) }), i } } return n.\u0275fac = function (e) { return new (e || n)(m(H), m(Ce), m(ex), m(N, 8), m(ix, 8)) }, n.\u0275prov = E({ factory: function () { return new n(m(H), m(Ce), m(ex), m(N, 8), m(ix, 8)) }, token: n, providedIn: "root" }), n })(); const rx = "cdk-high-contrast-black-on-white", sx = "cdk-high-contrast-white-on-black", Op = "cdk-high-contrast-active"; let ox = (() => { class n { constructor(e, i) { this._platform = e, this._document = i } getHighContrastMode() { if (!this._platform.isBrowser) return 0; const e = this._document.createElement("div"); e.style.backgroundColor = "rgb(1,2,3)", e.style.position = "absolute", this._document.body.appendChild(e); const i = this._document.defaultView || window, r = i && i.getComputedStyle ? i.getComputedStyle(e) : null, s = (r && r.backgroundColor || "").replace(/ /g, ""); switch (this._document.body.removeChild(e), s) { case "rgb(0,0,0)": return 2; case "rgb(255,255,255)": return 1 }return 0 } _applyBodyHighContrastModeCssClasses() { if (!this._hasCheckedHighContrastMode && this._platform.isBrowser && this._document.body) { const e = this._document.body.classList; e.remove(Op), e.remove(rx), e.remove(sx), this._hasCheckedHighContrastMode = !0; const i = this.getHighContrastMode(); 1 === i ? (e.add(Op), e.add(rx)) : 2 === i && (e.add(Op), e.add(sx)) } } } return n.\u0275fac = function (e) { return new (e || n)(m(Ce), m(N)) }, n.\u0275prov = E({ factory: function () { return new n(m(Ce), m(N)) }, token: n, providedIn: "root" }), n })(); const ax = new Pi("12.2.1"); class lx { } const bi = "*"; function cx(n, t) { return { type: 7, name: n, definitions: t, options: {} } } function Np(n, t = null) { return { type: 4, styles: t, timings: n } } function ux(n, t = null) { return { type: 2, steps: n, options: t } } function Ir(n) { return { type: 6, styles: n, offset: null } } function Pp(n, t, e) { return { type: 0, name: n, styles: t, options: e } } function Lp(n, t, e = null) { return { type: 1, expr: n, animation: t, options: e } } function dx(n) { Promise.resolve(null).then(n) } class Ys { constructor(t = 0, e = 0) { this._onDoneFns = [], this._onStartFns = [], this._onDestroyFns = [], this._started = !1, this._destroyed = !1, this._finished = !1, this._position = 0, this.parentPlayer = null, this.totalTime = t + e } _onFinish() { this._finished || (this._finished = !0, this._onDoneFns.forEach(t => t()), this._onDoneFns = []) } onStart(t) { this._onStartFns.push(t) } onDone(t) { this._onDoneFns.push(t) } onDestroy(t) { this._onDestroyFns.push(t) } hasStarted() { return this._started } init() { } play() { this.hasStarted() || (this._onStart(), this.triggerMicrotask()), this._started = !0 } triggerMicrotask() { dx(() => this._onFinish()) } _onStart() { this._onStartFns.forEach(t => t()), this._onStartFns = [] } pause() { } restart() { } finish() { this._onFinish() } destroy() { this._destroyed || (this._destroyed = !0, this.hasStarted() || this._onStart(), this.finish(), this._onDestroyFns.forEach(t => t()), this._onDestroyFns = []) } reset() { this._started = !1 } setPosition(t) { this._position = this.totalTime ? t * this.totalTime : 1 } getPosition() { return this.totalTime ? this._position / this.totalTime : 1 } triggerCallback(t) { const e = "start" == t ? this._onStartFns : this._onDoneFns; e.forEach(i => i()), e.length = 0 } } class fx { constructor(t) { this._onDoneFns = [], this._onStartFns = [], this._finished = !1, this._started = !1, this._destroyed = !1, this._onDestroyFns = [], this.parentPlayer = null, this.totalTime = 0, this.players = t; let e = 0, i = 0, r = 0; const s = this.players.length; 0 == s ? dx(() => this._onFinish()) : this.players.forEach(o => { o.onDone(() => { ++e == s && this._onFinish() }), o.onDestroy(() => { ++i == s && this._onDestroy() }), o.onStart(() => { ++r == s && this._onStart() }) }), this.totalTime = this.players.reduce((o, a) => Math.max(o, a.totalTime), 0) } _onFinish() { this._finished || (this._finished = !0, this._onDoneFns.forEach(t => t()), this._onDoneFns = []) } init() { this.players.forEach(t => t.init()) } onStart(t) { this._onStartFns.push(t) } _onStart() { this.hasStarted() || (this._started = !0, this._onStartFns.forEach(t => t()), this._onStartFns = []) } onDone(t) { this._onDoneFns.push(t) } onDestroy(t) { this._onDestroyFns.push(t) } hasStarted() { return this._started } play() { this.parentPlayer || this.init(), this._onStart(), this.players.forEach(t => t.play()) } pause() { this.players.forEach(t => t.pause()) } restart() { this.players.forEach(t => t.restart()) } finish() { this._onFinish(), this.players.forEach(t => t.finish()) } destroy() { this._onDestroy() } _onDestroy() { this._destroyed || (this._destroyed = !0, this._onFinish(), this.players.forEach(t => t.destroy()), this._onDestroyFns.forEach(t => t()), this._onDestroyFns = []) } reset() { this.players.forEach(t => t.reset()), this._destroyed = !1, this._finished = !1, this._started = !1 } setPosition(t) { const e = t * this.totalTime; this.players.forEach(i => { const r = i.totalTime ? Math.min(1, e / i.totalTime) : 1; i.setPosition(r) }) } getPosition() { const t = this.players.reduce((e, i) => null === e || i.totalTime > e.totalTime ? i : e, null); return null != t ? t.getPosition() : 0 } beforeDestroy() { this.players.forEach(t => { t.beforeDestroy && t.beforeDestroy() }) } triggerCallback(t) { const e = "start" == t ? this._onStartFns : this._onDoneFns; e.forEach(i => i()), e.length = 0 } } function hx() { return "undefined" != typeof window && void 0 !== window.document } function Bp() { return "undefined" != typeof process && "[object process]" === {}.toString.call(process) } function qi(n) { switch (n.length) { case 0: return new Ys; case 1: return n[0]; default: return new fx(n) } } function px(n, t, e, i, r = {}, s = {}) { const o = [], a = []; let l = -1, c = null; if (i.forEach(u => { const d = u.offset, f = d == l, h = f && c || {}; Object.keys(u).forEach(p => { let y = p, _ = u[p]; if ("offset" !== p) switch (y = t.normalizePropertyName(y, o), _) { case "!": _ = r[p]; break; case bi: _ = s[p]; break; default: _ = t.normalizeStyleValue(p, y, _, o) }h[y] = _ }), f || a.push(h), c = h, l = d }), o.length) { const u = "\n - "; throw new Error(`Unable to animate due to the following errors:${u}${o.join(u)}`) } return a } function Hp(n, t, e, i) { switch (t) { case "start": n.onStart(() => i(e && jp(e, "start", n))); break; case "done": n.onDone(() => i(e && jp(e, "done", n))); break; case "destroy": n.onDestroy(() => i(e && jp(e, "destroy", n))) } } function jp(n, t, e) { const i = e.totalTime, s = Gp(n.element, n.triggerName, n.fromState, n.toState, t || n.phaseName, null == i ? n.totalTime : i, !!e.disabled), o = n._data; return null != o && (s._data = o), s } function Gp(n, t, e, i, r = "", s = 0, o) { return { element: n, triggerName: t, fromState: e, toState: i, phaseName: r, totalTime: s, disabled: !!o } } function Qt(n, t, e) { let i; return n instanceof Map ? (i = n.get(t), i || n.set(t, i = e)) : (i = n[t], i || (i = n[t] = e)), i } function gx(n) { const t = n.indexOf(":"); return [n.substring(1, t), n.substr(t + 1)] } let $p = (n, t) => !1, Up = (n, t) => !1, mx = (n, t, e) => []; const _x = Bp(); (_x || "undefined" != typeof Element) && ($p = hx() ? (n, t) => { for (; t && t !== document.documentElement;) { if (t === n) return !0; t = t.parentNode || t.host } return !1 } : (n, t) => n.contains(t), Up = (() => { if (_x || Element.prototype.matches) return (n, t) => n.matches(t); { const n = Element.prototype, t = n.matchesSelector || n.mozMatchesSelector || n.msMatchesSelector || n.oMatchesSelector || n.webkitMatchesSelector; return t ? (e, i) => t.apply(e, [i]) : Up } })(), mx = (n, t, e) => { let i = []; if (e) { const r = n.querySelectorAll(t); for (let s = 0; s < r.length; s++)i.push(r[s]) } else { const r = n.querySelector(t); r && i.push(r) } return i }); let Fr = null, yx = !1; function zp(n) { Fr || (Fr = ("undefined" != typeof document ? document.body : null) || {}, yx = !!Fr.style && "WebkitAppearance" in Fr.style); let t = !0; return Fr.style && !function (n) { return "ebkit" == n.substring(1, 6) }(n) && (t = n in Fr.style, !t && yx && (t = "Webkit" + n.charAt(0).toUpperCase() + n.substr(1) in Fr.style)), t } const Wp = Up, qp = $p, Kp = mx; function vx(n) { const t = {}; return Object.keys(n).forEach(e => { const i = e.replace(/([a-z])([A-Z])/g, "$1-$2"); t[i] = n[e] }), t } let bx = (() => { class n { validateStyleProperty(e) { return zp(e) } matchesElement(e, i) { return Wp(e, i) } containsElement(e, i) { return qp(e, i) } query(e, i, r) { return Kp(e, i, r) } computeStyle(e, i, r) { return r || "" } animate(e, i, r, s, o, a = [], l) { return new Ys(r, s) } } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275prov = E({ token: n, factory: n.\u0275fac }), n })(); class Jc { } Jc.NOOP = new bx; const Qp = "ng-enter", Zc = "ng-leave", Xc = "ng-trigger", eu = ".ng-trigger", wx = "ng-animating", Yp = ".ng-animating"; function Rr(n) { if ("number" == typeof n) return n; const t = n.match(/^(-?[\.\d]+)(m?s)/); return !t || t.length < 2 ? 0 : Jp(parseFloat(t[1]), t[2]) } function Jp(n, t) { switch (t) { case "s": return 1e3 * n; default: return n } } function tu(n, t, e) { return n.hasOwnProperty("duration") ? n : function (n, t, e) { let r, s = 0, o = ""; if ("string" == typeof n) { const a = n.match(/^(-?[\.\d]+)(m?s)(?:\s+(-?[\.\d]+)(m?s))?(?:\s+([-a-z]+(?:\(.+?\))?))?$/i); if (null === a) return t.push(`The provided timing value "${n}" is invalid.`), { duration: 0, delay: 0, easing: "" }; r = Jp(parseFloat(a[1]), a[2]); const l = a[3]; null != l && (s = Jp(parseFloat(l), a[4])); const c = a[5]; c && (o = c) } else r = n; if (!e) { let a = !1, l = t.length; r < 0 && (t.push("Duration values below 0 are not allowed for this animation step."), a = !0), s < 0 && (t.push("Delay values below 0 are not allowed for this animation step."), a = !0), a && t.splice(l, 0, `The provided timing value "${n}" is invalid.`) } return { duration: r, delay: s, easing: o } }(n, t, e) } function Js(n, t = {}) { return Object.keys(n).forEach(e => { t[e] = n[e] }), t } function Ki(n, t, e = {}) { if (t) for (let i in n) e[i] = n[i]; else Js(n, e); return e } function Dx(n, t, e) { return e ? t + ":" + e + ";" : "" } function xx(n) { let t = ""; for (let e = 0; e < n.style.length; e++) { const i = n.style.item(e); t += Dx(0, i, n.style.getPropertyValue(i)) } for (const e in n.style) n.style.hasOwnProperty(e) && !e.startsWith("_") && (t += Dx(0, Wj(e), n.style[e])); n.setAttribute("style", t) } function ti(n, t, e) { n.style && (Object.keys(t).forEach(i => { const r = Xp(i); e && !e.hasOwnProperty(i) && (e[i] = n.style[r]), n.style[r] = t[i] }), Bp() && xx(n)) } function kr(n, t) { n.style && (Object.keys(t).forEach(e => { const i = Xp(e); n.style[i] = "" }), Bp() && xx(n)) } function Ia(n) { return Array.isArray(n) ? 1 == n.length ? n[0] : ux(n) : n } const Zp = new RegExp("{{\\s*(.+?)\\s*}}", "g"); function Mx(n) { let t = []; if ("string" == typeof n) { let e; for (; e = Zp.exec(n);)t.push(e[1]); Zp.lastIndex = 0 } return t } function nu(n, t, e) { const i = n.toString(), r = i.replace(Zp, (s, o) => { let a = t[o]; return t.hasOwnProperty(o) || (e.push(`Please provide a value for the animation param ${o}`), a = ""), a.toString() }); return r == i ? n : r } function iu(n) { const t = []; let e = n.next(); for (; !e.done;)t.push(e.value), e = n.next(); return t } const zj = /-+([a-z0-9])/g; function Xp(n) { return n.replace(zj, (...t) => t[1].toUpperCase()) } function Wj(n) { return n.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase() } function Ax(n, t) { return 0 === n || 0 === t } function Sx(n, t, e) { const i = Object.keys(e); if (i.length && t.length) { let s = t[0], o = []; if (i.forEach(a => { s.hasOwnProperty(a) || o.push(a), s[a] = e[a] }), o.length) for (var r = 1; r < t.length; r++) { let a = t[r]; o.forEach(function (l) { a[l] = eg(n, l) }) } } return t } function Yt(n, t, e) { switch (t.type) { case 7: return n.visitTrigger(t, e); case 0: return n.visitState(t, e); case 1: return n.visitTransition(t, e); case 2: return n.visitSequence(t, e); case 3: return n.visitGroup(t, e); case 4: return n.visitAnimate(t, e); case 5: return n.visitKeyframes(t, e); case 6: return n.visitStyle(t, e); case 8: return n.visitReference(t, e); case 9: return n.visitAnimateChild(t, e); case 10: return n.visitAnimateRef(t, e); case 11: return n.visitQuery(t, e); case 12: return n.visitStagger(t, e); default: throw new Error(`Unable to resolve animation metadata node #${t.type}`) } } function eg(n, t) { return window.getComputedStyle(n)[t] } function qj(n, t) { const e = []; return "string" == typeof n ? n.split(/\s*,\s*/).forEach(i => function (n, t, e) { if (":" == n[0]) { const l = function (n, t) { switch (n) { case ":enter": return "void => *"; case ":leave": return "* => void"; case ":increment": return (e, i) => parseFloat(i) > parseFloat(e); case ":decrement": return (e, i) => parseFloat(i) < parseFloat(e); default: return t.push(`The transition alias value "${n}" is not supported`), "* => *" } }(n, e); if ("function" == typeof l) return void t.push(l); n = l } const i = n.match(/^(\*|[-\w]+)\s*(<?[=-]>)\s*(\*|[-\w]+)$/); if (null == i || i.length < 4) return e.push(`The provided transition expression "${n}" is not supported`), t; const r = i[1], s = i[2], o = i[3]; t.push(Tx(r, o)); "<" == s[0] && !("*" == r && "*" == o) && t.push(Tx(o, r)) }(i, e, t)) : e.push(n), e } const su = new Set(["true", "1"]), ou = new Set(["false", "0"]); function Tx(n, t) { const e = su.has(n) || ou.has(n), i = su.has(t) || ou.has(t); return (r, s) => { let o = "*" == n || n == r, a = "*" == t || t == s; return !o && e && "boolean" == typeof r && (o = r ? su.has(n) : ou.has(n)), !a && i && "boolean" == typeof s && (a = s ? su.has(t) : ou.has(t)), o && a } } const Yj = new RegExp("s*:selfs*,?", "g"); function tg(n, t, e) { return new Jj(n).build(t, e) } class Jj { constructor(t) { this._driver = t } build(t, e) { const i = new eG(e); return this._resetContextStyleTimingState(i), Yt(this, Ia(t), i) } _resetContextStyleTimingState(t) { t.currentQuerySelector = "", t.collectedStyles = {}, t.collectedStyles[""] = {}, t.currentTime = 0 } visitTrigger(t, e) { let i = e.queryCount = 0, r = e.depCount = 0; const s = [], o = []; return "@" == t.name.charAt(0) && e.errors.push("animation triggers cannot be prefixed with an `@` sign (e.g. trigger('@foo', [...]))"), t.definitions.forEach(a => { if (this._resetContextStyleTimingState(e), 0 == a.type) { const l = a, c = l.name; c.toString().split(/\s*,\s*/).forEach(u => { l.name = u, s.push(this.visitState(l, e)) }), l.name = c } else if (1 == a.type) { const l = this.visitTransition(a, e); i += l.queryCount, r += l.depCount, o.push(l) } else e.errors.push("only state() and transition() definitions can sit inside of a trigger()") }), { type: 7, name: t.name, states: s, transitions: o, queryCount: i, depCount: r, options: null } } visitState(t, e) { const i = this.visitStyle(t.styles, e), r = t.options && t.options.params || null; if (i.containsDynamicStyles) { const s = new Set, o = r || {}; if (i.styles.forEach(a => { if (au(a)) { const l = a; Object.keys(l).forEach(c => { Mx(l[c]).forEach(u => { o.hasOwnProperty(u) || s.add(u) }) }) } }), s.size) { const a = iu(s.values()); e.errors.push(`state("${t.name}", ...) must define default values for all the following style substitutions: ${a.join(", ")}`) } } return { type: 0, name: t.name, style: i, options: r ? { params: r } : null } } visitTransition(t, e) { e.queryCount = 0, e.depCount = 0; const i = Yt(this, Ia(t.animation), e); return { type: 1, matchers: qj(t.expr, e.errors), animation: i, queryCount: e.queryCount, depCount: e.depCount, options: Or(t.options) } } visitSequence(t, e) { return { type: 2, steps: t.steps.map(i => Yt(this, i, e)), options: Or(t.options) } } visitGroup(t, e) { const i = e.currentTime; let r = 0; const s = t.steps.map(o => { e.currentTime = i; const a = Yt(this, o, e); return r = Math.max(r, e.currentTime), a }); return e.currentTime = r, { type: 3, steps: s, options: Or(t.options) } } visitAnimate(t, e) { const i = function (n, t) { let e = null; if (n.hasOwnProperty("duration")) e = n; else if ("number" == typeof n) return ng(tu(n, t).duration, 0, ""); const i = n; if (i.split(/\s+/).some(s => "{" == s.charAt(0) && "{" == s.charAt(1))) { const s = ng(0, 0, ""); return s.dynamic = !0, s.strValue = i, s } return e = e || tu(i, t), ng(e.duration, e.delay, e.easing) }(t.timings, e.errors); e.currentAnimateTimings = i; let r, s = t.styles ? t.styles : Ir({}); if (5 == s.type) r = this.visitKeyframes(s, e); else { let o = t.styles, a = !1; if (!o) { a = !0; const c = {}; i.easing && (c.easing = i.easing), o = Ir(c) } e.currentTime += i.duration + i.delay; const l = this.visitStyle(o, e); l.isEmptyStep = a, r = l } return e.currentAnimateTimings = null, { type: 4, timings: i, style: r, options: null } } visitStyle(t, e) { const i = this._makeStyleAst(t, e); return this._validateStyleAst(i, e), i } _makeStyleAst(t, e) { const i = []; Array.isArray(t.styles) ? t.styles.forEach(o => { "string" == typeof o ? o == bi ? i.push(o) : e.errors.push(`The provided style string value ${o} is not allowed.`) : i.push(o) }) : i.push(t.styles); let r = !1, s = null; return i.forEach(o => { if (au(o)) { const a = o, l = a.easing; if (l && (s = l, delete a.easing), !r) for (let c in a) if (a[c].toString().indexOf("{{") >= 0) { r = !0; break } } }), { type: 6, styles: i, easing: s, offset: t.offset, containsDynamicStyles: r, options: null } } _validateStyleAst(t, e) { const i = e.currentAnimateTimings; let r = e.currentTime, s = e.currentTime; i && s > 0 && (s -= i.duration + i.delay), t.styles.forEach(o => { "string" != typeof o && Object.keys(o).forEach(a => { if (!this._driver.validateStyleProperty(a)) return void e.errors.push(`The provided animation property "${a}" is not a supported CSS property for animations`); const l = e.collectedStyles[e.currentQuerySelector], c = l[a]; let u = !0; c && (s != r && s >= c.startTime && r <= c.endTime && (e.errors.push(`The CSS property "${a}" that exists between the times of "${c.startTime}ms" and "${c.endTime}ms" is also being animated in a parallel animation between the times of "${s}ms" and "${r}ms"`), u = !1), s = c.startTime), u && (l[a] = { startTime: s, endTime: r }), e.options && function (n, t, e) { const i = t.params || {}, r = Mx(n); r.length && r.forEach(s => { i.hasOwnProperty(s) || e.push(`Unable to resolve the local animation param ${s} in the given list of values`) }) }(o[a], e.options, e.errors) }) }) } visitKeyframes(t, e) { const i = { type: 5, styles: [], options: null }; if (!e.currentAnimateTimings) return e.errors.push("keyframes() must be placed inside of a call to animate()"), i; let s = 0; const o = []; let a = !1, l = !1, c = 0; const u = t.steps.map(b => { const v = this._makeStyleAst(b, e); let S = null != v.offset ? v.offset : function (n) { if ("string" == typeof n) return null; let t = null; if (Array.isArray(n)) n.forEach(e => { if (au(e) && e.hasOwnProperty("offset")) { const i = e; t = parseFloat(i.offset), delete i.offset } }); else if (au(n) && n.hasOwnProperty("offset")) { const e = n; t = parseFloat(e.offset), delete e.offset } return t }(v.styles), I = 0; return null != S && (s++, I = v.offset = S), l = l || I < 0 || I > 1, a = a || I < c, c = I, o.push(I), v }); l && e.errors.push("Please ensure that all keyframe offsets are between 0 and 1"), a && e.errors.push("Please ensure that all keyframe offsets are in order"); const d = t.steps.length; let f = 0; s > 0 && s < d ? e.errors.push("Not all style() steps within the declared keyframes() contain offsets") : 0 == s && (f = 1 / (d - 1)); const h = d - 1, p = e.currentTime, y = e.currentAnimateTimings, _ = y.duration; return u.forEach((b, v) => { const S = f > 0 ? v == h ? 1 : f * v : o[v], I = S * _; e.currentTime = p + y.delay + I, y.duration = I, this._validateStyleAst(b, e), b.offset = S, i.styles.push(b) }), i } visitReference(t, e) { return { type: 8, animation: Yt(this, Ia(t.animation), e), options: Or(t.options) } } visitAnimateChild(t, e) { return e.depCount++, { type: 9, options: Or(t.options) } } visitAnimateRef(t, e) { return { type: 10, animation: this.visitReference(t.animation, e), options: Or(t.options) } } visitQuery(t, e) { const i = e.currentQuerySelector, r = t.options || {}; e.queryCount++, e.currentQuery = t; const [s, o] = function (n) { const t = !!n.split(/\s*,\s*/).find(e => ":self" == e); return t && (n = n.replace(Yj, "")), [n = n.replace(/@\*/g, eu).replace(/@\w+/g, e => eu + "-" + e.substr(1)).replace(/:animating/g, Yp), t] }(t.selector); e.currentQuerySelector = i.length ? i + " " + s : s, Qt(e.collectedStyles, e.currentQuerySelector, {}); const a = Yt(this, Ia(t.animation), e); return e.currentQuery = null, e.currentQuerySelector = i, { type: 11, selector: s, limit: r.limit || 0, optional: !!r.optional, includeSelf: o, animation: a, originalSelector: t.selector, options: Or(t.options) } } visitStagger(t, e) { e.currentQuery || e.errors.push("stagger() can only be used inside of query()"); const i = "full" === t.timings ? { duration: 0, delay: 0, easing: "full" } : tu(t.timings, e.errors, !0); return { type: 12, animation: Yt(this, Ia(t.animation), e), timings: i, options: null } } } class eG { constructor(t) { this.errors = t, this.queryCount = 0, this.depCount = 0, this.currentTransition = null, this.currentQuery = null, this.currentQuerySelector = null, this.currentAnimateTimings = null, this.currentTime = 0, this.collectedStyles = {}, this.options = null } } function au(n) { return !Array.isArray(n) && "object" == typeof n } function Or(n) { return n ? (n = Js(n)).params && (n.params = function (n) { return n ? Js(n) : null }(n.params)) : n = {}, n } function ng(n, t, e) { return { duration: n, delay: t, easing: e } } function ig(n, t, e, i, r, s, o = null, a = !1) { return { type: 1, element: n, keyframes: t, preStyleProps: e, postStyleProps: i, duration: r, delay: s, totalTime: r + s, easing: o, subTimeline: a } } class lu { constructor() { this._map = new Map } consume(t) { let e = this._map.get(t); return e ? this._map.delete(t) : e = [], e } append(t, e) { let i = this._map.get(t); i || this._map.set(t, i = []), i.push(...e) } has(t) { return this._map.has(t) } clear() { this._map.clear() } } const sG = new RegExp(":enter", "g"), aG = new RegExp(":leave", "g"); function rg(n, t, e, i, r, s = {}, o = {}, a, l, c = []) { return (new lG).buildKeyframes(n, t, e, i, r, s, o, a, l, c) } class lG { buildKeyframes(t, e, i, r, s, o, a, l, c, u = []) { c = c || new lu; const d = new sg(t, e, c, r, s, u, []); d.options = l, d.currentTimeline.setStyles([o], null, d.errors, l), Yt(this, i, d); const f = d.timelines.filter(h => h.containsAnimation()); if (f.length && Object.keys(a).length) { const h = f[f.length - 1]; h.allowOnlyTimelineStyles() || h.setStyles([a], null, d.errors, l) } return f.length ? f.map(h => h.buildKeyframes()) : [ig(e, [], [], [], 0, 0, "", !1)] } visitTrigger(t, e) { } visitState(t, e) { } visitTransition(t, e) { } visitAnimateChild(t, e) { const i = e.subInstructions.consume(e.element); if (i) { const r = e.createSubContext(t.options), s = e.currentTimeline.currentTime, o = this._visitSubInstructions(i, r, r.options); s != o && e.transformIntoNewTimeline(o) } e.previousNode = t } visitAnimateRef(t, e) { const i = e.createSubContext(t.options); i.transformIntoNewTimeline(), this.visitReference(t.animation, i), e.transformIntoNewTimeline(i.currentTimeline.currentTime), e.previousNode = t } _visitSubInstructions(t, e, i) { let s = e.currentTimeline.currentTime; const o = null != i.duration ? Rr(i.duration) : null, a = null != i.delay ? Rr(i.delay) : null; return 0 !== o && t.forEach(l => { const c = e.appendInstructionToTimeline(l, o, a); s = Math.max(s, c.duration + c.delay) }), s } visitReference(t, e) { e.updateOptions(t.options, !0), Yt(this, t.animation, e), e.previousNode = t } visitSequence(t, e) { const i = e.subContextCount; let r = e; const s = t.options; if (s && (s.params || s.delay) && (r = e.createSubContext(s), r.transformIntoNewTimeline(), null != s.delay)) { 6 == r.previousNode.type && (r.currentTimeline.snapshotCurrentStyles(), r.previousNode = cu); const o = Rr(s.delay); r.delayNextStep(o) } t.steps.length && (t.steps.forEach(o => Yt(this, o, r)), r.currentTimeline.applyStylesToKeyframe(), r.subContextCount > i && r.transformIntoNewTimeline()), e.previousNode = t } visitGroup(t, e) { const i = []; let r = e.currentTimeline.currentTime; const s = t.options && t.options.delay ? Rr(t.options.delay) : 0; t.steps.forEach(o => { const a = e.createSubContext(t.options); s && a.delayNextStep(s), Yt(this, o, a), r = Math.max(r, a.currentTimeline.currentTime), i.push(a.currentTimeline) }), i.forEach(o => e.currentTimeline.mergeTimelineCollectedStyles(o)), e.transformIntoNewTimeline(r), e.previousNode = t } _visitTiming(t, e) { if (t.dynamic) { const i = t.strValue; return tu(e.params ? nu(i, e.params, e.errors) : i, e.errors) } return { duration: t.duration, delay: t.delay, easing: t.easing } } visitAnimate(t, e) { const i = e.currentAnimateTimings = this._visitTiming(t.timings, e), r = e.currentTimeline; i.delay && (e.incrementTime(i.delay), r.snapshotCurrentStyles()); const s = t.style; 5 == s.type ? this.visitKeyframes(s, e) : (e.incrementTime(i.duration), this.visitStyle(s, e), r.applyStylesToKeyframe()), e.currentAnimateTimings = null, e.previousNode = t } visitStyle(t, e) { const i = e.currentTimeline, r = e.currentAnimateTimings; !r && i.getCurrentStyleProperties().length && i.forwardFrame(); const s = r && r.easing || t.easing; t.isEmptyStep ? i.applyEmptyStep(s) : i.setStyles(t.styles, s, e.errors, e.options), e.previousNode = t } visitKeyframes(t, e) { const i = e.currentAnimateTimings, r = e.currentTimeline.duration, s = i.duration, a = e.createSubContext().currentTimeline; a.easing = i.easing, t.styles.forEach(l => { a.forwardTime((l.offset || 0) * s), a.setStyles(l.styles, l.easing, e.errors, e.options), a.applyStylesToKeyframe() }), e.currentTimeline.mergeTimelineCollectedStyles(a), e.transformIntoNewTimeline(r + s), e.previousNode = t } visitQuery(t, e) { const i = e.currentTimeline.currentTime, r = t.options || {}, s = r.delay ? Rr(r.delay) : 0; s && (6 === e.previousNode.type || 0 == i && e.currentTimeline.getCurrentStyleProperties().length) && (e.currentTimeline.snapshotCurrentStyles(), e.previousNode = cu); let o = i; const a = e.invokeQuery(t.selector, t.originalSelector, t.limit, t.includeSelf, !!r.optional, e.errors); e.currentQueryTotal = a.length; let l = null; a.forEach((c, u) => { e.currentQueryIndex = u; const d = e.createSubContext(t.options, c); s && d.delayNextStep(s), c === e.element && (l = d.currentTimeline), Yt(this, t.animation, d), d.currentTimeline.applyStylesToKeyframe(), o = Math.max(o, d.currentTimeline.currentTime) }), e.currentQueryIndex = 0, e.currentQueryTotal = 0, e.transformIntoNewTimeline(o), l && (e.currentTimeline.mergeTimelineCollectedStyles(l), e.currentTimeline.snapshotCurrentStyles()), e.previousNode = t } visitStagger(t, e) { const i = e.parentContext, r = e.currentTimeline, s = t.timings, o = Math.abs(s.duration), a = o * (e.currentQueryTotal - 1); let l = o * e.currentQueryIndex; switch (s.duration < 0 ? "reverse" : s.easing) { case "reverse": l = a - l; break; case "full": l = i.currentStaggerTime }const u = e.currentTimeline; l && u.delayNextStep(l); const d = u.currentTime; Yt(this, t.animation, e), e.previousNode = t, i.currentStaggerTime = r.currentTime - d + (r.startTime - i.currentTimeline.startTime) } } const cu = {}; class sg { constructor(t, e, i, r, s, o, a, l) { this._driver = t, this.element = e, this.subInstructions = i, this._enterClassName = r, this._leaveClassName = s, this.errors = o, this.timelines = a, this.parentContext = null, this.currentAnimateTimings = null, this.previousNode = cu, this.subContextCount = 0, this.options = {}, this.currentQueryIndex = 0, this.currentQueryTotal = 0, this.currentStaggerTime = 0, this.currentTimeline = l || new uu(this._driver, e, 0), a.push(this.currentTimeline) } get params() { return this.options.params } updateOptions(t, e) { if (!t) return; const i = t; let r = this.options; null != i.duration && (r.duration = Rr(i.duration)), null != i.delay && (r.delay = Rr(i.delay)); const s = i.params; if (s) { let o = r.params; o || (o = this.options.params = {}), Object.keys(s).forEach(a => { (!e || !o.hasOwnProperty(a)) && (o[a] = nu(s[a], o, this.errors)) }) } } _copyOptions() { const t = {}; if (this.options) { const e = this.options.params; if (e) { const i = t.params = {}; Object.keys(e).forEach(r => { i[r] = e[r] }) } } return t } createSubContext(t = null, e, i) { const r = e || this.element, s = new sg(this._driver, r, this.subInstructions, this._enterClassName, this._leaveClassName, this.errors, this.timelines, this.currentTimeline.fork(r, i || 0)); return s.previousNode = this.previousNode, s.currentAnimateTimings = this.currentAnimateTimings, s.options = this._copyOptions(), s.updateOptions(t), s.currentQueryIndex = this.currentQueryIndex, s.currentQueryTotal = this.currentQueryTotal, s.parentContext = this, this.subContextCount++, s } transformIntoNewTimeline(t) { return this.previousNode = cu, this.currentTimeline = this.currentTimeline.fork(this.element, t), this.timelines.push(this.currentTimeline), this.currentTimeline } appendInstructionToTimeline(t, e, i) { const r = { duration: null != e ? e : t.duration, delay: this.currentTimeline.currentTime + (null != i ? i : 0) + t.delay, easing: "" }, s = new cG(this._driver, t.element, t.keyframes, t.preStyleProps, t.postStyleProps, r, t.stretchStartingKeyframe); return this.timelines.push(s), r } incrementTime(t) { this.currentTimeline.forwardTime(this.currentTimeline.duration + t) } delayNextStep(t) { t > 0 && this.currentTimeline.delayNextStep(t) } invokeQuery(t, e, i, r, s, o) { let a = []; if (r && a.push(this.element), t.length > 0) { t = (t = t.replace(sG, "." + this._enterClassName)).replace(aG, "." + this._leaveClassName); let c = this._driver.query(this.element, t, 1 != i); 0 !== i && (c = i < 0 ? c.slice(c.length + i, c.length) : c.slice(0, i)), a.push(...c) } return !s && 0 == a.length && o.push(`\`query("${e}")\` returned zero elements. (Use \`query("${e}", { optional: true })\` if you wish to allow this.)`), a } } class uu { constructor(t, e, i, r) { this._driver = t, this.element = e, this.startTime = i, this._elementTimelineStylesLookup = r, this.duration = 0, this._previousKeyframe = {}, this._currentKeyframe = {}, this._keyframes = new Map, this._styleSummary = {}, this._pendingStyles = {}, this._backFill = {}, this._currentEmptyStepKeyframe = null, this._elementTimelineStylesLookup || (this._elementTimelineStylesLookup = new Map), this._localTimelineStyles = Object.create(this._backFill, {}), this._globalTimelineStyles = this._elementTimelineStylesLookup.get(e), this._globalTimelineStyles || (this._globalTimelineStyles = this._localTimelineStyles, this._elementTimelineStylesLookup.set(e, this._localTimelineStyles)), this._loadKeyframe() } containsAnimation() { switch (this._keyframes.size) { case 0: return !1; case 1: return this.getCurrentStyleProperties().length > 0; default: return !0 } } getCurrentStyleProperties() { return Object.keys(this._currentKeyframe) } get currentTime() { return this.startTime + this.duration } delayNextStep(t) { const e = 1 == this._keyframes.size && Object.keys(this._pendingStyles).length; this.duration || e ? (this.forwardTime(this.currentTime + t), e && this.snapshotCurrentStyles()) : this.startTime += t } fork(t, e) { return this.applyStylesToKeyframe(), new uu(this._driver, t, e || this.currentTime, this._elementTimelineStylesLookup) } _loadKeyframe() { this._currentKeyframe && (this._previousKeyframe = this._currentKeyframe), this._currentKeyframe = this._keyframes.get(this.duration), this._currentKeyframe || (this._currentKeyframe = Object.create(this._backFill, {}), this._keyframes.set(this.duration, this._currentKeyframe)) } forwardFrame() { this.duration += 1, this._loadKeyframe() } forwardTime(t) { this.applyStylesToKeyframe(), this.duration = t, this._loadKeyframe() } _updateStyle(t, e) { this._localTimelineStyles[t] = e, this._globalTimelineStyles[t] = e, this._styleSummary[t] = { time: this.currentTime, value: e } } allowOnlyTimelineStyles() { return this._currentEmptyStepKeyframe !== this._currentKeyframe } applyEmptyStep(t) { t && (this._previousKeyframe.easing = t), Object.keys(this._globalTimelineStyles).forEach(e => { this._backFill[e] = this._globalTimelineStyles[e] || bi, this._currentKeyframe[e] = bi }), this._currentEmptyStepKeyframe = this._currentKeyframe } setStyles(t, e, i, r) { e && (this._previousKeyframe.easing = e); const s = r && r.params || {}, o = function (n, t) { const e = {}; let i; return n.forEach(r => { "*" === r ? (i = i || Object.keys(t), i.forEach(s => { e[s] = bi })) : Ki(r, !1, e) }), e }(t, this._globalTimelineStyles); Object.keys(o).forEach(a => { const l = nu(o[a], s, i); this._pendingStyles[a] = l, this._localTimelineStyles.hasOwnProperty(a) || (this._backFill[a] = this._globalTimelineStyles.hasOwnProperty(a) ? this._globalTimelineStyles[a] : bi), this._updateStyle(a, l) }) } applyStylesToKeyframe() { const t = this._pendingStyles, e = Object.keys(t); 0 != e.length && (this._pendingStyles = {}, e.forEach(i => { this._currentKeyframe[i] = t[i] }), Object.keys(this._localTimelineStyles).forEach(i => { this._currentKeyframe.hasOwnProperty(i) || (this._currentKeyframe[i] = this._localTimelineStyles[i]) })) } snapshotCurrentStyles() { Object.keys(this._localTimelineStyles).forEach(t => { const e = this._localTimelineStyles[t]; this._pendingStyles[t] = e, this._updateStyle(t, e) }) } getFinalKeyframe() { return this._keyframes.get(this.duration) } get properties() { const t = []; for (let e in this._currentKeyframe) t.push(e); return t } mergeTimelineCollectedStyles(t) { Object.keys(t._styleSummary).forEach(e => { const i = this._styleSummary[e], r = t._styleSummary[e]; (!i || r.time > i.time) && this._updateStyle(e, r.value) }) } buildKeyframes() { this.applyStylesToKeyframe(); const t = new Set, e = new Set, i = 1 === this._keyframes.size && 0 === this.duration; let r = []; this._keyframes.forEach((a, l) => { const c = Ki(a, !0); Object.keys(c).forEach(u => { const d = c[u]; "!" == d ? t.add(u) : d == bi && e.add(u) }), i || (c.offset = l / this.duration), r.push(c) }); const s = t.size ? iu(t.values()) : [], o = e.size ? iu(e.values()) : []; if (i) { const a = r[0], l = Js(a); a.offset = 0, l.offset = 1, r = [a, l] } return ig(this.element, r, s, o, this.duration, this.startTime, this.easing, !1) } } class cG extends uu { constructor(t, e, i, r, s, o, a = !1) { super(t, e, o.delay), this.keyframes = i, this.preStyleProps = r, this.postStyleProps = s, this._stretchStartingKeyframe = a, this.timings = { duration: o.duration, delay: o.delay, easing: o.easing } } containsAnimation() { return this.keyframes.length > 1 } buildKeyframes() { let t = this.keyframes, { delay: e, duration: i, easing: r } = this.timings; if (this._stretchStartingKeyframe && e) { const s = [], o = i + e, a = e / o, l = Ki(t[0], !1); l.offset = 0, s.push(l); const c = Ki(t[0], !1); c.offset = Rx(a), s.push(c); const u = t.length - 1; for (let d = 1; d <= u; d++) { let f = Ki(t[d], !1); f.offset = Rx((e + f.offset * i) / o), s.push(f) } i = o, e = 0, r = "", t = s } return ig(this.element, t, this.preStyleProps, this.postStyleProps, i, e, r, !0) } } function Rx(n, t = 3) { const e = Math.pow(10, t - 1); return Math.round(n * e) / e } class og { } class dG extends og { normalizePropertyName(t, e) { return Xp(t) } normalizeStyleValue(t, e, i, r) { let s = ""; const o = i.toString().trim(); if (fG[e] && 0 !== i && "0" !== i) if ("number" == typeof i) s = "px"; else { const a = i.match(/^[+-]?[\d\.]+([a-z]*)$/); a && 0 == a[1].length && r.push(`Please provide a CSS unit value for ${t}:${i}`) } return o + s } } const fG = (() => function (n) { const t = {}; return n.forEach(e => t[e] = !0), t }("width,height,minWidth,minHeight,maxWidth,maxHeight,left,top,bottom,right,fontSize,outlineWidth,outlineOffset,paddingTop,paddingLeft,paddingBottom,paddingRight,marginTop,marginLeft,marginBottom,marginRight,borderRadius,borderWidth,borderTopWidth,borderLeftWidth,borderRightWidth,borderBottomWidth,textIndent,perspective".split(",")))(); function kx(n, t, e, i, r, s, o, a, l, c, u, d, f) { return { type: 0, element: n, triggerName: t, isRemovalTransition: r, fromState: e, fromStyles: s, toState: i, toStyles: o, timelines: a, queriedElements: l, preStyleProps: c, postStyleProps: u, totalTime: d, errors: f } } const ag = {}; class Ox { constructor(t, e, i) { this._triggerName = t, this.ast = e, this._stateStyles = i } match(t, e, i, r) { return function (n, t, e, i, r) { return n.some(s => s(t, e, i, r)) }(this.ast.matchers, t, e, i, r) } buildStyles(t, e, i) { const r = this._stateStyles["*"], s = this._stateStyles[t], o = r ? r.buildStyles(e, i) : {}; return s ? s.buildStyles(e, i) : o } build(t, e, i, r, s, o, a, l, c, u) { const d = [], f = this.ast.options && this.ast.options.params || ag, p = this.buildStyles(i, a && a.params || ag, d), y = l && l.params || ag, _ = this.buildStyles(r, y, d), b = new Set, v = new Map, S = new Map, I = "void" === r, U = { params: Object.assign(Object.assign({}, f), y) }, be = u ? [] : rg(t, e, this.ast.animation, s, o, p, _, U, c, d); let De = 0; if (be.forEach(wt => { De = Math.max(wt.duration + wt.delay, De) }), d.length) return kx(e, this._triggerName, i, r, I, p, _, [], [], v, S, De, d); be.forEach(wt => { const Et = wt.element, Ei = Qt(v, Et, {}); wt.preStyleProps.forEach(Bn => Ei[Bn] = !0); const Di = Qt(S, Et, {}); wt.postStyleProps.forEach(Bn => Di[Bn] = !0), Et !== e && b.add(Et) }); const Ot = iu(b.values()); return kx(e, this._triggerName, i, r, I, p, _, be, Ot, v, S, De) } } class gG { constructor(t, e, i) { this.styles = t, this.defaultParams = e, this.normalizer = i } buildStyles(t, e) { const i = {}, r = Js(this.defaultParams); return Object.keys(t).forEach(s => { const o = t[s]; null != o && (r[s] = o) }), this.styles.styles.forEach(s => { if ("string" != typeof s) { const o = s; Object.keys(o).forEach(a => { let l = o[a]; l.length > 1 && (l = nu(l, r, e)); const c = this.normalizer.normalizePropertyName(a, e); l = this.normalizer.normalizeStyleValue(a, c, l, e), i[c] = l }) } }), i } } class _G { constructor(t, e, i) { this.name = t, this.ast = e, this._normalizer = i, this.transitionFactories = [], this.states = {}, e.states.forEach(r => { this.states[r.name] = new gG(r.style, r.options && r.options.params || {}, i) }), Nx(this.states, "true", "1"), Nx(this.states, "false", "0"), e.transitions.forEach(r => { this.transitionFactories.push(new Ox(t, r, this.states)) }), this.fallbackTransition = function (n, t, e) { return new Ox(n, { type: 1, animation: { type: 2, steps: [], options: null }, matchers: [(o, a) => !0], options: null, queryCount: 0, depCount: 0 }, t) }(t, this.states) } get containsQueries() { return this.ast.queryCount > 0 } matchTransition(t, e, i, r) { return this.transitionFactories.find(o => o.match(t, e, i, r)) || null } matchStyles(t, e, i) { return this.fallbackTransition.buildStyles(t, e, i) } } function Nx(n, t, e) { n.hasOwnProperty(t) ? n.hasOwnProperty(e) || (n[e] = n[t]) : n.hasOwnProperty(e) && (n[t] = n[e]) } const vG = new lu; class bG { constructor(t, e, i) { this.bodyNode = t, this._driver = e, this._normalizer = i, this._animations = {}, this._playersById = {}, this.players = [] } register(t, e) { const i = [], r = tg(this._driver, e, i); if (i.length) throw new Error(`Unable to build the animation due to the following errors: ${i.join("\n")}`); this._animations[t] = r } _buildPlayer(t, e, i) { const r = t.element, s = px(0, this._normalizer, 0, t.keyframes, e, i); return this._driver.animate(r, s, t.duration, t.delay, t.easing, [], !0) } create(t, e, i = {}) { const r = [], s = this._animations[t]; let o; const a = new Map; if (s ? (o = rg(this._driver, e, s, Qp, Zc, {}, {}, i, vG, r), o.forEach(u => { const d = Qt(a, u.element, {}); u.postStyleProps.forEach(f => d[f] = null) })) : (r.push("The requested animation doesn't exist or has already been destroyed"), o = []), r.length) throw new Error(`Unable to create the animation due to the following errors: ${r.join("\n")}`); a.forEach((u, d) => { Object.keys(u).forEach(f => { u[f] = this._driver.computeStyle(d, f, bi) }) }); const c = qi(o.map(u => { const d = a.get(u.element); return this._buildPlayer(u, {}, d) })); return this._playersById[t] = c, c.onDestroy(() => this.destroy(t)), this.players.push(c), c } destroy(t) { const e = this._getPlayer(t); e.destroy(), delete this._playersById[t]; const i = this.players.indexOf(e); i >= 0 && this.players.splice(i, 1) } _getPlayer(t) { const e = this._playersById[t]; if (!e) throw new Error(`Unable to find the timeline player referenced by ${t}`); return e } listen(t, e, i, r) { const s = Gp(e, "", "", ""); return Hp(this._getPlayer(t), i, s, r), () => { } } command(t, e, i, r) { if ("register" == i) return void this.register(t, r[0]); if ("create" == i) return void this.create(t, e, r[0] || {}); const s = this._getPlayer(t); switch (i) { case "play": s.play(); break; case "pause": s.pause(); break; case "reset": s.reset(); break; case "restart": s.restart(); break; case "finish": s.finish(); break; case "init": s.init(); break; case "setPosition": s.setPosition(parseFloat(r[0])); break; case "destroy": this.destroy(t) } } } const Px = "ng-animate-queued", Lx = "ng-animate-disabled", Vx = ".ng-animate-disabled", DG = [], Bx = { namespaceId: "", setForRemoval: !1, setForMove: !1, hasAnimation: !1, removedBeforeQueried: !1 }, xG = { namespaceId: "", setForMove: !1, setForRemoval: !1, hasAnimation: !1, removedBeforeQueried: !0 }, mn = "__ng_removed"; class lg { constructor(t, e = "") { this.namespaceId = e; const i = t && t.hasOwnProperty("value"); if (this.value = function (n) { return null != n ? n : null }(i ? t.value : t), i) { const s = Js(t); delete s.value, this.options = s } else this.options = {}; this.options.params || (this.options.params = {}) } get params() { return this.options.params } absorbOptions(t) { const e = t.params; if (e) { const i = this.options.params; Object.keys(e).forEach(r => { null == i[r] && (i[r] = e[r]) }) } } } const Fa = "void", cg = new lg(Fa); class MG { constructor(t, e, i) { this.id = t, this.hostElement = e, this._engine = i, this.players = [], this._triggers = {}, this._queue = [], this._elementListeners = new Map, this._hostClassName = "ng-tns-" + t, _n(e, this._hostClassName) } listen(t, e, i, r) { if (!this._triggers.hasOwnProperty(e)) throw new Error(`Unable to listen on the animation trigger event "${i}" because the animation trigger "${e}" doesn't exist!`); if (null == i || 0 == i.length) throw new Error(`Unable to listen on the animation trigger "${e}" because the provided event is undefined!`); if (!function (n) { return "start" == n || "done" == n }(i)) throw new Error(`The provided animation trigger event "${i}" for the animation trigger "${e}" is not supported!`); const s = Qt(this._elementListeners, t, []), o = { name: e, phase: i, callback: r }; s.push(o); const a = Qt(this._engine.statesByElement, t, {}); return a.hasOwnProperty(e) || (_n(t, Xc), _n(t, Xc + "-" + e), a[e] = cg), () => { this._engine.afterFlush(() => { const l = s.indexOf(o); l >= 0 && s.splice(l, 1), this._triggers[e] || delete a[e] }) } } register(t, e) { return !this._triggers[t] && (this._triggers[t] = e, !0) } _getTrigger(t) { const e = this._triggers[t]; if (!e) throw new Error(`The provided animation trigger "${t}" has not been registered!`); return e } trigger(t, e, i, r = !0) { const s = this._getTrigger(e), o = new ug(this.id, e, t); let a = this._engine.statesByElement.get(t); a || (_n(t, Xc), _n(t, Xc + "-" + e), this._engine.statesByElement.set(t, a = {})); let l = a[e]; const c = new lg(i, this.id); if (!(i && i.hasOwnProperty("value")) && l && c.absorbOptions(l.options), a[e] = c, l || (l = cg), c.value !== Fa && l.value === c.value) { if (!function (n, t) { const e = Object.keys(n), i = Object.keys(t); if (e.length != i.length) return !1; for (let r = 0; r < e.length; r++) { const s = e[r]; if (!t.hasOwnProperty(s) || n[s] !== t[s]) return !1 } return !0 }(l.params, c.params)) { const y = [], _ = s.matchStyles(l.value, l.params, y), b = s.matchStyles(c.value, c.params, y); y.length ? this._engine.reportError(y) : this._engine.afterFlush(() => { kr(t, _), ti(t, b) }) } return } const f = Qt(this._engine.playersByElement, t, []); f.forEach(y => { y.namespaceId == this.id && y.triggerName == e && y.queued && y.destroy() }); let h = s.matchTransition(l.value, c.value, t, c.params), p = !1; if (!h) { if (!r) return; h = s.fallbackTransition, p = !0 } return this._engine.totalQueuedPlayers++, this._queue.push({ element: t, triggerName: e, transition: h, fromState: l, toState: c, player: o, isFallbackTransition: p }), p || (_n(t, Px), o.onStart(() => { Zs(t, Px) })), o.onDone(() => { let y = this.players.indexOf(o); y >= 0 && this.players.splice(y, 1); const _ = this._engine.playersByElement.get(t); if (_) { let b = _.indexOf(o); b >= 0 && _.splice(b, 1) } }), this.players.push(o), f.push(o), o } deregister(t) { delete this._triggers[t], this._engine.statesByElement.forEach((e, i) => { delete e[t] }), this._elementListeners.forEach((e, i) => { this._elementListeners.set(i, e.filter(r => r.name != t)) }) } clearElementCache(t) { this._engine.statesByElement.delete(t), this._elementListeners.delete(t); const e = this._engine.playersByElement.get(t); e && (e.forEach(i => i.destroy()), this._engine.playersByElement.delete(t)) } _signalRemovalForInnerTriggers(t, e) { const i = this._engine.driver.query(t, eu, !0); i.forEach(r => { if (r[mn]) return; const s = this._engine.fetchNamespacesByElement(r); s.size ? s.forEach(o => o.triggerLeaveAnimation(r, e, !1, !0)) : this.clearElementCache(r) }), this._engine.afterFlushAnimationsDone(() => i.forEach(r => this.clearElementCache(r))) } triggerLeaveAnimation(t, e, i, r) { const s = this._engine.statesByElement.get(t); if (s) { const o = []; if (Object.keys(s).forEach(a => { if (this._triggers[a]) { const l = this.trigger(t, a, Fa, r); l && o.push(l) } }), o.length) return this._engine.markElementAsRemoved(this.id, t, !0, e), i && qi(o).onDone(() => this._engine.processLeaveNode(t)), !0 } return !1 } prepareLeaveAnimationListeners(t) { const e = this._elementListeners.get(t), i = this._engine.statesByElement.get(t); if (e && i) { const r = new Set; e.forEach(s => { const o = s.name; if (r.has(o)) return; r.add(o); const l = this._triggers[o].fallbackTransition, c = i[o] || cg, u = new lg(Fa), d = new ug(this.id, o, t); this._engine.totalQueuedPlayers++, this._queue.push({ element: t, triggerName: o, transition: l, fromState: c, toState: u, player: d, isFallbackTransition: !0 }) }) } } removeNode(t, e) { const i = this._engine; if (t.childElementCount && this._signalRemovalForInnerTriggers(t, e), this.triggerLeaveAnimation(t, e, !0)) return; let r = !1; if (i.totalAnimations) { const s = i.players.length ? i.playersByQueriedElement.get(t) : []; if (s && s.length) r = !0; else { let o = t; for (; o = o.parentNode;)if (i.statesByElement.get(o)) { r = !0; break } } } if (this.prepareLeaveAnimationListeners(t), r) i.markElementAsRemoved(this.id, t, !1, e); else { const s = t[mn]; (!s || s === Bx) && (i.afterFlush(() => this.clearElementCache(t)), i.destroyInnerAnimations(t), i._onRemovalComplete(t, e)) } } insertNode(t, e) { _n(t, this._hostClassName) } drainQueuedTransitions(t) { const e = []; return this._queue.forEach(i => { const r = i.player; if (r.destroyed) return; const s = i.element, o = this._elementListeners.get(s); o && o.forEach(a => { if (a.name == i.triggerName) { const l = Gp(s, i.triggerName, i.fromState.value, i.toState.value); l._data = t, Hp(i.player, a.phase, l, a.callback) } }), r.markedForDestroy ? this._engine.afterFlush(() => { r.destroy() }) : e.push(i) }), this._queue = [], e.sort((i, r) => { const s = i.transition.ast.depCount, o = r.transition.ast.depCount; return 0 == s || 0 == o ? s - o : this._engine.driver.containsElement(i.element, r.element) ? 1 : -1 }) } destroy(t) { this.players.forEach(e => e.destroy()), this._signalRemovalForInnerTriggers(this.hostElement, t) } elementContainsData(t) { let e = !1; return this._elementListeners.has(t) && (e = !0), e = !!this._queue.find(i => i.element === t) || e, e } } class AG { constructor(t, e, i) { this.bodyNode = t, this.driver = e, this._normalizer = i, this.players = [], this.newHostElements = new Map, this.playersByElement = new Map, this.playersByQueriedElement = new Map, this.statesByElement = new Map, this.disabledNodes = new Set, this.totalAnimations = 0, this.totalQueuedPlayers = 0, this._namespaceLookup = {}, this._namespaceList = [], this._flushFns = [], this._whenQuietFns = [], this.namespacesByHostElement = new Map, this.collectedEnterElements = [], this.collectedLeaveElements = [], this.onRemovalComplete = (r, s) => { } } _onRemovalComplete(t, e) { this.onRemovalComplete(t, e) } get queuedPlayers() { const t = []; return this._namespaceList.forEach(e => { e.players.forEach(i => { i.queued && t.push(i) }) }), t } createNamespace(t, e) { const i = new MG(t, e, this); return this.bodyNode && this.driver.containsElement(this.bodyNode, e) ? this._balanceNamespaceList(i, e) : (this.newHostElements.set(e, i), this.collectEnterElement(e)), this._namespaceLookup[t] = i } _balanceNamespaceList(t, e) { const i = this._namespaceList.length - 1; if (i >= 0) { let r = !1; for (let s = i; s >= 0; s--)if (this.driver.containsElement(this._namespaceList[s].hostElement, e)) { this._namespaceList.splice(s + 1, 0, t), r = !0; break } r || this._namespaceList.splice(0, 0, t) } else this._namespaceList.push(t); return this.namespacesByHostElement.set(e, t), t } register(t, e) { let i = this._namespaceLookup[t]; return i || (i = this.createNamespace(t, e)), i } registerTrigger(t, e, i) { let r = this._namespaceLookup[t]; r && r.register(e, i) && this.totalAnimations++ } destroy(t, e) { if (!t) return; const i = this._fetchNamespace(t); this.afterFlush(() => { this.namespacesByHostElement.delete(i.hostElement), delete this._namespaceLookup[t]; const r = this._namespaceList.indexOf(i); r >= 0 && this._namespaceList.splice(r, 1) }), this.afterFlushAnimationsDone(() => i.destroy(e)) } _fetchNamespace(t) { return this._namespaceLookup[t] } fetchNamespacesByElement(t) { const e = new Set, i = this.statesByElement.get(t); if (i) { const r = Object.keys(i); for (let s = 0; s < r.length; s++) { const o = i[r[s]].namespaceId; if (o) { const a = this._fetchNamespace(o); a && e.add(a) } } } return e } trigger(t, e, i, r) { if (du(e)) { const s = this._fetchNamespace(t); if (s) return s.trigger(e, i, r), !0 } return !1 } insertNode(t, e, i, r) { if (!du(e)) return; const s = e[mn]; if (s && s.setForRemoval) { s.setForRemoval = !1, s.setForMove = !0; const o = this.collectedLeaveElements.indexOf(e); o >= 0 && this.collectedLeaveElements.splice(o, 1) } if (t) { const o = this._fetchNamespace(t); o && o.insertNode(e, i) } r && this.collectEnterElement(e) } collectEnterElement(t) { this.collectedEnterElements.push(t) } markElementAsDisabled(t, e) { e ? this.disabledNodes.has(t) || (this.disabledNodes.add(t), _n(t, Lx)) : this.disabledNodes.has(t) && (this.disabledNodes.delete(t), Zs(t, Lx)) } removeNode(t, e, i, r) { if (du(e)) { const s = t ? this._fetchNamespace(t) : null; if (s ? s.removeNode(e, r) : this.markElementAsRemoved(t, e, !1, r), i) { const o = this.namespacesByHostElement.get(e); o && o.id !== t && o.removeNode(e, r) } } else this._onRemovalComplete(e, r) } markElementAsRemoved(t, e, i, r) { this.collectedLeaveElements.push(e), e[mn] = { namespaceId: t, setForRemoval: r, hasAnimation: i, removedBeforeQueried: !1 } } listen(t, e, i, r, s) { return du(e) ? this._fetchNamespace(t).listen(e, i, r, s) : () => { } } _buildInstruction(t, e, i, r, s) { return t.transition.build(this.driver, t.element, t.fromState.value, t.toState.value, i, r, t.fromState.options, t.toState.options, e, s) } destroyInnerAnimations(t) { let e = this.driver.query(t, eu, !0); e.forEach(i => this.destroyActiveAnimationsForElement(i)), 0 != this.playersByQueriedElement.size && (e = this.driver.query(t, Yp, !0), e.forEach(i => this.finishActiveQueriedAnimationOnElement(i))) } destroyActiveAnimationsForElement(t) { const e = this.playersByElement.get(t); e && e.forEach(i => { i.queued ? i.markedForDestroy = !0 : i.destroy() }) } finishActiveQueriedAnimationOnElement(t) { const e = this.playersByQueriedElement.get(t); e && e.forEach(i => i.finish()) } whenRenderingDone() { return new Promise(t => { if (this.players.length) return qi(this.players).onDone(() => t()); t() }) } processLeaveNode(t) { const e = t[mn]; if (e && e.setForRemoval) { if (t[mn] = Bx, e.namespaceId) { this.destroyInnerAnimations(t); const i = this._fetchNamespace(e.namespaceId); i && i.clearElementCache(t) } this._onRemovalComplete(t, e.setForRemoval) } this.driver.matchesElement(t, Vx) && this.markElementAsDisabled(t, !1), this.driver.query(t, Vx, !0).forEach(i => { this.markElementAsDisabled(i, !1) }) } flush(t = -1) { let e = []; if (this.newHostElements.size && (this.newHostElements.forEach((i, r) => this._balanceNamespaceList(i, r)), this.newHostElements.clear()), this.totalAnimations && this.collectedEnterElements.length) for (let i = 0; i < this.collectedEnterElements.length; i++)_n(this.collectedEnterElements[i], "ng-star-inserted"); if (this._namespaceList.length && (this.totalQueuedPlayers || this.collectedLeaveElements.length)) { const i = []; try { e = this._flushAnimations(i, t) } finally { for (let r = 0; r < i.length; r++)i[r]() } } else for (let i = 0; i < this.collectedLeaveElements.length; i++)this.processLeaveNode(this.collectedLeaveElements[i]); if (this.totalQueuedPlayers = 0, this.collectedEnterElements.length = 0, this.collectedLeaveElements.length = 0, this._flushFns.forEach(i => i()), this._flushFns = [], this._whenQuietFns.length) { const i = this._whenQuietFns; this._whenQuietFns = [], e.length ? qi(e).onDone(() => { i.forEach(r => r()) }) : i.forEach(r => r()) } } reportError(t) { throw new Error(`Unable to process animations due to the following failed trigger transitions\n ${t.join("\n")}`) } _flushAnimations(t, e) { const i = new lu, r = [], s = new Map, o = [], a = new Map, l = new Map, c = new Map, u = new Set; this.disabledNodes.forEach(R => { u.add(R); const V = this.driver.query(R, ".ng-animate-queued", !0); for (let Y = 0; Y < V.length; Y++)u.add(V[Y]) }); const d = this.bodyNode, f = Array.from(this.statesByElement.keys()), h = Gx(f, this.collectedEnterElements), p = new Map; let y = 0; h.forEach((R, V) => { const Y = Qp + y++; p.set(V, Y), R.forEach(fe => _n(fe, Y)) }); const _ = [], b = new Set, v = new Set; for (let R = 0; R < this.collectedLeaveElements.length; R++) { const V = this.collectedLeaveElements[R], Y = V[mn]; Y && Y.setForRemoval && (_.push(V), b.add(V), Y.hasAnimation ? this.driver.query(V, ".ng-star-inserted", !0).forEach(fe => b.add(fe)) : v.add(V)) } const S = new Map, I = Gx(f, Array.from(b)); I.forEach((R, V) => { const Y = Zc + y++; S.set(V, Y), R.forEach(fe => _n(fe, Y)) }), t.push(() => { h.forEach((R, V) => { const Y = p.get(V); R.forEach(fe => Zs(fe, Y)) }), I.forEach((R, V) => { const Y = S.get(V); R.forEach(fe => Zs(fe, Y)) }), _.forEach(R => { this.processLeaveNode(R) }) }); const U = [], be = []; for (let R = this._namespaceList.length - 1; R >= 0; R--)this._namespaceList[R].drainQueuedTransitions(e).forEach(Y => { const fe = Y.player, ht = Y.element; if (U.push(fe), this.collectedEnterElements.length) { const ii = ht[mn]; if (ii && ii.setForMove) return void fe.destroy() } const ni = !d || !this.driver.containsElement(d, ht), Jt = S.get(ht), Xi = p.get(ht), $e = this._buildInstruction(Y, i, Xi, Jt, ni); if ($e.errors && $e.errors.length) be.push($e); else { if (ni) return fe.onStart(() => kr(ht, $e.fromStyles)), fe.onDestroy(() => ti(ht, $e.toStyles)), void r.push(fe); if (Y.isFallbackTransition) return fe.onStart(() => kr(ht, $e.fromStyles)), fe.onDestroy(() => ti(ht, $e.toStyles)), void r.push(fe); $e.timelines.forEach(ii => ii.stretchStartingKeyframe = !0), i.append(ht, $e.timelines), o.push({ instruction: $e, player: fe, element: ht }), $e.queriedElements.forEach(ii => Qt(a, ii, []).push(fe)), $e.preStyleProps.forEach((ii, La) => { const Tu = Object.keys(ii); if (Tu.length) { let Br = l.get(La); Br || l.set(La, Br = new Set), Tu.forEach(kg => Br.add(kg)) } }), $e.postStyleProps.forEach((ii, La) => { const Tu = Object.keys(ii); let Br = c.get(La); Br || c.set(La, Br = new Set), Tu.forEach(kg => Br.add(kg)) }) } }); if (be.length) { const R = []; be.forEach(V => { R.push(`@${V.triggerName} has failed due to:\n`), V.errors.forEach(Y => R.push(`- ${Y}\n`)) }), U.forEach(V => V.destroy()), this.reportError(R) } const De = new Map, Ot = new Map; o.forEach(R => { const V = R.element; i.has(V) && (Ot.set(V, V), this._beforeAnimationBuild(R.player.namespaceId, R.instruction, De)) }), r.forEach(R => { const V = R.element; this._getPreviousPlayers(V, !1, R.namespaceId, R.triggerName, null).forEach(fe => { Qt(De, V, []).push(fe), fe.destroy() }) }); const wt = _.filter(R => Ux(R, l, c)), Et = new Map; jx(Et, this.driver, v, c, bi).forEach(R => { Ux(R, l, c) && wt.push(R) }); const Di = new Map; h.forEach((R, V) => { jx(Di, this.driver, new Set(R), l, "!") }), wt.forEach(R => { const V = Et.get(R), Y = Di.get(R); Et.set(R, Object.assign(Object.assign({}, V), Y)) }); const Bn = [], no = [], io = {}; o.forEach(R => { const { element: V, player: Y, instruction: fe } = R; if (i.has(V)) { if (u.has(V)) return Y.onDestroy(() => ti(V, fe.toStyles)), Y.disabled = !0, Y.overrideTotalTime(fe.totalTime), void r.push(Y); let ht = io; if (Ot.size > 1) { let Jt = V; const Xi = []; for (; Jt = Jt.parentNode;) { const $e = Ot.get(Jt); if ($e) { ht = $e; break } Xi.push(Jt) } Xi.forEach($e => Ot.set($e, ht)) } const ni = this._buildAnimation(Y.namespaceId, fe, De, s, Di, Et); if (Y.setRealPlayer(ni), ht === io) Bn.push(Y); else { const Jt = this.playersByElement.get(ht); Jt && Jt.length && (Y.parentPlayer = qi(Jt)), r.push(Y) } } else kr(V, fe.fromStyles), Y.onDestroy(() => ti(V, fe.toStyles)), no.push(Y), u.has(V) && r.push(Y) }), no.forEach(R => { const V = s.get(R.element); if (V && V.length) { const Y = qi(V); R.setRealPlayer(Y) } }), r.forEach(R => { R.parentPlayer ? R.syncPlayerEvents(R.parentPlayer) : R.destroy() }); for (let R = 0; R < _.length; R++) { const V = _[R], Y = V[mn]; if (Zs(V, Zc), Y && Y.hasAnimation) continue; let fe = []; if (a.size) { let ni = a.get(V); ni && ni.length && fe.push(...ni); let Jt = this.driver.query(V, Yp, !0); for (let Xi = 0; Xi < Jt.length; Xi++) { let $e = a.get(Jt[Xi]); $e && $e.length && fe.push(...$e) } } const ht = fe.filter(ni => !ni.destroyed); ht.length ? FG(this, V, ht) : this.processLeaveNode(V) } return _.length = 0, Bn.forEach(R => { this.players.push(R), R.onDone(() => { R.destroy(); const V = this.players.indexOf(R); this.players.splice(V, 1) }), R.play() }), Bn } elementContainsData(t, e) { let i = !1; const r = e[mn]; return r && r.setForRemoval && (i = !0), this.playersByElement.has(e) && (i = !0), this.playersByQueriedElement.has(e) && (i = !0), this.statesByElement.has(e) && (i = !0), this._fetchNamespace(t).elementContainsData(e) || i } afterFlush(t) { this._flushFns.push(t) } afterFlushAnimationsDone(t) { this._whenQuietFns.push(t) } _getPreviousPlayers(t, e, i, r, s) { let o = []; if (e) { const a = this.playersByQueriedElement.get(t); a && (o = a) } else { const a = this.playersByElement.get(t); if (a) { const l = !s || s == Fa; a.forEach(c => { c.queued || !l && c.triggerName != r || o.push(c) }) } } return (i || r) && (o = o.filter(a => !(i && i != a.namespaceId || r && r != a.triggerName))), o } _beforeAnimationBuild(t, e, i) { const s = e.element, o = e.isRemovalTransition ? void 0 : t, a = e.isRemovalTransition ? void 0 : e.triggerName; for (const l of e.timelines) { const c = l.element, u = c !== s, d = Qt(i, c, []); this._getPreviousPlayers(c, u, o, a, e.toState).forEach(h => { const p = h.getRealPlayer(); p.beforeDestroy && p.beforeDestroy(), h.destroy(), d.push(h) }) } kr(s, e.fromStyles) } _buildAnimation(t, e, i, r, s, o) { const a = e.triggerName, l = e.element, c = [], u = new Set, d = new Set, f = e.timelines.map(p => { const y = p.element; u.add(y); const _ = y[mn]; if (_ && _.removedBeforeQueried) return new Ys(p.duration, p.delay); const b = y !== l, v = function (n) { const t = []; return $x(n, t), t }((i.get(y) || DG).map(De => De.getRealPlayer())).filter(De => !!De.element && De.element === y), S = s.get(y), I = o.get(y), U = px(0, this._normalizer, 0, p.keyframes, S, I), be = this._buildPlayer(p, U, v); if (p.subTimeline && r && d.add(y), b) { const De = new ug(t, a, y); De.setRealPlayer(be), c.push(De) } return be }); c.forEach(p => { Qt(this.playersByQueriedElement, p.element, []).push(p), p.onDone(() => function (n, t, e) { let i; if (n instanceof Map) { if (i = n.get(t), i) { if (i.length) { const r = i.indexOf(e); i.splice(r, 1) } 0 == i.length && n.delete(t) } } else if (i = n[t], i) { if (i.length) { const r = i.indexOf(e); i.splice(r, 1) } 0 == i.length && delete n[t] } return i }(this.playersByQueriedElement, p.element, p)) }), u.forEach(p => _n(p, wx)); const h = qi(f); return h.onDestroy(() => { u.forEach(p => Zs(p, wx)), ti(l, e.toStyles) }), d.forEach(p => { Qt(r, p, []).push(h) }), h } _buildPlayer(t, e, i) { return e.length > 0 ? this.driver.animate(t.element, e, t.duration, t.delay, t.easing, i) : new Ys(t.duration, t.delay) } } class ug { constructor(t, e, i) { this.namespaceId = t, this.triggerName = e, this.element = i, this._player = new Ys, this._containsRealPlayer = !1, this._queuedCallbacks = {}, this.destroyed = !1, this.markedForDestroy = !1, this.disabled = !1, this.queued = !0, this.totalTime = 0 } setRealPlayer(t) { this._containsRealPlayer || (this._player = t, Object.keys(this._queuedCallbacks).forEach(e => { this._queuedCallbacks[e].forEach(i => Hp(t, e, void 0, i)) }), this._queuedCallbacks = {}, this._containsRealPlayer = !0, this.overrideTotalTime(t.totalTime), this.queued = !1) } getRealPlayer() { return this._player } overrideTotalTime(t) { this.totalTime = t } syncPlayerEvents(t) { const e = this._player; e.triggerCallback && t.onStart(() => e.triggerCallback("start")), t.onDone(() => this.finish()), t.onDestroy(() => this.destroy()) } _queueEvent(t, e) { Qt(this._queuedCallbacks, t, []).push(e) } onDone(t) { this.queued && this._queueEvent("done", t), this._player.onDone(t) } onStart(t) { this.queued && this._queueEvent("start", t), this._player.onStart(t) } onDestroy(t) { this.queued && this._queueEvent("destroy", t), this._player.onDestroy(t) } init() { this._player.init() } hasStarted() { return !this.queued && this._player.hasStarted() } play() { !this.queued && this._player.play() } pause() { !this.queued && this._player.pause() } restart() { !this.queued && this._player.restart() } finish() { this._player.finish() } destroy() { this.destroyed = !0, this._player.destroy() } reset() { !this.queued && this._player.reset() } setPosition(t) { this.queued || this._player.setPosition(t) } getPosition() { return this.queued ? 0 : this._player.getPosition() } triggerCallback(t) { const e = this._player; e.triggerCallback && e.triggerCallback(t) } } function du(n) { return n && 1 === n.nodeType } function Hx(n, t) { const e = n.style.display; return n.style.display = null != t ? t : "none", e } function jx(n, t, e, i, r) { const s = []; e.forEach(l => s.push(Hx(l))); const o = []; i.forEach((l, c) => { const u = {}; l.forEach(d => { const f = u[d] = t.computeStyle(c, d, r); (!f || 0 == f.length) && (c[mn] = xG, o.push(c)) }), n.set(c, u) }); let a = 0; return e.forEach(l => Hx(l, s[a++])), o } function Gx(n, t) { const e = new Map; if (n.forEach(a => e.set(a, [])), 0 == t.length) return e; const r = new Set(t), s = new Map; function o(a) { if (!a) return 1; let l = s.get(a); if (l) return l; const c = a.parentNode; return l = e.has(c) ? c : r.has(c) ? 1 : o(c), s.set(a, l), l } return t.forEach(a => { const l = o(a); 1 !== l && e.get(l).push(a) }), e } const fu = "$$classes"; function _n(n, t) { if (n.classList) n.classList.add(t); else { let e = n[fu]; e || (e = n[fu] = {}), e[t] = !0 } } function Zs(n, t) { if (n.classList) n.classList.remove(t); else { let e = n[fu]; e && delete e[t] } } function FG(n, t, e) { qi(e).onDone(() => n.processLeaveNode(t)) } function $x(n, t) { for (let e = 0; e < n.length; e++) { const i = n[e]; i instanceof fx ? $x(i.players, t) : t.push(i) } } function Ux(n, t, e) { const i = e.get(n); if (!i) return !1; let r = t.get(n); return r ? i.forEach(s => r.add(s)) : t.set(n, i), e.delete(n), !0 } class hu { constructor(t, e, i) { this.bodyNode = t, this._driver = e, this._normalizer = i, this._triggerCache = {}, this.onRemovalComplete = (r, s) => { }, this._transitionEngine = new AG(t, e, i), this._timelineEngine = new bG(t, e, i), this._transitionEngine.onRemovalComplete = (r, s) => this.onRemovalComplete(r, s) } registerTrigger(t, e, i, r, s) { const o = t + "-" + r; let a = this._triggerCache[o]; if (!a) { const l = [], c = tg(this._driver, s, l); if (l.length) throw new Error(`The animation trigger "${r}" has failed to build due to the following errors:\n - ${l.join("\n - ")}`); a = function (n, t, e) { return new _G(n, t, e) }(r, c, this._normalizer), this._triggerCache[o] = a } this._transitionEngine.registerTrigger(e, r, a) } register(t, e) { this._transitionEngine.register(t, e) } destroy(t, e) { this._transitionEngine.destroy(t, e) } onInsert(t, e, i, r) { this._transitionEngine.insertNode(t, e, i, r) } onRemove(t, e, i, r) { this._transitionEngine.removeNode(t, e, r || !1, i) } disableAnimations(t, e) { this._transitionEngine.markElementAsDisabled(t, e) } process(t, e, i, r) { if ("@" == i.charAt(0)) { const [s, o] = gx(i); this._timelineEngine.command(s, e, o, r) } else this._transitionEngine.trigger(t, e, i, r) } listen(t, e, i, r, s) { if ("@" == i.charAt(0)) { const [o, a] = gx(i); return this._timelineEngine.listen(o, e, a, s) } return this._transitionEngine.listen(t, e, i, r, s) } flush(t = -1) { this._transitionEngine.flush(t) } get players() { return this._transitionEngine.players.concat(this._timelineEngine.players) } whenRenderingDone() { return this._transitionEngine.whenRenderingDone() } } function zx(n, t) { let e = null, i = null; return Array.isArray(t) && t.length ? (e = dg(t[0]), t.length > 1 && (i = dg(t[t.length - 1]))) : t && (e = dg(t)), e || i ? new Xs(n, e, i) : null } class Xs { constructor(t, e, i) { this._element = t, this._startStyles = e, this._endStyles = i, this._state = 0; let r = Xs.initialStylesByElement.get(t); r || Xs.initialStylesByElement.set(t, r = {}), this._initialStyles = r } start() { this._state < 1 && (this._startStyles && ti(this._element, this._startStyles, this._initialStyles), this._state = 1) } finish() { this.start(), this._state < 2 && (ti(this._element, this._initialStyles), this._endStyles && (ti(this._element, this._endStyles), this._endStyles = null), this._state = 1) } destroy() { this.finish(), this._state < 3 && (Xs.initialStylesByElement.delete(this._element), this._startStyles && (kr(this._element, this._startStyles), this._endStyles = null), this._endStyles && (kr(this._element, this._endStyles), this._endStyles = null), ti(this._element, this._initialStyles), this._state = 3) } } function dg(n) { let t = null; const e = Object.keys(n); for (let i = 0; i < e.length; i++) { const r = e[i]; OG(r) && (t = t || {}, t[r] = n[r]) } return t } function OG(n) { return "display" === n || "position" === n } Xs.initialStylesByElement = new WeakMap; const Wx = "animation", qx = "animationend"; class LG { constructor(t, e, i, r, s, o, a) { this._element = t, this._name = e, this._duration = i, this._delay = r, this._easing = s, this._fillMode = o, this._onDoneFn = a, this._finished = !1, this._destroyed = !1, this._startTime = 0, this._position = 0, this._eventFn = l => this._handleCallback(l) } apply() { (function (n, t) { const e = hg(n, "").trim(); let i = 0; e.length && (function (n, t) { let e = 0; for (let i = 0; i < n.length; i++)"," === n.charAt(i) && e++; return e }(e) + 1, t = `${e}, ${t}`), pu(n, "", t) })(this._element, `${this._duration}ms ${this._easing} ${this._delay}ms 1 normal ${this._fillMode} ${this._name}`), Yx(this._element, this._eventFn, !1), this._startTime = Date.now() } pause() { Kx(this._element, this._name, "paused") } resume() { Kx(this._element, this._name, "running") } setPosition(t) { const e = Qx(this._element, this._name); this._position = t * this._duration, pu(this._element, "Delay", `-${this._position}ms`, e) } getPosition() { return this._position } _handleCallback(t) { const e = t._ngTestManualTimestamp || Date.now(), i = 1e3 * parseFloat(t.elapsedTime.toFixed(3)); t.animationName == this._name && Math.max(e - this._startTime, 0) >= this._delay && i >= this._duration && this.finish() } finish() { this._finished || (this._finished = !0, this._onDoneFn(), Yx(this._element, this._eventFn, !0)) } destroy() { this._destroyed || (this._destroyed = !0, this.finish(), function (n, t) { const i = hg(n, "").split(","), r = fg(i, t); r >= 0 && (i.splice(r, 1), pu(n, "", i.join(","))) }(this._element, this._name)) } } function Kx(n, t, e) { pu(n, "PlayState", e, Qx(n, t)) } function Qx(n, t) { const e = hg(n, ""); return e.indexOf(",") > 0 ? fg(e.split(","), t) : fg([e], t) } function fg(n, t) { for (let e = 0; e < n.length; e++)if (n[e].indexOf(t) >= 0) return e; return -1 } function Yx(n, t, e) { e ? n.removeEventListener(qx, t) : n.addEventListener(qx, t) } function pu(n, t, e, i) { const r = Wx + t; if (null != i) { const s = n.style[r]; if (s.length) { const o = s.split(","); o[i] = e, e = o.join(",") } } n.style[r] = e } function hg(n, t) { return n.style[Wx + t] || "" } class Jx { constructor(t, e, i, r, s, o, a, l) { this.element = t, this.keyframes = e, this.animationName = i, this._duration = r, this._delay = s, this._finalStyles = a, this._specialStyles = l, this._onDoneFns = [], this._onStartFns = [], this._onDestroyFns = [], this.currentSnapshot = {}, this._state = 0, this.easing = o || "linear", this.totalTime = r + s, this._buildStyler() } onStart(t) { this._onStartFns.push(t) } onDone(t) { this._onDoneFns.push(t) } onDestroy(t) { this._onDestroyFns.push(t) } destroy() { this.init(), !(this._state >= 4) && (this._state = 4, this._styler.destroy(), this._flushStartFns(), this._flushDoneFns(), this._specialStyles && this._specialStyles.destroy(), this._onDestroyFns.forEach(t => t()), this._onDestroyFns = []) } _flushDoneFns() { this._onDoneFns.forEach(t => t()), this._onDoneFns = [] } _flushStartFns() { this._onStartFns.forEach(t => t()), this._onStartFns = [] } finish() { this.init(), !(this._state >= 3) && (this._state = 3, this._styler.finish(), this._flushStartFns(), this._specialStyles && this._specialStyles.finish(), this._flushDoneFns()) } setPosition(t) { this._styler.setPosition(t) } getPosition() { return this._styler.getPosition() } hasStarted() { return this._state >= 2 } init() { this._state >= 1 || (this._state = 1, this._styler.apply(), this._delay && this._styler.pause()) } play() { this.init(), this.hasStarted() || (this._flushStartFns(), this._state = 2, this._specialStyles && this._specialStyles.start()), this._styler.resume() } pause() { this.init(), this._styler.pause() } restart() { this.reset(), this.play() } reset() { this._state = 0, this._styler.destroy(), this._buildStyler(), this._styler.apply() } _buildStyler() { this._styler = new LG(this.element, this.animationName, this._duration, this._delay, this.easing, "forwards", () => this.finish()) } triggerCallback(t) { const e = "start" == t ? this._onStartFns : this._onDoneFns; e.forEach(i => i()), e.length = 0 } beforeDestroy() { this.init(); const t = {}; if (this.hasStarted()) { const e = this._state >= 3; Object.keys(this._finalStyles).forEach(i => { "offset" != i && (t[i] = e ? this._finalStyles[i] : eg(this.element, i)) }) } this.currentSnapshot = t } } class $G extends Ys { constructor(t, e) { super(), this.element = t, this._startingStyles = {}, this.__initialized = !1, this._styles = vx(e) } init() { this.__initialized || !this._startingStyles || (this.__initialized = !0, Object.keys(this._styles).forEach(t => { this._startingStyles[t] = this.element.style[t] }), super.init()) } play() { !this._startingStyles || (this.init(), Object.keys(this._styles).forEach(t => this.element.style.setProperty(t, this._styles[t])), super.play()) } destroy() { !this._startingStyles || (Object.keys(this._startingStyles).forEach(t => { const e = this._startingStyles[t]; e ? this.element.style.setProperty(t, e) : this.element.style.removeProperty(t) }), this._startingStyles = null, super.destroy()) } } class Xx { constructor() { this._count = 0 } validateStyleProperty(t) { return zp(t) } matchesElement(t, e) { return Wp(t, e) } containsElement(t, e) { return qp(t, e) } query(t, e, i) { return Kp(t, e, i) } computeStyle(t, e, i) { return window.getComputedStyle(t)[e] } buildKeyframeElement(t, e, i) { i = i.map(a => vx(a)); let r = `@keyframes ${e} {\n`, s = ""; i.forEach(a => { s = " "; const l = parseFloat(a.offset); r += `${s}${100 * l}% {\n`, s += " ", Object.keys(a).forEach(c => { const u = a[c]; switch (c) { case "offset": return; case "easing": return void (u && (r += `${s}animation-timing-function: ${u};\n`)); default: return void (r += `${s}${c}: ${u};\n`) } }), r += `${s}}\n` }), r += "}\n"; const o = document.createElement("style"); return o.textContent = r, o } animate(t, e, i, r, s, o = [], a) { const l = o.filter(_ => _ instanceof Jx), c = {}; Ax(i, r) && l.forEach(_ => { let b = _.currentSnapshot; Object.keys(b).forEach(v => c[v] = b[v]) }); const u = function (n) { let t = {}; return n && (Array.isArray(n) ? n : [n]).forEach(i => { Object.keys(i).forEach(r => { "offset" == r || "easing" == r || (t[r] = i[r]) }) }), t }(e = Sx(t, e, c)); if (0 == i) return new $G(t, u); const d = "gen_css_kf_" + this._count++, f = this.buildKeyframeElement(t, d, e); (function (n) { var t; const e = null === (t = n.getRootNode) || void 0 === t ? void 0 : t.call(n); return "undefined" != typeof ShadowRoot && e instanceof ShadowRoot ? e : document.head })(t).appendChild(f); const p = zx(t, e), y = new Jx(t, e, d, i, r, s, u, p); return y.onDestroy(() => function (n) { n.parentNode.removeChild(n) }(f)), y } } class tM { constructor(t, e, i, r) { this.element = t, this.keyframes = e, this.options = i, this._specialStyles = r, this._onDoneFns = [], this._onStartFns = [], this._onDestroyFns = [], this._initialized = !1, this._finished = !1, this._started = !1, this._destroyed = !1, this.time = 0, this.parentPlayer = null, this.currentSnapshot = {}, this._duration = i.duration, this._delay = i.delay || 0, this.time = this._duration + this._delay } _onFinish() { this._finished || (this._finished = !0, this._onDoneFns.forEach(t => t()), this._onDoneFns = []) } init() { this._buildPlayer(), this._preparePlayerBeforeStart() } _buildPlayer() { if (this._initialized) return; this._initialized = !0; const t = this.keyframes; this.domPlayer = this._triggerWebAnimation(this.element, t, this.options), this._finalKeyframe = t.length ? t[t.length - 1] : {}, this.domPlayer.addEventListener("finish", () => this._onFinish()) } _preparePlayerBeforeStart() { this._delay ? this._resetDomPlayerState() : this.domPlayer.pause() } _triggerWebAnimation(t, e, i) { return t.animate(e, i) } onStart(t) { this._onStartFns.push(t) } onDone(t) { this._onDoneFns.push(t) } onDestroy(t) { this._onDestroyFns.push(t) } play() { this._buildPlayer(), this.hasStarted() || (this._onStartFns.forEach(t => t()), this._onStartFns = [], this._started = !0, this._specialStyles && this._specialStyles.start()), this.domPlayer.play() } pause() { this.init(), this.domPlayer.pause() } finish() { this.init(), this._specialStyles && this._specialStyles.finish(), this._onFinish(), this.domPlayer.finish() } reset() { this._resetDomPlayerState(), this._destroyed = !1, this._finished = !1, this._started = !1 } _resetDomPlayerState() { this.domPlayer && this.domPlayer.cancel() } restart() { this.reset(), this.play() } hasStarted() { return this._started } destroy() { this._destroyed || (this._destroyed = !0, this._resetDomPlayerState(), this._onFinish(), this._specialStyles && this._specialStyles.destroy(), this._onDestroyFns.forEach(t => t()), this._onDestroyFns = []) } setPosition(t) { void 0 === this.domPlayer && this.init(), this.domPlayer.currentTime = t * this.time } getPosition() { return this.domPlayer.currentTime / this.time } get totalTime() { return this._delay + this._duration } beforeDestroy() { const t = {}; this.hasStarted() && Object.keys(this._finalKeyframe).forEach(e => { "offset" != e && (t[e] = this._finished ? this._finalKeyframe[e] : eg(this.element, e)) }), this.currentSnapshot = t } triggerCallback(t) { const e = "start" == t ? this._onStartFns : this._onDoneFns; e.forEach(i => i()), e.length = 0 } } class KG { constructor() { this._isNativeImpl = /\{\s*\[native\s+code\]\s*\}/.test(nM().toString()), this._cssKeyframesDriver = new Xx } validateStyleProperty(t) { return zp(t) } matchesElement(t, e) { return Wp(t, e) } containsElement(t, e) { return qp(t, e) } query(t, e, i) { return Kp(t, e, i) } computeStyle(t, e, i) { return window.getComputedStyle(t)[e] } overrideWebAnimationsSupport(t) { this._isNativeImpl = t } animate(t, e, i, r, s, o = [], a) { if (!a && !this._isNativeImpl) return this._cssKeyframesDriver.animate(t, e, i, r, s, o); const u = { duration: i, delay: r, fill: 0 == r ? "both" : "forwards" }; s && (u.easing = s); const d = {}, f = o.filter(p => p instanceof tM); Ax(i, r) && f.forEach(p => { let y = p.currentSnapshot; Object.keys(y).forEach(_ => d[_] = y[_]) }); const h = zx(t, e = Sx(t, e = e.map(p => Ki(p, !1)), d)); return new tM(t, e, u, h) } } function nM() { return hx() && Element.prototype.animate || {} } let YG = (() => { class n extends lx { constructor(e, i) { super(), this._nextAnimationId = 0, this._renderer = e.createRenderer(i.body, { id: "0", encapsulation: qe.None, styles: [], data: { animation: [] } }) } build(e) { const i = this._nextAnimationId.toString(); this._nextAnimationId++; const r = Array.isArray(e) ? ux(e) : e; return iM(this._renderer, null, i, "register", [r]), new JG(i, this._renderer) } } return n.\u0275fac = function (e) { return new (e || n)(m(mr), m(N)) }, n.\u0275prov = E({ token: n, factory: n.\u0275fac }), n })(); class JG extends class { }{ constructor(t, e) { super(), this._id = t, this._renderer = e } create(t, e) { return new ZG(this._id, t, e || {}, this._renderer) } } class ZG { constructor(t, e, i, r) { this.id = t, this.element = e, this._renderer = r, this.parentPlayer = null, this._started = !1, this.totalTime = 0, this._command("create", i) } _listen(t, e) { return this._renderer.listen(this.element, `@@${this.id}:${t}`, e) } _command(t, ...e) { return iM(this._renderer, this.element, this.id, t, e) } onDone(t) { this._listen("done", t) } onStart(t) { this._listen("start", t) } onDestroy(t) { this._listen("destroy", t) } init() { this._command("init") } hasStarted() { return this._started } play() { this._command("play"), this._started = !0 } pause() { this._command("pause") } restart() { this._command("restart") } finish() { this._command("finish") } destroy() { this._command("destroy") } reset() { this._command("reset"), this._started = !1 } setPosition(t) { this._command("setPosition", t) } getPosition() { var t, e; return null !== (e = null === (t = this._renderer.engine.players[+this.id]) || void 0 === t ? void 0 : t.getPosition()) && void 0 !== e ? e : 0 } } function iM(n, t, e, i, r) { return n.setProperty(t, `@@${e}:${i}`, r) } const rM = "@.disabled"; let XG = (() => { class n { constructor(e, i, r) { this.delegate = e, this.engine = i, this._zone = r, this._currentId = 0, this._microtaskId = 1, this._animationCallbacksBuffer = [], this._rendererCache = new Map, this._cdRecurDepth = 0, this.promise = Promise.resolve(0), i.onRemovalComplete = (s, o) => { o && o.parentNode(s) && o.removeChild(s.parentNode, s) } } createRenderer(e, i) { const s = this.delegate.createRenderer(e, i); if (!(e && i && i.data && i.data.animation)) { let u = this._rendererCache.get(s); return u || (u = new sM("", s, this.engine), this._rendererCache.set(s, u)), u } const o = i.id, a = i.id + "-" + this._currentId; this._currentId++, this.engine.register(a, e); const l = u => { Array.isArray(u) ? u.forEach(l) : this.engine.registerTrigger(o, a, e, u.name, u) }; return i.data.animation.forEach(l), new e$(this, a, s, this.engine) } begin() { this._cdRecurDepth++, this.delegate.begin && this.delegate.begin() } _scheduleCountTask() { this.promise.then(() => { this._microtaskId++ }) } scheduleListenerCallback(e, i, r) { e >= 0 && e < this._microtaskId ? this._zone.run(() => i(r)) : (0 == this._animationCallbacksBuffer.length && Promise.resolve(null).then(() => { this._zone.run(() => { this._animationCallbacksBuffer.forEach(s => { const [o, a] = s; o(a) }), this._animationCallbacksBuffer = [] }) }), this._animationCallbacksBuffer.push([i, r])) } end() { this._cdRecurDepth--, 0 == this._cdRecurDepth && this._zone.runOutsideAngular(() => { this._scheduleCountTask(), this.engine.flush(this._microtaskId) }), this.delegate.end && this.delegate.end() } whenRenderingDone() { return this.engine.whenRenderingDone() } } return n.\u0275fac = function (e) { return new (e || n)(m(mr), m(hu), m(H)) }, n.\u0275prov = E({ token: n, factory: n.\u0275fac }), n })(); class sM { constructor(t, e, i) { this.namespaceId = t, this.delegate = e, this.engine = i, this.destroyNode = this.delegate.destroyNode ? r => e.destroyNode(r) : null } get data() { return this.delegate.data } destroy() { this.engine.destroy(this.namespaceId, this.delegate), this.delegate.destroy() } createElement(t, e) { return this.delegate.createElement(t, e) } createComment(t) { return this.delegate.createComment(t) } createText(t) { return this.delegate.createText(t) } appendChild(t, e) { this.delegate.appendChild(t, e), this.engine.onInsert(this.namespaceId, e, t, !1) } insertBefore(t, e, i, r = !0) { this.delegate.insertBefore(t, e, i), this.engine.onInsert(this.namespaceId, e, t, r) } removeChild(t, e, i) { this.engine.onRemove(this.namespaceId, e, this.delegate, i) } selectRootElement(t, e) { return this.delegate.selectRootElement(t, e) } parentNode(t) { return this.delegate.parentNode(t) } nextSibling(t) { return this.delegate.nextSibling(t) } setAttribute(t, e, i, r) { this.delegate.setAttribute(t, e, i, r) } removeAttribute(t, e, i) { this.delegate.removeAttribute(t, e, i) } addClass(t, e) { this.delegate.addClass(t, e) } removeClass(t, e) { this.delegate.removeClass(t, e) } setStyle(t, e, i, r) { this.delegate.setStyle(t, e, i, r) } removeStyle(t, e, i) { this.delegate.removeStyle(t, e, i) } setProperty(t, e, i) { "@" == e.charAt(0) && e == rM ? this.disableAnimations(t, !!i) : this.delegate.setProperty(t, e, i) } setValue(t, e) { this.delegate.setValue(t, e) } listen(t, e, i) { return this.delegate.listen(t, e, i) } disableAnimations(t, e) { this.engine.disableAnimations(t, e) } } class e$ extends sM { constructor(t, e, i, r) { super(e, i, r), this.factory = t, this.namespaceId = e } setProperty(t, e, i) { "@" == e.charAt(0) ? "." == e.charAt(1) && e == rM ? this.disableAnimations(t, i = void 0 === i || !!i) : this.engine.process(this.namespaceId, t, e.substr(1), i) : this.delegate.setProperty(t, e, i) } listen(t, e, i) { if ("@" == e.charAt(0)) { const r = function (n) { switch (n) { case "body": return document.body; case "document": return document; case "window": return window; default: return n } }(t); let s = e.substr(1), o = ""; return "@" != s.charAt(0) && ([s, o] = function (n) { const t = n.indexOf("."); return [n.substring(0, t), n.substr(t + 1)] }(s)), this.engine.listen(this.namespaceId, r, s, o, a => { this.factory.scheduleListenerCallback(a._data || -1, i, a) }) } return this.delegate.listen(t, e, i) } } let i$ = (() => { class n extends hu { constructor(e, i, r) { super(e.body, i, r) } ngOnDestroy() { this.flush() } } return n.\u0275fac = function (e) { return new (e || n)(m(N), m(Jc), m(og)) }, n.\u0275prov = E({ token: n, factory: n.\u0275fac }), n })(); const Qi = new k("AnimationModuleType"), oM = [{ provide: lx, useClass: YG }, { provide: og, useFactory: function () { return new dG } }, { provide: hu, useClass: i$ }, { provide: mr, useFactory: function (n, t, e) { return new XG(n, t, e) }, deps: [Sc, hu, H] }], aM = [{ provide: Jc, useFactory: function () { return "function" == typeof nM() ? new KG : new Xx } }, { provide: Qi, useValue: "BrowserAnimations" }, ...oM], lM = [{ provide: Jc, useClass: bx }, { provide: Qi, useValue: "NoopAnimations" }, ...oM]; let a$ = (() => { class n { static withConfig(e) { return { ngModule: n, providers: e.disableAnimations ? lM : aM } } } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275mod = ee({ type: n }), n.\u0275inj = X({ providers: aM, imports: [ep] }), n })(); const cM = new Pi("12.2.1"), p$ = new k("mat-sanity-checks", { providedIn: "root", factory: function () { return !0 } }); let Nr, at = (() => { class n { constructor(e, i, r) { this._hasDoneGlobalChecks = !1, this._document = r, e._applyBodyHighContrastModeCssClasses(), this._sanityChecks = i, this._hasDoneGlobalChecks || (this._checkDoctypeIsDefined(), this._checkThemeIsPresent(), this._checkCdkVersionMatch(), this._hasDoneGlobalChecks = !0) } _getWindow() { const e = this._document.defaultView || window; return "object" == typeof e && e ? e : null } _checkIsEnabled(e) { return !(!mh() || this._isTestEnv()) && ("boolean" == typeof this._sanityChecks ? this._sanityChecks : !!this._sanityChecks[e]) } _isTestEnv() { const e = this._getWindow(); return e && (e.__karma__ || e.jasmine) } _checkDoctypeIsDefined() { this._checkIsEnabled("doctype") && !this._document.doctype && console.warn("Current document does not have a doctype. This may cause some Angular Material components not to behave as expected.") } _checkThemeIsPresent() { if (!this._checkIsEnabled("theme") || !this._document.body || "function" != typeof getComputedStyle) return; const e = this._document.createElement("div"); e.classList.add("mat-theme-loaded-marker"), this._document.body.appendChild(e); const i = getComputedStyle(e); i && "none" !== i.display && console.warn("Could not find Angular Material core theme. Most Material components may not work as expected. For more info refer to the theming guide: https://material.angular.io/guide/theming"), this._document.body.removeChild(e) } _checkCdkVersionMatch() { this._checkIsEnabled("version") && cM.full !== ax.full && console.warn("The Angular Material version (" + cM.full + ") does not match the Angular CDK version (" + ax.full + ").\nPlease ensure the versions of these two packages exactly match.") } } return n.\u0275fac = function (e) { return new (e || n)(m(ox), m(p$, 8), m(N)) }, n.\u0275mod = ee({ type: n }), n.\u0275inj = X({ imports: [[qs], qs] }), n })(); function uM(n) { return class extends n { constructor(...t) { super(...t), this._disabled = !1 } get disabled() { return this._disabled } set disabled(t) { this._disabled = Te(t) } } } function mu(n, t) { return class extends n { constructor(...e) { super(...e), this.defaultColor = t, this.color = t } get color() { return this._color } set color(e) { const i = e || this.defaultColor; i !== this._color && (this._color && this._elementRef.nativeElement.classList.remove(`mat-${this._color}`), i && this._elementRef.nativeElement.classList.add(`mat-${i}`), this._color = i) } } } function g$(n) { return class extends n { constructor(...t) { super(...t), this._disableRipple = !1 } get disableRipple() { return this._disableRipple } set disableRipple(t) { this._disableRipple = Te(t) } } } function m$(n) { return class extends n { constructor(...t) { super(...t), this.stateChanges = new ie, this.errorState = !1 } updateErrorState() { const t = this.errorState, s = (this.errorStateMatcher || this._defaultErrorStateMatcher).isErrorState(this.ngControl ? this.ngControl.control : null, this._parentFormGroup || this._parentForm); s !== t && (this.errorState = s, this.stateChanges.next()) } } } try { Nr = "undefined" != typeof Intl } catch (n) { Nr = !1 } let fM = (() => { class n { isErrorState(e, i) { return !!(e && e.invalid && (e.touched || i && i.submitted)) } } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275prov = E({ factory: function () { return new n }, token: n, providedIn: "root" }), n })(); class S$ { constructor(t, e, i) { this._renderer = t, this.element = e, this.config = i, this.state = 3 } fadeOut() { this._renderer.fadeOutRipple(this) } } const hM = { enterDuration: 225, exitDuration: 150 }, pg = zc({ passive: !0 }), pM = ["mousedown", "touchstart"], gM = ["mouseup", "mouseleave", "touchend", "touchcancel"]; class I$ { constructor(t, e, i, r) { this._target = t, this._ngZone = e, this._isPointerDown = !1, this._activeRipples = new Set, this._pointerUpEventsRegistered = !1, r.isBrowser && (this._containerElement = vi(i)) } fadeInRipple(t, e, i = {}) { const r = this._containerRect = this._containerRect || this._containerElement.getBoundingClientRect(), s = Object.assign(Object.assign({}, hM), i.animation); i.centered && (t = r.left + r.width / 2, e = r.top + r.height / 2); const o = i.radius || function (n, t, e) { const i = Math.max(Math.abs(n - e.left), Math.abs(n - e.right)), r = Math.max(Math.abs(t - e.top), Math.abs(t - e.bottom)); return Math.sqrt(i * i + r * r) }(t, e, r), a = t - r.left, l = e - r.top, c = s.enterDuration, u = document.createElement("div"); u.classList.add("mat-ripple-element"), u.style.left = a - o + "px", u.style.top = l - o + "px", u.style.height = 2 * o + "px", u.style.width = 2 * o + "px", null != i.color && (u.style.backgroundColor = i.color), u.style.transitionDuration = `${c}ms`, this._containerElement.appendChild(u), function (n) { window.getComputedStyle(n).getPropertyValue("opacity") }(u), u.style.transform = "scale(1)"; const d = new S$(this, u, i); return d.state = 0, this._activeRipples.add(d), i.persistent || (this._mostRecentTransientRipple = d), this._runTimeoutOutsideZone(() => { const f = d === this._mostRecentTransientRipple; d.state = 1, !i.persistent && (!f || !this._isPointerDown) && d.fadeOut() }, c), d } fadeOutRipple(t) { const e = this._activeRipples.delete(t); if (t === this._mostRecentTransientRipple && (this._mostRecentTransientRipple = null), this._activeRipples.size || (this._containerRect = null), !e) return; const i = t.element, r = Object.assign(Object.assign({}, hM), t.config.animation); i.style.transitionDuration = `${r.exitDuration}ms`, i.style.opacity = "0", t.state = 2, this._runTimeoutOutsideZone(() => { t.state = 3, i.parentNode.removeChild(i) }, r.exitDuration) } fadeOutAll() { this._activeRipples.forEach(t => t.fadeOut()) } fadeOutAllNonPersistent() { this._activeRipples.forEach(t => { t.config.persistent || t.fadeOut() }) } setupTriggerEvents(t) { const e = vi(t); !e || e === this._triggerElement || (this._removeTriggerEvents(), this._triggerElement = e, this._registerEvents(pM)) } handleEvent(t) { "mousedown" === t.type ? this._onMousedown(t) : "touchstart" === t.type ? this._onTouchStart(t) : this._onPointerUp(), this._pointerUpEventsRegistered || (this._registerEvents(gM), this._pointerUpEventsRegistered = !0) } _onMousedown(t) { const e = YD(t), i = this._lastTouchStartEvent && Date.now() < this._lastTouchStartEvent + 800; !this._target.rippleDisabled && !e && !i && (this._isPointerDown = !0, this.fadeInRipple(t.clientX, t.clientY, this._target.rippleConfig)) } _onTouchStart(t) { if (!this._target.rippleDisabled && !JD(t)) { this._lastTouchStartEvent = Date.now(), this._isPointerDown = !0; const e = t.changedTouches; for (let i = 0; i < e.length; i++)this.fadeInRipple(e[i].clientX, e[i].clientY, this._target.rippleConfig) } } _onPointerUp() { !this._isPointerDown || (this._isPointerDown = !1, this._activeRipples.forEach(t => { !t.config.persistent && (1 === t.state || t.config.terminateOnPointerUp && 0 === t.state) && t.fadeOut() })) } _runTimeoutOutsideZone(t, e = 0) { this._ngZone.runOutsideAngular(() => setTimeout(t, e)) } _registerEvents(t) { this._ngZone.runOutsideAngular(() => { t.forEach(e => { this._triggerElement.addEventListener(e, this, pg) }) }) } _removeTriggerEvents() { this._triggerElement && (pM.forEach(t => { this._triggerElement.removeEventListener(t, this, pg) }), this._pointerUpEventsRegistered && gM.forEach(t => { this._triggerElement.removeEventListener(t, this, pg) })) } } const k$ = new k("mat-ripple-global-options"); let yu = (() => { class n { constructor(e, i, r, s, o) { this._elementRef = e, this._animationMode = o, this.radius = 0, this._disabled = !1, this._isInitialized = !1, this._globalOptions = s || {}, this._rippleRenderer = new I$(this, i, e, r) } get disabled() { return this._disabled } set disabled(e) { e && this.fadeOutAllNonPersistent(), this._disabled = e, this._setupTriggerEventsIfEnabled() } get trigger() { return this._trigger || this._elementRef.nativeElement } set trigger(e) { this._trigger = e, this._setupTriggerEventsIfEnabled() } ngOnInit() { this._isInitialized = !0, this._setupTriggerEventsIfEnabled() } ngOnDestroy() { this._rippleRenderer._removeTriggerEvents() } fadeOutAll() { this._rippleRenderer.fadeOutAll() } fadeOutAllNonPersistent() { this._rippleRenderer.fadeOutAllNonPersistent() } get rippleConfig() { return { centered: this.centered, radius: this.radius, color: this.color, animation: Object.assign(Object.assign(Object.assign({}, this._globalOptions.animation), "NoopAnimations" === this._animationMode ? { enterDuration: 0, exitDuration: 0 } : {}), this.animation), terminateOnPointerUp: this._globalOptions.terminateOnPointerUp } } get rippleDisabled() { return this.disabled || !!this._globalOptions.disabled } _setupTriggerEventsIfEnabled() { !this.disabled && this._isInitialized && this._rippleRenderer.setupTriggerEvents(this.trigger) } launch(e, i = 0, r) { return "number" == typeof e ? this._rippleRenderer.fadeInRipple(e, i, Object.assign(Object.assign({}, this.rippleConfig), r)) : this._rippleRenderer.fadeInRipple(0, 0, Object.assign(Object.assign({}, this.rippleConfig), e)) } } return n.\u0275fac = function (e) { return new (e || n)(g(O), g(H), g(Ce), g(k$, 8), g(Qi, 8)) }, n.\u0275dir = C({ type: n, selectors: [["", "mat-ripple", ""], ["", "matRipple", ""]], hostAttrs: [1, "mat-ripple"], hostVars: 2, hostBindings: function (e, i) { 2 & e && je("mat-ripple-unbounded", i.unbounded) }, inputs: { radius: ["matRippleRadius", "radius"], disabled: ["matRippleDisabled", "disabled"], trigger: ["matRippleTrigger", "trigger"], color: ["matRippleColor", "color"], unbounded: ["matRippleUnbounded", "unbounded"], centered: ["matRippleCentered", "centered"], animation: ["matRippleAnimation", "animation"] }, exportAs: ["matRipple"] }), n })(), mM = (() => { class n { } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275mod = ee({ type: n }), n.\u0275inj = X({ imports: [[at, xa], at] }), n })(); const bM = ["mat-button", ""], CM = ["*"], G$ = ["mat-button", "mat-flat-button", "mat-icon-button", "mat-raised-button", "mat-stroked-button", "mat-mini-fab", "mat-fab"], $$ = mu(uM(g$(class { constructor(n) { this._elementRef = n } }))); let gg = (() => { class n extends $$ { constructor(e, i, r) { super(e), this._focusMonitor = i, this._animationMode = r, this.isRoundButton = this._hasHostAttributes("mat-fab", "mat-mini-fab"), this.isIconButton = this._hasHostAttributes("mat-icon-button"); for (const s of G$) this._hasHostAttributes(s) && this._getHostElement().classList.add(s); e.nativeElement.classList.add("mat-button-base"), this.isRoundButton && (this.color = "accent") } ngAfterViewInit() { this._focusMonitor.monitor(this._elementRef, !0) } ngOnDestroy() { this._focusMonitor.stopMonitoring(this._elementRef) } focus(e, i) { e ? this._focusMonitor.focusVia(this._getHostElement(), e, i) : this._getHostElement().focus(i) } _getHostElement() { return this._elementRef.nativeElement } _isRippleDisabled() { return this.disableRipple || this.disabled } _hasHostAttributes(...e) { return e.some(i => this._getHostElement().hasAttribute(i)) } } return n.\u0275fac = function (e) { return new (e || n)(g(O), g(kp), g(Qi, 8)) }, n.\u0275cmp = tt({ type: n, selectors: [["button", "mat-button", ""], ["button", "mat-raised-button", ""], ["button", "mat-icon-button", ""], ["button", "mat-fab", ""], ["button", "mat-mini-fab", ""], ["button", "mat-stroked-button", ""], ["button", "mat-flat-button", ""]], viewQuery: function (e, i) { if (1 & e && Bi(yu, 5), 2 & e) { let r; ct(r = ut()) && (i.ripple = r.first) } }, hostAttrs: [1, "mat-focus-indicator"], hostVars: 5, hostBindings: function (e, i) { 2 & e && (Qe("disabled", i.disabled || null), je("_mat-animation-noopable", "NoopAnimations" === i._animationMode)("mat-button-disabled", i.disabled)) }, inputs: { disabled: "disabled", disableRipple: "disableRipple", color: "color" }, exportAs: ["matButton"], features: [D], attrs: bM, ngContentSelectors: CM, decls: 4, vars: 5, consts: [[1, "mat-button-wrapper"], ["matRipple", "", 1, "mat-button-ripple", 3, "matRippleDisabled", "matRippleCentered", "matRippleTrigger"], [1, "mat-button-focus-overlay"]], template: function (e, i) { 1 & e && (an(), x(0, "span", 0), Ae(1), M(), Ye(2, "span", 1), Ye(3, "span", 2)), 2 & e && (B(2), je("mat-button-ripple-round", i.isRoundButton || i.isIconButton), K("matRippleDisabled", i._isRippleDisabled())("matRippleCentered", i.isIconButton)("matRippleTrigger", i._getHostElement())) }, directives: [yu], styles: [".mat-button .mat-button-focus-overlay,.mat-icon-button .mat-button-focus-overlay{opacity:0}.mat-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay,.mat-stroked-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay{opacity:.04}@media(hover: none){.mat-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay,.mat-stroked-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay{opacity:0}}.mat-button,.mat-icon-button,.mat-stroked-button,.mat-flat-button{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible}.mat-button::-moz-focus-inner,.mat-icon-button::-moz-focus-inner,.mat-stroked-button::-moz-focus-inner,.mat-flat-button::-moz-focus-inner{border:0}.mat-button.mat-button-disabled,.mat-icon-button.mat-button-disabled,.mat-stroked-button.mat-button-disabled,.mat-flat-button.mat-button-disabled{cursor:default}.mat-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-button.cdk-program-focused .mat-button-focus-overlay,.mat-icon-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-icon-button.cdk-program-focused .mat-button-focus-overlay,.mat-stroked-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-stroked-button.cdk-program-focused .mat-button-focus-overlay,.mat-flat-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-flat-button.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-button::-moz-focus-inner,.mat-icon-button::-moz-focus-inner,.mat-stroked-button::-moz-focus-inner,.mat-flat-button::-moz-focus-inner{border:0}.mat-raised-button{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0, 0, 0);transition:background 400ms cubic-bezier(0.25, 0.8, 0.25, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1)}.mat-raised-button::-moz-focus-inner{border:0}.mat-raised-button.mat-button-disabled{cursor:default}.mat-raised-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-raised-button.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-raised-button::-moz-focus-inner{border:0}._mat-animation-noopable.mat-raised-button{transition:none;animation:none}.mat-stroked-button{border:1px solid currentColor;padding:0 15px;line-height:34px}.mat-stroked-button .mat-button-ripple.mat-ripple,.mat-stroked-button .mat-button-focus-overlay{top:-1px;left:-1px;right:-1px;bottom:-1px}.mat-fab{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0, 0, 0);transition:background 400ms cubic-bezier(0.25, 0.8, 0.25, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);min-width:0;border-radius:50%;width:56px;height:56px;padding:0;flex-shrink:0}.mat-fab::-moz-focus-inner{border:0}.mat-fab.mat-button-disabled{cursor:default}.mat-fab.cdk-keyboard-focused .mat-button-focus-overlay,.mat-fab.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-fab::-moz-focus-inner{border:0}._mat-animation-noopable.mat-fab{transition:none;animation:none}.mat-fab .mat-button-wrapper{padding:16px 0;display:inline-block;line-height:24px}.mat-mini-fab{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0, 0, 0);transition:background 400ms cubic-bezier(0.25, 0.8, 0.25, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);min-width:0;border-radius:50%;width:40px;height:40px;padding:0;flex-shrink:0}.mat-mini-fab::-moz-focus-inner{border:0}.mat-mini-fab.mat-button-disabled{cursor:default}.mat-mini-fab.cdk-keyboard-focused .mat-button-focus-overlay,.mat-mini-fab.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-mini-fab::-moz-focus-inner{border:0}._mat-animation-noopable.mat-mini-fab{transition:none;animation:none}.mat-mini-fab .mat-button-wrapper{padding:8px 0;display:inline-block;line-height:24px}.mat-icon-button{padding:0;min-width:0;width:40px;height:40px;flex-shrink:0;line-height:40px;border-radius:50%}.mat-icon-button i,.mat-icon-button .mat-icon{line-height:24px}.mat-button-ripple.mat-ripple,.mat-button-focus-overlay{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;border-radius:inherit}.mat-button-ripple.mat-ripple:not(:empty){transform:translateZ(0)}.mat-button-focus-overlay{opacity:0;transition:opacity 200ms cubic-bezier(0.35, 0, 0.25, 1),background-color 200ms cubic-bezier(0.35, 0, 0.25, 1)}._mat-animation-noopable .mat-button-focus-overlay{transition:none}.mat-button-ripple-round{border-radius:50%;z-index:1}.mat-button .mat-button-wrapper>*,.mat-flat-button .mat-button-wrapper>*,.mat-stroked-button .mat-button-wrapper>*,.mat-raised-button .mat-button-wrapper>*,.mat-icon-button .mat-button-wrapper>*,.mat-fab .mat-button-wrapper>*,.mat-mini-fab .mat-button-wrapper>*{vertical-align:middle}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon-button,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon-button{display:inline-flex;justify-content:center;align-items:center;font-size:inherit;width:2.5em;height:2.5em}.cdk-high-contrast-active .mat-button,.cdk-high-contrast-active .mat-flat-button,.cdk-high-contrast-active .mat-raised-button,.cdk-high-contrast-active .mat-icon-button,.cdk-high-contrast-active .mat-fab,.cdk-high-contrast-active .mat-mini-fab{outline:solid 1px}.cdk-high-contrast-active .mat-button-base.cdk-keyboard-focused,.cdk-high-contrast-active .mat-button-base.cdk-program-focused{outline:solid 3px}\n"], encapsulation: 2, changeDetection: 0 }), n })(), EM = (() => { class n { } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275mod = ee({ type: n }), n.\u0275inj = X({ imports: [[mM, at], at] }), n })(); class U$ extends Ie { notifyNext(t, e, i, r, s) { this.destination.next(e) } notifyError(t, e) { this.destination.error(t) } notifyComplete(t) { this.destination.complete() } } class z$ extends Ie { constructor(t, e, i) { super(), this.parent = t, this.outerValue = e, this.outerIndex = i, this.index = 0 } _next(t) { this.parent.notifyNext(this.outerValue, t, this.outerIndex, this.index++, this) } _error(t) { this.parent.notifyError(t, this), this.unsubscribe() } _complete() { this.parent.notifyComplete(this), this.unsubscribe() } } function W$(n, t, e, i, r = new z$(n, e, i)) { if (!r.closed) return t instanceof me ? t.subscribe(r) : Ru(t)(r) } const DM = {}; class K$ { constructor(t) { this.resultSelector = t } call(t, e) { return e.subscribe(new Q$(t, this.resultSelector)) } } class Q$ extends U$ { constructor(t, e) { super(t), this.resultSelector = e, this.active = 0, this.values = [], this.observables = [] } _next(t) { this.values.push(DM), this.observables.push(t) } _complete() { const t = this.observables, e = t.length; if (0 === e) this.destination.complete(); else { this.active = e, this.toRespond = e; for (let i = 0; i < e; i++)this.add(W$(this, t[i], void 0, i)) } } notifyComplete(t) { 0 == (this.active -= 1) && this.destination.complete() } notifyNext(t, e, i) { const r = this.values, o = this.toRespond ? r[i] === DM ? --this.toRespond : this.toRespond : 0; r[i] = e, 0 === o && (this.resultSelector ? this._tryResultSelector(r) : this.destination.next(r.slice())) } _tryResultSelector(t) { let e; try { e = this.resultSelector.apply(this, t) } catch (i) { return void this.destination.error(i) } this.destination.next(e) } } const xM = new Set; let eo, MM = (() => { class n { constructor(e) { this._platform = e, this._matchMedia = this._platform.isBrowser && window.matchMedia ? window.matchMedia.bind(window) : J$ } matchMedia(e) { return this._platform.WEBKIT && function (n) { if (!xM.has(n)) try { eo || (eo = document.createElement("style"), eo.setAttribute("type", "text/css"), document.head.appendChild(eo)), eo.sheet && (eo.sheet.insertRule(`@media ${n} {.fx-query-test{ }}`, 0), xM.add(n)) } catch (t) { console.error(t) } }(e), this._matchMedia(e) } } return n.\u0275fac = function (e) { return new (e || n)(m(Ce)) }, n.\u0275prov = E({ factory: function () { return new n(m(Ce)) }, token: n, providedIn: "root" }), n })(); function J$(n) { return { matches: "all" === n || "" === n, media: n, addListener: () => { }, removeListener: () => { } } } let AM = (() => { class n { constructor(e, i) { this._mediaMatcher = e, this._zone = i, this._queries = new Map, this._destroySubject = new ie } ngOnDestroy() { this._destroySubject.next(), this._destroySubject.complete() } isMatched(e) { return SM(Hc(e)).some(r => this._registerQuery(r).mql.matches) } observe(e) { let s = function (...n) { let t, e; return Gr(n[n.length - 1]) && (e = n.pop()), "function" == typeof n[n.length - 1] && (t = n.pop()), 1 === n.length && jr(n[0]) && (n = n[0]), Nu(n, e).lift(new K$(t)) }(SM(Hc(e)).map(o => this._registerQuery(o).observable)); return s = wp(s.pipe(Ks(1)), s.pipe(jD(1), GD(0))), s.pipe(Dt(o => { const a = { matches: !1, breakpoints: {} }; return o.forEach(({ matches: l, query: c }) => { a.matches = a.matches || l, a.breakpoints[c] = l }), a })) } _registerQuery(e) { if (this._queries.has(e)) return this._queries.get(e); const i = this._mediaMatcher.matchMedia(e), s = { observable: new me(o => { const a = l => this._zone.run(() => o.next(l)); return i.addListener(a), () => { i.removeListener(a) } }).pipe(Us(i), Dt(({ matches: o }) => ({ query: e, matches: o })), pt(this._destroySubject)), mql: i }; return this._queries.set(e, s), s } } return n.\u0275fac = function (e) { return new (e || n)(m(MM), m(H)) }, n.\u0275prov = E({ factory: function () { return new n(m(MM), m(H)) }, token: n, providedIn: "root" }), n })(); function SM(n) { return n.map(t => t.split(",")).reduce((t, e) => t.concat(e)).map(t => t.trim()) } function X$(n, t) { if (1 & n) { const e = pr(); x(0, "div", 1), x(1, "button", 2), ye("click", function () { return ai(e), He().action() }), oe(2), M(), M() } if (2 & n) { const e = He(); B(2), Ms(e.data.action) } } function e3(n, t) { } const TM = new k("MatSnackBarData"); class vu { constructor() { this.politeness = "assertive", this.announcementMessage = "", this.duration = 0, this.data = null, this.horizontalPosition = "center", this.verticalPosition = "bottom" } } const t3 = Math.pow(2, 31) - 1; class mg { constructor(t, e) { this._overlayRef = e, this._afterDismissed = new ie, this._afterOpened = new ie, this._onAction = new ie, this._dismissedByAction = !1, this.containerInstance = t, this.onAction().subscribe(() => this.dismiss()), t._onExit.subscribe(() => this._finishDismiss()) } dismiss() { this._afterDismissed.closed || this.containerInstance.exit(), clearTimeout(this._durationTimeoutId) } dismissWithAction() { this._onAction.closed || (this._dismissedByAction = !0, this._onAction.next(), this._onAction.complete()), clearTimeout(this._durationTimeoutId) } closeWithAction() { this.dismissWithAction() } _dismissAfter(t) { this._durationTimeoutId = setTimeout(() => this.dismiss(), Math.min(t, t3)) } _open() { this._afterOpened.closed || (this._afterOpened.next(), this._afterOpened.complete()) } _finishDismiss() { this._overlayRef.dispose(), this._onAction.closed || this._onAction.complete(), this._afterDismissed.next({ dismissedByAction: this._dismissedByAction }), this._afterDismissed.complete(), this._dismissedByAction = !1 } afterDismissed() { return this._afterDismissed } afterOpened() { return this.containerInstance._onEnter } onAction() { return this._onAction } } let n3 = (() => { class n { constructor(e, i) { this.snackBarRef = e, this.data = i } action() { this.snackBarRef.dismissWithAction() } get hasAction() { return !!this.data.action } } return n.\u0275fac = function (e) { return new (e || n)(g(mg), g(TM)) }, n.\u0275cmp = tt({ type: n, selectors: [["simple-snack-bar"]], hostAttrs: [1, "mat-simple-snackbar"], decls: 3, vars: 2, consts: [["class", "mat-simple-snackbar-action", 4, "ngIf"], [1, "mat-simple-snackbar-action"], ["mat-button", "", 3, "click"]], template: function (e, i) { 1 & e && (x(0, "span"), oe(1), M(), Ee(2, X$, 3, 1, "div", 0)), 2 & e && (B(1), Ms(i.data.message), B(1), K("ngIf", i.hasAction)) }, directives: [js, gg], styles: [".mat-simple-snackbar{display:flex;justify-content:space-between;align-items:center;line-height:20px;opacity:1}.mat-simple-snackbar-action{flex-shrink:0;margin:-8px -8px -8px 8px}.mat-simple-snackbar-action button{max-height:36px;min-width:0}[dir=rtl] .mat-simple-snackbar-action{margin-left:-8px;margin-right:8px}\n"], encapsulation: 2, changeDetection: 0 }), n })(); const i3 = { snackBarState: cx("state", [Pp("void, hidden", Ir({ transform: "scale(0.8)", opacity: 0 })), Pp("visible", Ir({ transform: "scale(1)", opacity: 1 })), Lp("* => visible", Np("150ms cubic-bezier(0, 0, 0.2, 1)")), Lp("* => void, * => hidden", Np("75ms cubic-bezier(0.4, 0.0, 1, 1)", Ir({ opacity: 0 })))]) }; let r3 = (() => { class n extends Ap { constructor(e, i, r, s, o) { super(), this._ngZone = e, this._elementRef = i, this._changeDetectorRef = r, this._platform = s, this.snackBarConfig = o, this._announceDelay = 150, this._destroyed = !1, this._onAnnounce = new ie, this._onExit = new ie, this._onEnter = new ie, this._animationState = "void", this.attachDomPortal = a => (this._assertNotAttached(), this._applySnackBarClasses(), this._portalOutlet.attachDomPortal(a)), this._live = "assertive" !== o.politeness || o.announcementMessage ? "off" === o.politeness ? "off" : "polite" : "assertive", this._platform.FIREFOX && ("polite" === this._live && (this._role = "status"), "assertive" === this._live && (this._role = "alert")) } attachComponentPortal(e) { return this._assertNotAttached(), this._applySnackBarClasses(), this._portalOutlet.attachComponentPortal(e) } attachTemplatePortal(e) { return this._assertNotAttached(), this._applySnackBarClasses(), this._portalOutlet.attachTemplatePortal(e) } onAnimationEnd(e) { const { fromState: i, toState: r } = e; if (("void" === r && "void" !== i || "hidden" === r) && this._completeExit(), "visible" === r) { const s = this._onEnter; this._ngZone.run(() => { s.next(), s.complete() }) } } enter() { this._destroyed || (this._animationState = "visible", this._changeDetectorRef.detectChanges(), this._screenReaderAnnounce()) } exit() { return this._animationState = "hidden", this._elementRef.nativeElement.setAttribute("mat-exit", ""), clearTimeout(this._announceTimeoutId), this._onExit } ngOnDestroy() { this._destroyed = !0, this._completeExit() } _completeExit() { this._ngZone.onMicrotaskEmpty.pipe(Ks(1)).subscribe(() => { this._onExit.next(), this._onExit.complete() }) } _applySnackBarClasses() { const e = this._elementRef.nativeElement, i = this.snackBarConfig.panelClass; i && (Array.isArray(i) ? i.forEach(r => e.classList.add(r)) : e.classList.add(i)), "center" === this.snackBarConfig.horizontalPosition && e.classList.add("mat-snack-bar-center"), "top" === this.snackBarConfig.verticalPosition && e.classList.add("mat-snack-bar-top") } _assertNotAttached() { this._portalOutlet.hasAttached() } _screenReaderAnnounce() { this._announceTimeoutId || this._ngZone.runOutsideAngular(() => { this._announceTimeoutId = setTimeout(() => { const e = this._elementRef.nativeElement.querySelector("[aria-hidden]"), i = this._elementRef.nativeElement.querySelector("[aria-live]"); if (e && i) { let r = null; this._platform.isBrowser && document.activeElement instanceof HTMLElement && e.contains(document.activeElement) && (r = document.activeElement), e.removeAttribute("aria-hidden"), i.appendChild(e), null == r || r.focus(), this._onAnnounce.next(), this._onAnnounce.complete() } }, this._announceDelay) }) } } return n.\u0275fac = function (e) { return new (e || n)(g(H), g(O), g(Is), g(Ce), g(vu)) }, n.\u0275cmp = tt({ type: n, selectors: [["snack-bar-container"]], viewQuery: function (e, i) { if (1 & e && Bi(Qc, 7), 2 & e) { let r; ct(r = ut()) && (i._portalOutlet = r.first) } }, hostAttrs: [1, "mat-snack-bar-container"], hostVars: 1, hostBindings: function (e, i) { 1 & e && wf("@state.done", function (s) { return i.onAnimationEnd(s) }), 2 & e && Af("@state", i._animationState) }, features: [D], decls: 3, vars: 2, consts: [["aria-hidden", "true"], ["cdkPortalOutlet", ""]], template: function (e, i) { 1 & e && (x(0, "div", 0), Ee(1, e3, 0, 0, "ng-template", 1), M(), Ye(2, "div")), 2 & e && (B(2), Qe("aria-live", i._live)("role", i._role)) }, directives: [Qc], styles: [".mat-snack-bar-container{border-radius:4px;box-sizing:border-box;display:block;margin:24px;max-width:33vw;min-width:344px;padding:14px 16px;min-height:48px;transform-origin:center}.cdk-high-contrast-active .mat-snack-bar-container{border:solid 1px}.mat-snack-bar-handset{width:100%}.mat-snack-bar-handset .mat-snack-bar-container{margin:8px;max-width:100%;min-width:0;width:100%}\n"], encapsulation: 2, data: { animation: [i3.snackBarState] } }), n })(), IM = (() => { class n { } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275mod = ee({ type: n }), n.\u0275inj = X({ imports: [[dj, AD, Ec, EM, at], at] }), n })(); const FM = new k("mat-snack-bar-default-options", { providedIn: "root", factory: function () { return new vu } }); let o3 = (() => { class n { constructor(e, i, r, s, o, a) { this._overlay = e, this._live = i, this._injector = r, this._breakpointObserver = s, this._parentSnackBar = o, this._defaultConfig = a, this._snackBarRefAtThisLevel = null, this.simpleSnackBarComponent = n3, this.snackBarContainerComponent = r3, this.handsetCssClass = "mat-snack-bar-handset" } get _openedSnackBarRef() { const e = this._parentSnackBar; return e ? e._openedSnackBarRef : this._snackBarRefAtThisLevel } set _openedSnackBarRef(e) { this._parentSnackBar ? this._parentSnackBar._openedSnackBarRef = e : this._snackBarRefAtThisLevel = e } openFromComponent(e, i) { return this._attach(e, i) } openFromTemplate(e, i) { return this._attach(e, i) } open(e, i = "", r) { const s = Object.assign(Object.assign({}, this._defaultConfig), r); return s.data = { message: e, action: i }, s.announcementMessage === e && (s.announcementMessage = void 0), this.openFromComponent(this.simpleSnackBarComponent, s) } dismiss() { this._openedSnackBarRef && this._openedSnackBarRef.dismiss() } ngOnDestroy() { this._snackBarRefAtThisLevel && this._snackBarRefAtThisLevel.dismiss() } _attachSnackBarContainer(e, i) { const s = ce.create({ parent: i && i.viewContainerRef && i.viewContainerRef.injector || this._injector, providers: [{ provide: vu, useValue: i }] }), o = new Mp(this.snackBarContainerComponent, i.viewContainerRef, s), a = e.attach(o); return a.instance.snackBarConfig = i, a.instance } _attach(e, i) { const r = Object.assign(Object.assign(Object.assign({}, new vu), this._defaultConfig), i), s = this._createOverlay(r), o = this._attachSnackBarContainer(s, r), a = new mg(o, s); if (e instanceof Kt) { const l = new Kc(e, null, { $implicit: r.data, snackBarRef: a }); a.instance = o.attachTemplatePortal(l) } else { const l = this._createInjector(r, a), c = new Mp(e, void 0, l), u = o.attachComponentPortal(c); a.instance = u.instance } return this._breakpointObserver.observe("(max-width: 599.98px) and (orientation: portrait)").pipe(pt(s.detachments())).subscribe(l => { const c = s.overlayElement.classList; l.matches ? c.add(this.handsetCssClass) : c.remove(this.handsetCssClass) }), r.announcementMessage && o._onAnnounce.subscribe(() => { this._live.announce(r.announcementMessage, r.politeness) }), this._animateSnackBar(a, r), this._openedSnackBarRef = a, this._openedSnackBarRef } _animateSnackBar(e, i) { e.afterDismissed().subscribe(() => { this._openedSnackBarRef == e && (this._openedSnackBarRef = null), i.announcementMessage && this._live.clear() }), this._openedSnackBarRef ? (this._openedSnackBarRef.afterDismissed().subscribe(() => { e.containerInstance.enter() }), this._openedSnackBarRef.dismiss()) : e.containerInstance.enter(), i.duration && i.duration > 0 && e.afterOpened().subscribe(() => e._dismissAfter(i.duration)) } _createOverlay(e) { const i = new Tp; i.direction = e.direction; let r = this._overlay.position().global(); const s = "rtl" === e.direction, o = "left" === e.horizontalPosition || "start" === e.horizontalPosition && !s || "end" === e.horizontalPosition && s, a = !o && "center" !== e.horizontalPosition; return o ? r.left("0") : a ? r.right("0") : r.centerHorizontally(), "top" === e.verticalPosition ? r.top("0") : r.bottom("0"), i.positionStrategy = r, this._overlay.create(i) } _createInjector(e, i) { return ce.create({ parent: e && e.viewContainerRef && e.viewContainerRef.injector || this._injector, providers: [{ provide: mg, useValue: i }, { provide: TM, useValue: e.data }] }) } } return n.\u0275fac = function (e) { return new (e || n)(m(Ta), m(Rp), m(ce), m(AM), m(n, 12), m(FM)) }, n.\u0275prov = E({ factory: function () { return new n(m(Ta), m(Rp), m(fr), m(AM), m(n, 12), m(FM)) }, token: n, providedIn: IM }), n })(); const a3 = ["*", [["mat-toolbar-row"]]], l3 = ["*", "mat-toolbar-row"], c3 = mu(class { constructor(n) { this._elementRef = n } }); let u3 = (() => { class n { } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275dir = C({ type: n, selectors: [["mat-toolbar-row"]], hostAttrs: [1, "mat-toolbar-row"], exportAs: ["matToolbarRow"] }), n })(), d3 = (() => { class n extends c3 { constructor(e, i, r) { super(e), this._platform = i, this._document = r } ngAfterViewInit() { this._platform.isBrowser && (this._checkToolbarMixedModes(), this._toolbarRows.changes.subscribe(() => this._checkToolbarMixedModes())) } _checkToolbarMixedModes() { } } return n.\u0275fac = function (e) { return new (e || n)(g(O), g(Ce), g(N)) }, n.\u0275cmp = tt({ type: n, selectors: [["mat-toolbar"]], contentQueries: function (e, i, r) { if (1 & e && Fn(r, u3, 5), 2 & e) { let s; ct(s = ut()) && (i._toolbarRows = s) } }, hostAttrs: [1, "mat-toolbar"], hostVars: 4, hostBindings: function (e, i) { 2 & e && je("mat-toolbar-multiple-rows", i._toolbarRows.length > 0)("mat-toolbar-single-row", 0 === i._toolbarRows.length) }, inputs: { color: "color" }, exportAs: ["matToolbar"], features: [D], ngContentSelectors: l3, decls: 2, vars: 0, template: function (e, i) { 1 & e && (an(a3), Ae(0), Ae(1, 1)) }, styles: [".cdk-high-contrast-active .mat-toolbar{outline:solid 1px}.mat-toolbar-row,.mat-toolbar-single-row{display:flex;box-sizing:border-box;padding:0 16px;width:100%;flex-direction:row;align-items:center;white-space:nowrap}.mat-toolbar-multiple-rows{display:flex;box-sizing:border-box;flex-direction:column;width:100%}\n"], encapsulation: 2, changeDetection: 0 }), n })(), f3 = (() => { class n { } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275mod = ee({ type: n }), n.\u0275inj = X({ imports: [[at], at] }), n })(); function Yi() { } function bu(n, t, e) { return function (r) { return r.lift(new h3(n, t, e)) } } class h3 { constructor(t, e, i) { this.nextOrObserver = t, this.error = e, this.complete = i } call(t, e) { return e.subscribe(new p3(t, this.nextOrObserver, this.error, this.complete)) } } class p3 extends Ie { constructor(t, e, i, r) { super(t), this._tapNext = Yi, this._tapError = Yi, this._tapComplete = Yi, this._tapError = i || Yi, this._tapComplete = r || Yi, Hn(e) ? (this._context = this, this._tapNext = e) : e && (this._context = e, this._tapNext = e.next || Yi, this._tapError = e.error || Yi, this._tapComplete = e.complete || Yi) } _next(t) { try { this._tapNext.call(this._context, t) } catch (e) { return void this.destination.error(e) } this.destination.next(t) } _error(t) { try { this._tapError.call(this._context, t) } catch (e) { return void this.destination.error(e) } this.destination.error(t) } _complete() { try { this._tapComplete.call(this._context) } catch (t) { return void this.destination.error(t) } return this.destination.complete() } } const m3 = { provide: LC, useFactory: function (n, t) { return () => { if (Dr(t)) { const e = Array.from(n.querySelectorAll(`[class*=${RM}]`)), i = /\bflex-layout-.+?\b/g; e.forEach(r => { r.classList.contains(`${RM}ssr`) && r.parentNode ? r.parentNode.removeChild(r) : r.className.replace(i, "") }) } } }, deps: [N, bt], multi: !0 }, RM = "flex-layout-"; let _g = (() => { class n { } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275mod = ee({ type: n }), n.\u0275inj = X({ providers: [m3] }), n })(); class Pr { constructor(t = !1, e = "all", i = "", r = "", s = 0) { this.matches = t, this.mediaQuery = e, this.mqAlias = i, this.suffix = r, this.priority = s, this.property = "" } clone() { return new Pr(this.matches, this.mediaQuery, this.mqAlias, this.suffix) } } let kM = (() => { class n { constructor() { this.stylesheet = new Map } addStyleToElement(e, i, r) { const s = this.stylesheet.get(e); s ? s.set(i, r) : this.stylesheet.set(e, new Map([[i, r]])) } clearStyles() { this.stylesheet.clear() } getStyleForElement(e, i) { const r = this.stylesheet.get(e); let s = ""; if (r) { const o = r.get(i); ("number" == typeof o || "string" == typeof o) && (s = o + "") } return s } } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275prov = E({ factory: function () { return new n }, token: n, providedIn: "root" }), n })(); const yg = { addFlexToParent: !0, addOrientationBps: !1, disableDefaultBps: !1, disableVendorPrefixes: !1, serverLoaded: !1, useColumnBasisZero: !0, printWithBreakpoints: [], mediaTriggerAutoRestore: !0, ssrObserveBreakpoints: [] }, Vn = new k("Flex Layout token, config options for the library", { providedIn: "root", factory: () => yg }), Lr = new k("FlexLayoutServerLoaded", { providedIn: "root", factory: () => !1 }), vg = new k("Flex Layout token, collect all breakpoints into one provider", { providedIn: "root", factory: () => null }); function OM(n, t) { return n = n ? n.clone() : new Pr, t && (n.mqAlias = t.alias, n.mediaQuery = t.mediaQuery, n.suffix = t.suffix, n.priority = t.priority), n } const bg = "inline", NM = ["row", "column", "row-reverse", "column-reverse"]; function v3(n) { if (n) switch (n.toLowerCase()) { case "reverse": case "wrap-reverse": case "reverse-wrap": n = "wrap-reverse"; break; case "no": case "none": case "nowrap": n = "nowrap"; break; default: n = "wrap" }return n } let Pe = (() => { class n { constructor(e, i, r, s) { this.elementRef = e, this.styleBuilder = i, this.styler = r, this.marshal = s, this.DIRECTIVE_KEY = "", this.inputs = [], this.mru = {}, this.destroySubject = new ie, this.styleCache = new Map } get parentElement() { return this.elementRef.nativeElement.parentElement } get nativeElement() { return this.elementRef.nativeElement } get activatedValue() { return this.marshal.getValue(this.nativeElement, this.DIRECTIVE_KEY) } set activatedValue(e) { this.marshal.setValue(this.nativeElement, this.DIRECTIVE_KEY, e, this.marshal.activatedAlias) } ngOnChanges(e) { Object.keys(e).forEach(i => { if (-1 !== this.inputs.indexOf(i)) { const r = i.split(".").slice(1).join("."); this.setValue(e[i].currentValue, r) } }) } ngOnDestroy() { this.destroySubject.next(), this.destroySubject.complete(), this.marshal.releaseElement(this.nativeElement) } init(e = []) { this.marshal.init(this.elementRef.nativeElement, this.DIRECTIVE_KEY, this.updateWithValue.bind(this), this.clearStyles.bind(this), e) } addStyles(e, i) { const r = this.styleBuilder, s = r.shouldCache; let o = this.styleCache.get(e); (!o || !s) && (o = r.buildStyles(e, i), s && this.styleCache.set(e, o)), this.mru = Object.assign({}, o), this.applyStyleToElement(o), r.sideEffect(e, o, i) } clearStyles() { Object.keys(this.mru).forEach(e => { this.mru[e] = "" }), this.applyStyleToElement(this.mru), this.mru = {} } triggerUpdate() { this.marshal.triggerUpdate(this.nativeElement, this.DIRECTIVE_KEY) } getFlexFlowDirection(e, i = !1) { if (e) { const [r, s] = this.styler.getFlowDirection(e); if (!s && i) { const o = function (n) { let [t, e, i] = function (n) { n = n ? n.toLowerCase() : ""; let [t, e, i] = n.split(" "); return NM.find(r => r === t) || (t = NM[0]), e === bg && (e = i !== bg ? i : "", i = bg), [t, v3(e), !!i] }(n); return function (n, t = null, e = !1) { return { display: e ? "inline-flex" : "flex", "box-sizing": "border-box", "flex-direction": n, "flex-wrap": t || null } }(t, e, i) }(r); this.styler.applyStyleToElements(o, [e]) } return r.trim() } return "row" } hasWrap(e) { return this.styler.hasWrap(e) } applyStyleToElement(e, i, r = this.nativeElement) { this.styler.applyStyleToElement(r, e, i) } setValue(e, i) { this.marshal.setValue(this.nativeElement, this.DIRECTIVE_KEY, e, i) } updateWithValue(e) { this.currentValue !== e && (this.addStyles(e), this.currentValue = e) } } return n.\u0275fac = function (e) { !function () { throw new Error("invalid") }() }, n.\u0275dir = C({ type: n, features: [nt] }), n })(); const C3 = [{ alias: "xs", mediaQuery: "screen and (min-width: 0px) and (max-width: 599.98px)", priority: 1e3 }, { alias: "sm", mediaQuery: "screen and (min-width: 600px) and (max-width: 959.98px)", priority: 900 }, { alias: "md", mediaQuery: "screen and (min-width: 960px) and (max-width: 1279.98px)", priority: 800 }, { alias: "lg", mediaQuery: "screen and (min-width: 1280px) and (max-width: 1919.98px)", priority: 700 }, { alias: "xl", mediaQuery: "screen and (min-width: 1920px) and (max-width: 4999.98px)", priority: 600 }, { alias: "lt-sm", overlapping: !0, mediaQuery: "screen and (max-width: 599.98px)", priority: 950 }, { alias: "lt-md", overlapping: !0, mediaQuery: "screen and (max-width: 959.98px)", priority: 850 }, { alias: "lt-lg", overlapping: !0, mediaQuery: "screen and (max-width: 1279.98px)", priority: 750 }, { alias: "lt-xl", overlapping: !0, priority: 650, mediaQuery: "screen and (max-width: 1919.98px)" }, { alias: "gt-xs", overlapping: !0, mediaQuery: "screen and (min-width: 600px)", priority: -950 }, { alias: "gt-sm", overlapping: !0, mediaQuery: "screen and (min-width: 960px)", priority: -850 }, { alias: "gt-md", overlapping: !0, mediaQuery: "screen and (min-width: 1280px)", priority: -750 }, { alias: "gt-lg", overlapping: !0, mediaQuery: "screen and (min-width: 1920px)", priority: -650 }], PM = "(orientation: portrait) and (max-width: 599.98px)", LM = "(orientation: landscape) and (max-width: 959.98px)", VM = "(orientation: portrait) and (min-width: 600px) and (max-width: 839.98px)", BM = "(orientation: landscape) and (min-width: 960px) and (max-width: 1279.98px)", HM = "(orientation: portrait) and (min-width: 840px)", jM = "(orientation: landscape) and (min-width: 1280px)", Ci = { HANDSET: `${PM}, ${LM}`, TABLET: `${VM} , ${BM}`, WEB: `${HM}, ${jM} `, HANDSET_PORTRAIT: `${PM}`, TABLET_PORTRAIT: `${VM} `, WEB_PORTRAIT: `${HM}`, HANDSET_LANDSCAPE: `${LM}`, TABLET_LANDSCAPE: `${BM}`, WEB_LANDSCAPE: `${jM}` }, w3 = [{ alias: "handset", priority: 2e3, mediaQuery: Ci.HANDSET }, { alias: "handset.landscape", priority: 2e3, mediaQuery: Ci.HANDSET_LANDSCAPE }, { alias: "handset.portrait", priority: 2e3, mediaQuery: Ci.HANDSET_PORTRAIT }, { alias: "tablet", priority: 2100, mediaQuery: Ci.TABLET }, { alias: "tablet.landscape", priority: 2100, mediaQuery: Ci.TABLET_LANDSCAPE }, { alias: "tablet.portrait", priority: 2100, mediaQuery: Ci.TABLET_PORTRAIT }, { alias: "web", priority: 2200, mediaQuery: Ci.WEB, overlapping: !0 }, { alias: "web.landscape", priority: 2200, mediaQuery: Ci.WEB_LANDSCAPE, overlapping: !0 }, { alias: "web.portrait", priority: 2200, mediaQuery: Ci.WEB_PORTRAIT, overlapping: !0 }], D3 = /(\.|-|_)/g; function x3(n) { let t = n.length > 0 ? n.charAt(0) : "", e = n.length > 1 ? n.slice(1) : ""; return t.toUpperCase() + e } function S3(n, t = []) { const e = {}; return n.forEach(i => { e[i.alias] = i }), t.forEach(i => { e[i.alias] ? function (n, ...t) { if (null == n) throw TypeError("Cannot convert undefined or null to object"); for (let e of t) if (null != e) for (let i in e) e.hasOwnProperty(i) && (n[i] = e[i]) }(e[i.alias], i) : e[i.alias] = i }), function (n) { return n.forEach(t => { t.suffix || (t.suffix = function (n) { return n.replace(D3, "|").split("|").map(x3).join("") }(t.alias), t.overlapping = !!t.overlapping) }), n }(Object.keys(e).map(i => e[i])) } const GM = new k("Token (@angular/flex-layout) Breakpoints", { providedIn: "root", factory: () => { const n = Ao(vg), t = Ao(Vn), e = [].concat.apply([], (n || []).map(r => Array.isArray(r) ? r : [r])); return S3((t.disableDefaultBps ? [] : C3).concat(t.addOrientationBps ? w3 : []), e) } }); function ka(n, t) { return (t && t.priority || 0) - (n && n.priority || 0) } function T3(n, t) { return (n.priority || 0) - (t.priority || 0) } let Oa = (() => { class n { constructor(e) { this.findByMap = new Map, this.items = [...e].sort(T3) } findByAlias(e) { return e ? this.findWithPredicate(e, i => i.alias == e) : null } findByQuery(e) { return this.findWithPredicate(e, i => i.mediaQuery == e) } get overlappings() { return this.items.filter(e => 1 == e.overlapping) } get aliases() { return this.items.map(e => e.alias) } get suffixes() { return this.items.map(e => e.suffix ? e.suffix : "") } findWithPredicate(e, i) { let r = this.findByMap.get(e); return r || (r = this.items.find(i) || null, this.findByMap.set(e, r)), r || null } } return n.\u0275fac = function (e) { return new (e || n)(m(GM)) }, n.\u0275prov = E({ factory: function () { return new n(m(GM)) }, token: n, providedIn: "root" }), n })(), Cu = (() => { class n { constructor(e, i, r) { this._zone = e, this._platformId = i, this._document = r, this.source = new HD(new Pr(!0)), this.registry = new Map, this.pendingRemoveListenerFns = [], this._observable$ = this.source.asObservable() } get activations() { const e = []; return this.registry.forEach((i, r) => { i.matches && e.push(r) }), e } isActive(e) { const i = this.registry.get(e); return i ? i.matches : this.registerQuery(e).some(r => r.matches) } observe(e, i = !1) { if (e && e.length) { const r = this._observable$.pipe(Da(o => !i || e.indexOf(o.mediaQuery) > -1)); return uo(new me(o => { const a = this.registerQuery(e); if (a.length) { const l = a.pop(); a.forEach(c => { o.next(c) }), this.source.next(l) } o.complete() }), r) } return this._observable$ } registerQuery(e) { const i = Array.isArray(e) ? e : [e], r = []; return function (n, t) { const e = n.filter(i => !$M[i]); if (e.length > 0) { const i = e.join(", "); try { const r = t.createElement("style"); r.setAttribute("type", "text/css"), r.styleSheet || r.appendChild(t.createTextNode(`\n/*\n  @angular/flex-layout - workaround for possible browser quirk with mediaQuery listeners\n  see http://bit.ly/2sd4HMP\n*/\n@media ${i} {.fx-query-test{ }}\n`)), t.head.appendChild(r), e.forEach(s => $M[s] = r) } catch (r) { console.error(r) } } }(i, this._document), i.forEach(s => { const o = l => { this._zone.run(() => this.source.next(new Pr(l.matches, s))) }; let a = this.registry.get(s); a || (a = this.buildMQL(s), a.addListener(o), this.pendingRemoveListenerFns.push(() => a.removeListener(o)), this.registry.set(s, a)), a.matches && r.push(new Pr(!0, s)) }), r } ngOnDestroy() { let e; for (; e = this.pendingRemoveListenerFns.pop();)e() } buildMQL(e) { return function (n, t) { return t && window.matchMedia("all").addListener ? window.matchMedia(n) : { matches: "all" === n || "" === n, media: n, addListener: () => { }, removeListener: () => { }, onchange: null, addEventListener() { }, removeEventListener() { }, dispatchEvent: () => !1 } }(e, Dr(this._platformId)) } } return n.\u0275fac = function (e) { return new (e || n)(m(H), m(bt), m(N)) }, n.\u0275prov = E({ factory: function () { return new n(m(H), m(bt), m(N)) }, token: n, providedIn: "root" }), n })(); const $M = {}, to = "print", O3 = { alias: to, mediaQuery: to, priority: 1e3 }; let UM = (() => { class n { constructor(e, i, r) { this.breakpoints = e, this.layoutConfig = i, this._document = r, this.registeredBeforeAfterPrintHooks = !1, this.isPrintingBeforeAfterEvent = !1, this.beforePrintEventListeners = [], this.afterPrintEventListeners = [], this.isPrinting = !1, this.queue = new N3, this.deactivations = [] } withPrintQuery(e) { return [...e, to] } isPrintEvent(e) { return e.mediaQuery.startsWith(to) } get printAlias() { return this.layoutConfig.printWithBreakpoints || [] } get printBreakPoints() { return this.printAlias.map(e => this.breakpoints.findByAlias(e)).filter(e => null !== e) } getEventBreakpoints({ mediaQuery: e }) { const i = this.breakpoints.findByQuery(e); return (i ? [...this.printBreakPoints, i] : this.printBreakPoints).sort(ka) } updateEvent(e) { let i = this.breakpoints.findByQuery(e.mediaQuery); return this.isPrintEvent(e) && (i = this.getEventBreakpoints(e)[0], e.mediaQuery = i ? i.mediaQuery : ""), OM(e, i) } registerBeforeAfterPrintHooks(e) { if (!this._document.defaultView || this.registeredBeforeAfterPrintHooks) return; this.registeredBeforeAfterPrintHooks = !0; const i = () => { this.isPrinting || (this.isPrintingBeforeAfterEvent = !0, this.startPrinting(e, this.getEventBreakpoints(new Pr(!0, to))), e.updateStyles()) }, r = () => { this.isPrintingBeforeAfterEvent = !1, this.isPrinting && (this.stopPrinting(e), e.updateStyles()) }; this._document.defaultView.addEventListener("beforeprint", i), this._document.defaultView.addEventListener("afterprint", r), this.beforePrintEventListeners.push(i), this.afterPrintEventListeners.push(r) } interceptEvents(e) { return this.registerBeforeAfterPrintHooks(e), i => { this.isPrintEvent(i) ? i.matches && !this.isPrinting ? (this.startPrinting(e, this.getEventBreakpoints(i)), e.updateStyles()) : !i.matches && this.isPrinting && !this.isPrintingBeforeAfterEvent && (this.stopPrinting(e), e.updateStyles()) : this.collectActivations(i) } } blockPropagation() { return e => !(this.isPrinting || this.isPrintEvent(e)) } startPrinting(e, i) { this.isPrinting = !0, e.activatedBreakpoints = this.queue.addPrintBreakpoints(i) } stopPrinting(e) { e.activatedBreakpoints = this.deactivations, this.deactivations = [], this.queue.clear(), this.isPrinting = !1 } collectActivations(e) { if (!this.isPrinting || this.isPrintingBeforeAfterEvent) if (e.matches) this.isPrintingBeforeAfterEvent || (this.deactivations = []); else { const i = this.breakpoints.findByQuery(e.mediaQuery); i && (this.deactivations.push(i), this.deactivations.sort(ka)) } } ngOnDestroy() { this._document.defaultView && (this.beforePrintEventListeners.forEach(e => this._document.defaultView.removeEventListener("beforeprint", e)), this.afterPrintEventListeners.forEach(e => this._document.defaultView.removeEventListener("afterprint", e))) } } return n.\u0275fac = function (e) { return new (e || n)(m(Oa), m(Vn), m(N)) }, n.\u0275prov = E({ factory: function () { return new n(m(Oa), m(Vn), m(N)) }, token: n, providedIn: "root" }), n })(); class N3 { constructor() { this.printBreakpoints = [] } addPrintBreakpoints(t) { return t.push(O3), t.sort(ka), t.forEach(e => this.addBreakpoint(e)), this.printBreakpoints } addBreakpoint(t) { t && void 0 === this.printBreakpoints.find(i => i.mediaQuery === t.mediaQuery) && (this.printBreakpoints = function (n) { return !!n && n.mediaQuery.startsWith(to) }(t) ? [t, ...this.printBreakpoints] : [...this.printBreakpoints, t]) } clear() { this.printBreakpoints = [] } } function zM(n) { for (let t in n) { let e = n[t] || ""; switch (t) { case "display": n.display = "flex" === e ? ["-webkit-flex", "flex"] : "inline-flex" === e ? ["-webkit-inline-flex", "inline-flex"] : e; break; case "align-items": case "align-self": case "align-content": case "flex": case "flex-basis": case "flex-flow": case "flex-grow": case "flex-shrink": case "flex-wrap": case "justify-content": n["-webkit-" + t] = e; break; case "flex-direction": e = e || "row", n["-webkit-flex-direction"] = e, n["flex-direction"] = e; break; case "order": n.order = n["-webkit-" + t] = isNaN(+e) ? "0" : e } } return n } let Re = (() => { class n { constructor(e, i, r, s) { this._serverStylesheet = e, this._serverModuleLoaded = i, this._platformId = r, this.layoutConfig = s } applyStyleToElement(e, i, r = null) { let s = {}; "string" == typeof i && (s[i] = r, i = s), s = this.layoutConfig.disableVendorPrefixes ? i : zM(i), this._applyMultiValueStyleToElement(s, e) } applyStyleToElements(e, i = []) { const r = this.layoutConfig.disableVendorPrefixes ? e : zM(e); i.forEach(s => { this._applyMultiValueStyleToElement(r, s) }) } getFlowDirection(e) { const i = "flex-direction"; let r = this.lookupStyle(e, i); return [r || "row", this.lookupInlineStyle(e, i) || Gs(this._platformId) && this._serverModuleLoaded ? r : ""] } hasWrap(e) { return "wrap" === this.lookupStyle(e, "flex-wrap") } lookupAttributeValue(e, i) { return e.getAttribute(i) || "" } lookupInlineStyle(e, i) { return Dr(this._platformId) ? e.style.getPropertyValue(i) : this._getServerStyle(e, i) } lookupStyle(e, i, r = !1) { let s = ""; return e && ((s = this.lookupInlineStyle(e, i)) || (Dr(this._platformId) ? r || (s = getComputedStyle(e).getPropertyValue(i)) : this._serverModuleLoaded && (s = this._serverStylesheet.getStyleForElement(e, i)))), s ? s.trim() : "" } _applyMultiValueStyleToElement(e, i) { Object.keys(e).sort().forEach(r => { const s = e[r], o = Array.isArray(s) ? s : [s]; o.sort(); for (let a of o) a = a ? a + "" : "", Dr(this._platformId) || !this._serverModuleLoaded ? Dr(this._platformId) ? i.style.setProperty(r, a) : this._setServerStyle(i, r, a) : this._serverStylesheet.addStyleToElement(i, r, a) }) } _setServerStyle(e, i, r) { i = i.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase(); const s = this._readStyleAttribute(e); s[i] = r || "", this._writeStyleAttribute(e, s) } _getServerStyle(e, i) { return this._readStyleAttribute(e)[i] || "" } _readStyleAttribute(e) { const i = {}, r = e.getAttribute("style"); if (r) { const s = r.split(/;+/g); for (let o = 0; o < s.length; o++) { const a = s[o].trim(); if (a.length > 0) { const l = a.indexOf(":"); if (-1 === l) throw new Error(`Invalid CSS style: ${a}`); i[a.substr(0, l).trim()] = a.substr(l + 1).trim() } } } return i } _writeStyleAttribute(e, i) { let r = ""; for (const s in i) i[s] && (r += s + ":" + i[s] + ";"); e.setAttribute("style", r) } } return n.\u0275fac = function (e) { return new (e || n)(m(kM), m(Lr), m(bt), m(Vn)) }, n.\u0275prov = E({ factory: function () { return new n(m(kM), m(Lr), m(bt), m(Vn)) }, token: n, providedIn: "root" }), n })(); class We { constructor() { this.shouldCache = !0 } sideEffect(t, e, i) { } } let Le = (() => { class n { constructor(e, i, r) { this.matchMedia = e, this.breakpoints = i, this.hook = r, this.activatedBreakpoints = [], this.elementMap = new Map, this.elementKeyMap = new WeakMap, this.watcherMap = new WeakMap, this.updateMap = new WeakMap, this.clearMap = new WeakMap, this.subject = new ie, this.observeActivations() } get activatedAlias() { return this.activatedBreakpoints[0] ? this.activatedBreakpoints[0].alias : "" } onMediaChange(e) { const i = this.findByQuery(e.mediaQuery); i && ((e = OM(e, i)).matches && -1 === this.activatedBreakpoints.indexOf(i) ? (this.activatedBreakpoints.push(i), this.activatedBreakpoints.sort(ka), this.updateStyles()) : !e.matches && -1 !== this.activatedBreakpoints.indexOf(i) && (this.activatedBreakpoints.splice(this.activatedBreakpoints.indexOf(i), 1), this.activatedBreakpoints.sort(ka), this.updateStyles())) } init(e, i, r, s, o = []) { KM(this.updateMap, e, i, r), KM(this.clearMap, e, i, s), this.buildElementKeyMap(e, i), this.watchExtraTriggers(e, i, o) } getValue(e, i, r) { const s = this.elementMap.get(e); if (s) { const o = void 0 !== r ? s.get(r) : this.getActivatedValues(s, i); if (o) return o.get(i) } } hasValue(e, i) { const r = this.elementMap.get(e); if (r) { const s = this.getActivatedValues(r, i); if (s) return void 0 !== s.get(i) || !1 } return !1 } setValue(e, i, r, s) { let o = this.elementMap.get(e); if (o) { const l = (o.get(s) || new Map).set(i, r); o.set(s, l), this.elementMap.set(e, o) } else o = (new Map).set(s, (new Map).set(i, r)), this.elementMap.set(e, o); const a = this.getValue(e, i); void 0 !== a && this.updateElement(e, i, a) } trackValue(e, i) { return this.subject.asObservable().pipe(Da(r => r.element === e && r.key === i)) } updateStyles() { this.elementMap.forEach((e, i) => { const r = new Set(this.elementKeyMap.get(i)); let s = this.getActivatedValues(e); s && s.forEach((o, a) => { this.updateElement(i, a, o), r.delete(a) }), r.forEach(o => { if (s = this.getActivatedValues(e, o), s) { const a = s.get(o); this.updateElement(i, o, a) } else this.clearElement(i, o) }) }) } clearElement(e, i) { const r = this.clearMap.get(e); if (r) { const s = r.get(i); s && (s(), this.subject.next({ element: e, key: i, value: "" })) } } updateElement(e, i, r) { const s = this.updateMap.get(e); if (s) { const o = s.get(i); o && (o(r), this.subject.next({ element: e, key: i, value: r })) } } releaseElement(e) { const i = this.watcherMap.get(e); i && (i.forEach(s => s.unsubscribe()), this.watcherMap.delete(e)); const r = this.elementMap.get(e); r && (r.forEach((s, o) => r.delete(o)), this.elementMap.delete(e)) } triggerUpdate(e, i) { const r = this.elementMap.get(e); if (r) { const s = this.getActivatedValues(r, i); s && (i ? this.updateElement(e, i, s.get(i)) : s.forEach((o, a) => this.updateElement(e, a, o))) } } buildElementKeyMap(e, i) { let r = this.elementKeyMap.get(e); r || (r = new Set, this.elementKeyMap.set(e, r)), r.add(i) } watchExtraTriggers(e, i, r) { if (r && r.length) { let s = this.watcherMap.get(e); if (s || (s = new Map, this.watcherMap.set(e, s)), !s.get(i)) { const a = uo(...r).subscribe(() => { const l = this.getValue(e, i); this.updateElement(e, i, l) }); s.set(i, a) } } } findByQuery(e) { return this.breakpoints.findByQuery(e) } getActivatedValues(e, i) { for (let s = 0; s < this.activatedBreakpoints.length; s++) { const a = e.get(this.activatedBreakpoints[s].alias); if (a && (void 0 === i || a.has(i) && null != a.get(i))) return a } const r = e.get(""); return void 0 === i || r && r.has(i) ? r : void 0 } observeActivations() { const i = this.breakpoints.items.map(r => r.mediaQuery); this.matchMedia.observe(this.hook.withPrintQuery(i)).pipe(bu(this.hook.interceptEvents(this)), Da(this.hook.blockPropagation())).subscribe(this.onMediaChange.bind(this)) } } return n.\u0275fac = function (e) { return new (e || n)(m(Cu), m(Oa), m(UM)) }, n.\u0275prov = E({ factory: function () { return new n(m(Cu), m(Oa), m(UM)) }, token: n, providedIn: "root" }), n })(); function KM(n, t, e, i) { if (void 0 !== i) { let r = n.get(t); r || (r = new Map, n.set(t, r)), r.set(e, i) } } let G3 = (() => { class n extends Pe { constructor(e, i, r, s, o, a, l) { super(e, null, i, r), this.ngClassInstance = l, this.DIRECTIVE_KEY = "ngClass", this.ngClassInstance || (this.ngClassInstance = new jh(s, o, e, a)), this.init(), this.setValue("", "") } set klass(e) { this.ngClassInstance.klass = e, this.setValue(e, "") } updateWithValue(e) { this.ngClassInstance.ngClass = e, this.ngClassInstance.ngDoCheck() } ngDoCheck() { this.ngClassInstance.ngDoCheck() } } return n.\u0275fac = function (e) { return new (e || n)(g(O), g(Re), g(Le), g(_r), g(Li), g(pi), g(jh, 10)) }, n.\u0275dir = C({ type: n, inputs: { klass: ["class", "klass"] }, features: [D] }), n })(); const $3 = ["ngClass", "ngClass.xs", "ngClass.sm", "ngClass.md", "ngClass.lg", "ngClass.xl", "ngClass.lt-sm", "ngClass.lt-md", "ngClass.lt-lg", "ngClass.lt-xl", "ngClass.gt-xs", "ngClass.gt-sm", "ngClass.gt-md", "ngClass.gt-lg"]; let wu = (() => { class n extends G3 { constructor() { super(...arguments), this.inputs = $3 } } return n.\u0275fac = function () { let t; return function (i) { return (t || (t = P(n)))(i || n) } }(), n.\u0275dir = C({ type: n, selectors: [["", "ngClass", ""], ["", "ngClass.xs", ""], ["", "ngClass.sm", ""], ["", "ngClass.md", ""], ["", "ngClass.lg", ""], ["", "ngClass.xl", ""], ["", "ngClass.lt-sm", ""], ["", "ngClass.lt-md", ""], ["", "ngClass.lt-lg", ""], ["", "ngClass.lt-xl", ""], ["", "ngClass.gt-xs", ""], ["", "ngClass.gt-sm", ""], ["", "ngClass.gt-md", ""], ["", "ngClass.gt-lg", ""]], inputs: { ngClass: "ngClass", "ngClass.xs": "ngClass.xs", "ngClass.sm": "ngClass.sm", "ngClass.md": "ngClass.md", "ngClass.lg": "ngClass.lg", "ngClass.xl": "ngClass.xl", "ngClass.lt-sm": "ngClass.lt-sm", "ngClass.lt-md": "ngClass.lt-md", "ngClass.lt-lg": "ngClass.lt-lg", "ngClass.lt-xl": "ngClass.lt-xl", "ngClass.gt-xs": "ngClass.gt-xs", "ngClass.gt-sm": "ngClass.gt-sm", "ngClass.gt-md": "ngClass.gt-md", "ngClass.gt-lg": "ngClass.gt-lg" }, features: [D] }), n })(), U3 = (() => { class n extends We { buildStyles(e, i) { return { display: "true" === e ? i.display || (i.isServer ? "initial" : "") : "none" } } } return n.\u0275fac = function () { let t; return function (i) { return (t || (t = P(n)))(i || n) } }(), n.\u0275prov = E({ factory: function () { return new n }, token: n, providedIn: "root" }), n })(), z3 = (() => { class n extends Pe { constructor(e, i, r, s, o, a, l) { super(e, i, r, s), this.layoutConfig = o, this.platformId = a, this.serverModuleLoaded = l, this.DIRECTIVE_KEY = "show-hide", this.display = "", this.hasLayout = !1, this.hasFlexChild = !1 } ngAfterViewInit() { this.trackExtraTriggers(); const e = Array.from(this.nativeElement.children); for (let r = 0; r < e.length; r++)if (this.marshal.hasValue(e[r], "flex")) { this.hasFlexChild = !0; break } Cg.has(this.nativeElement) ? this.display = Cg.get(this.nativeElement) : (this.display = this.getDisplayStyle(), Cg.set(this.nativeElement, this.display)), this.init(); const i = this.marshal.getValue(this.nativeElement, this.DIRECTIVE_KEY, ""); void 0 === i || "" === i ? this.setValue(!0, "") : this.triggerUpdate() } ngOnChanges(e) { Object.keys(e).forEach(i => { if (-1 !== this.inputs.indexOf(i)) { const r = i.split("."), s = r.slice(1).join("."), o = e[i].currentValue; let a = "" === o || 0 !== o && Te(o); "fxHide" === r[0] && (a = !a), this.setValue(a, s) } }) } trackExtraTriggers() { this.hasLayout = this.marshal.hasValue(this.nativeElement, "layout"), ["layout", "layout-align"].forEach(e => { this.marshal.trackValue(this.nativeElement, e).pipe(pt(this.destroySubject)).subscribe(this.triggerUpdate.bind(this)) }) } getDisplayStyle() { return this.hasLayout || this.hasFlexChild && this.layoutConfig.addFlexToParent ? "flex" : this.styler.lookupStyle(this.nativeElement, "display", !0) } updateWithValue(e = !0) { if ("" === e) return; const i = Gs(this.platformId); this.addStyles(e ? "true" : "false", { display: this.display, isServer: i }), i && this.serverModuleLoaded && this.nativeElement.style.setProperty("display", ""), this.marshal.triggerUpdate(this.parentElement, "layout-gap") } } return n.\u0275fac = function (e) { return new (e || n)(g(O), g(U3), g(Re), g(Le), g(Vn), g(bt), g(Lr)) }, n.\u0275dir = C({ type: n, features: [D, nt] }), n })(); const Cg = new WeakMap, W3 = ["fxShow", "fxShow.print", "fxShow.xs", "fxShow.sm", "fxShow.md", "fxShow.lg", "fxShow.xl", "fxShow.lt-sm", "fxShow.lt-md", "fxShow.lt-lg", "fxShow.lt-xl", "fxShow.gt-xs", "fxShow.gt-sm", "fxShow.gt-md", "fxShow.gt-lg", "fxHide", "fxHide.print", "fxHide.xs", "fxHide.sm", "fxHide.md", "fxHide.lg", "fxHide.xl", "fxHide.lt-sm", "fxHide.lt-md", "fxHide.lt-lg", "fxHide.lt-xl", "fxHide.gt-xs", "fxHide.gt-sm", "fxHide.gt-md", "fxHide.gt-lg"]; let QM = (() => { class n extends z3 { constructor() { super(...arguments), this.inputs = W3 } } return n.\u0275fac = function () { let t; return function (i) { return (t || (t = P(n)))(i || n) } }(), n.\u0275dir = C({ type: n, selectors: [["", "fxShow", ""], ["", "fxShow.print", ""], ["", "fxShow.xs", ""], ["", "fxShow.sm", ""], ["", "fxShow.md", ""], ["", "fxShow.lg", ""], ["", "fxShow.xl", ""], ["", "fxShow.lt-sm", ""], ["", "fxShow.lt-md", ""], ["", "fxShow.lt-lg", ""], ["", "fxShow.lt-xl", ""], ["", "fxShow.gt-xs", ""], ["", "fxShow.gt-sm", ""], ["", "fxShow.gt-md", ""], ["", "fxShow.gt-lg", ""], ["", "fxHide", ""], ["", "fxHide.print", ""], ["", "fxHide.xs", ""], ["", "fxHide.sm", ""], ["", "fxHide.md", ""], ["", "fxHide.lg", ""], ["", "fxHide.xl", ""], ["", "fxHide.lt-sm", ""], ["", "fxHide.lt-md", ""], ["", "fxHide.lt-lg", ""], ["", "fxHide.lt-xl", ""], ["", "fxHide.gt-xs", ""], ["", "fxHide.gt-sm", ""], ["", "fxHide.gt-md", ""], ["", "fxHide.gt-lg", ""]], inputs: { fxShow: "fxShow", "fxShow.print": "fxShow.print", "fxShow.xs": "fxShow.xs", "fxShow.sm": "fxShow.sm", "fxShow.md": "fxShow.md", "fxShow.lg": "fxShow.lg", "fxShow.xl": "fxShow.xl", "fxShow.lt-sm": "fxShow.lt-sm", "fxShow.lt-md": "fxShow.lt-md", "fxShow.lt-lg": "fxShow.lt-lg", "fxShow.lt-xl": "fxShow.lt-xl", "fxShow.gt-xs": "fxShow.gt-xs", "fxShow.gt-sm": "fxShow.gt-sm", "fxShow.gt-md": "fxShow.gt-md", "fxShow.gt-lg": "fxShow.gt-lg", fxHide: "fxHide", "fxHide.print": "fxHide.print", "fxHide.xs": "fxHide.xs", "fxHide.sm": "fxHide.sm", "fxHide.md": "fxHide.md", "fxHide.lg": "fxHide.lg", "fxHide.xl": "fxHide.xl", "fxHide.lt-sm": "fxHide.lt-sm", "fxHide.lt-md": "fxHide.lt-md", "fxHide.lt-lg": "fxHide.lt-lg", "fxHide.lt-xl": "fxHide.lt-xl", "fxHide.gt-xs": "fxHide.gt-xs", "fxHide.gt-sm": "fxHide.gt-sm", "fxHide.gt-md": "fxHide.gt-md", "fxHide.gt-lg": "fxHide.gt-lg" }, features: [D] }), n })(), tA = (() => { class n { } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275mod = ee({ type: n }), n.\u0275inj = X({ imports: [[_g]] }), n })(); class eU { constructor(t) { this.selector = t } call(t, e) { return e.subscribe(new tU(t, this.selector, this.caught)) } } class tU extends lo { constructor(t, e, i) { super(t), this.selector = e, this.caught = i } error(t) { if (!this.isStopped) { let e; try { e = this.selector(t, this.caught) } catch (s) { return void super.error(s) } this._unsubscribeAndRecycle(); const i = new ao(this); this.add(i); const r = co(e, i); r !== i && this.add(r) } } } class iU { constructor(t) { this.callback = t } call(t, e) { return e.subscribe(new rU(t, this.callback)) } } class rU extends Ie { constructor(t, e) { super(t), this.add(new he(e)) } } class nA { } class wi { constructor(t) { this.normalizedNames = new Map, this.lazyUpdate = null, t ? this.lazyInit = "string" == typeof t ? () => { this.headers = new Map, t.split("\n").forEach(e => { const i = e.indexOf(":"); if (i > 0) { const r = e.slice(0, i), s = r.toLowerCase(), o = e.slice(i + 1).trim(); this.maybeSetNormalizedName(r, s), this.headers.has(s) ? this.headers.get(s).push(o) : this.headers.set(s, [o]) } }) } : () => { this.headers = new Map, Object.keys(t).forEach(e => { let i = t[e]; const r = e.toLowerCase(); "string" == typeof i && (i = [i]), i.length > 0 && (this.headers.set(r, i), this.maybeSetNormalizedName(e, r)) }) } : this.headers = new Map } has(t) { return this.init(), this.headers.has(t.toLowerCase()) } get(t) { this.init(); const e = this.headers.get(t.toLowerCase()); return e && e.length > 0 ? e[0] : null } keys() { return this.init(), Array.from(this.normalizedNames.values()) } getAll(t) { return this.init(), this.headers.get(t.toLowerCase()) || null } append(t, e) { return this.clone({ name: t, value: e, op: "a" }) } set(t, e) { return this.clone({ name: t, value: e, op: "s" }) } delete(t, e) { return this.clone({ name: t, value: e, op: "d" }) } maybeSetNormalizedName(t, e) { this.normalizedNames.has(e) || this.normalizedNames.set(e, t) } init() { this.lazyInit && (this.lazyInit instanceof wi ? this.copyFrom(this.lazyInit) : this.lazyInit(), this.lazyInit = null, this.lazyUpdate && (this.lazyUpdate.forEach(t => this.applyUpdate(t)), this.lazyUpdate = null)) } copyFrom(t) { t.init(), Array.from(t.headers.keys()).forEach(e => { this.headers.set(e, t.headers.get(e)), this.normalizedNames.set(e, t.normalizedNames.get(e)) }) } clone(t) { const e = new wi; return e.lazyInit = this.lazyInit && this.lazyInit instanceof wi ? this.lazyInit : this, e.lazyUpdate = (this.lazyUpdate || []).concat([t]), e } applyUpdate(t) { const e = t.name.toLowerCase(); switch (t.op) { case "a": case "s": let i = t.value; if ("string" == typeof i && (i = [i]), 0 === i.length) return; this.maybeSetNormalizedName(t.name, e); const r = ("a" === t.op ? this.headers.get(e) : void 0) || []; r.push(...i), this.headers.set(e, r); break; case "d": const s = t.value; if (s) { let o = this.headers.get(e); if (!o) return; o = o.filter(a => -1 === s.indexOf(a)), 0 === o.length ? (this.headers.delete(e), this.normalizedNames.delete(e)) : this.headers.set(e, o) } else this.headers.delete(e), this.normalizedNames.delete(e) } } forEach(t) { this.init(), Array.from(this.normalizedNames.keys()).forEach(e => t(this.normalizedNames.get(e), this.headers.get(e))) } } class oU { encodeKey(t) { return rA(t) } encodeValue(t) { return rA(t) } decodeKey(t) { return decodeURIComponent(t) } decodeValue(t) { return decodeURIComponent(t) } } function rA(n) { return encodeURIComponent(n).replace(/%40/gi, "@").replace(/%3A/gi, ":").replace(/%24/gi, "$").replace(/%2C/gi, ",").replace(/%3B/gi, ";").replace(/%2B/gi, "+").replace(/%3D/gi, "=").replace(/%3F/gi, "?").replace(/%2F/gi, "/") } function sA(n) { return `${n}` } class Ji { constructor(t = {}) { if (this.updates = null, this.cloneFrom = null, this.encoder = t.encoder || new oU, t.fromString) { if (t.fromObject) throw new Error("Cannot specify both fromString and fromObject."); this.map = function (n, t) { const e = new Map; return n.length > 0 && n.replace(/^\?/, "").split("&").forEach(r => { const s = r.indexOf("="), [o, a] = -1 == s ? [t.decodeKey(r), ""] : [t.decodeKey(r.slice(0, s)), t.decodeValue(r.slice(s + 1))], l = e.get(o) || []; l.push(a), e.set(o, l) }), e }(t.fromString, this.encoder) } else t.fromObject ? (this.map = new Map, Object.keys(t.fromObject).forEach(e => { const i = t.fromObject[e]; this.map.set(e, Array.isArray(i) ? i : [i]) })) : this.map = null } has(t) { return this.init(), this.map.has(t) } get(t) { this.init(); const e = this.map.get(t); return e ? e[0] : null } getAll(t) { return this.init(), this.map.get(t) || null } keys() { return this.init(), Array.from(this.map.keys()) } append(t, e) { return this.clone({ param: t, value: e, op: "a" }) } appendAll(t) { const e = []; return Object.keys(t).forEach(i => { const r = t[i]; Array.isArray(r) ? r.forEach(s => { e.push({ param: i, value: s, op: "a" }) }) : e.push({ param: i, value: r, op: "a" }) }), this.clone(e) } set(t, e) { return this.clone({ param: t, value: e, op: "s" }) } delete(t, e) { return this.clone({ param: t, value: e, op: "d" }) } toString() { return this.init(), this.keys().map(t => { const e = this.encoder.encodeKey(t); return this.map.get(t).map(i => e + "=" + this.encoder.encodeValue(i)).join("&") }).filter(t => "" !== t).join("&") } clone(t) { const e = new Ji({ encoder: this.encoder }); return e.cloneFrom = this.cloneFrom || this, e.updates = (this.updates || []).concat(t), e } init() { null === this.map && (this.map = new Map), null !== this.cloneFrom && (this.cloneFrom.init(), this.cloneFrom.keys().forEach(t => this.map.set(t, this.cloneFrom.map.get(t))), this.updates.forEach(t => { switch (t.op) { case "a": case "s": const e = ("a" === t.op ? this.map.get(t.param) : void 0) || []; e.push(sA(t.value)), this.map.set(t.param, e); break; case "d": if (void 0 === t.value) { this.map.delete(t.param); break } { let i = this.map.get(t.param) || []; const r = i.indexOf(sA(t.value)); -1 !== r && i.splice(r, 1), i.length > 0 ? this.map.set(t.param, i) : this.map.delete(t.param) } } }), this.cloneFrom = this.updates = null) } } class lU { constructor() { this.map = new Map } set(t, e) { return this.map.set(t, e), this } get(t) { return this.map.has(t) || this.map.set(t, t.defaultValue()), this.map.get(t) } delete(t) { return this.map.delete(t), this } keys() { return this.map.keys() } } function oA(n) { return "undefined" != typeof ArrayBuffer && n instanceof ArrayBuffer } function aA(n) { return "undefined" != typeof Blob && n instanceof Blob } function lA(n) { return "undefined" != typeof FormData && n instanceof FormData } class Na { constructor(t, e, i, r) { let s; if (this.url = e, this.body = null, this.reportProgress = !1, this.withCredentials = !1, this.responseType = "json", this.method = t.toUpperCase(), function (n) { switch (n) { case "DELETE": case "GET": case "HEAD": case "OPTIONS": case "JSONP": return !1; default: return !0 } }(this.method) || r ? (this.body = void 0 !== i ? i : null, s = r) : s = i, s && (this.reportProgress = !!s.reportProgress, this.withCredentials = !!s.withCredentials, s.responseType && (this.responseType = s.responseType), s.headers && (this.headers = s.headers), s.context && (this.context = s.context), s.params && (this.params = s.params)), this.headers || (this.headers = new wi), this.context || (this.context = new lU), this.params) { const o = this.params.toString(); if (0 === o.length) this.urlWithParams = e; else { const a = e.indexOf("?"); this.urlWithParams = e + (-1 === a ? "?" : a < e.length - 1 ? "&" : "") + o } } else this.params = new Ji, this.urlWithParams = e } serializeBody() { return null === this.body ? null : oA(this.body) || aA(this.body) || lA(this.body) || function (n) { return "undefined" != typeof URLSearchParams && n instanceof URLSearchParams }(this.body) || "string" == typeof this.body ? this.body : this.body instanceof Ji ? this.body.toString() : "object" == typeof this.body || "boolean" == typeof this.body || Array.isArray(this.body) ? JSON.stringify(this.body) : this.body.toString() } detectContentTypeHeader() { return null === this.body || lA(this.body) ? null : aA(this.body) ? this.body.type || null : oA(this.body) ? null : "string" == typeof this.body ? "text/plain" : this.body instanceof Ji ? "application/x-www-form-urlencoded;charset=UTF-8" : "object" == typeof this.body || "number" == typeof this.body || "boolean" == typeof this.body ? "application/json" : null } clone(t = {}) { var e; const i = t.method || this.method, r = t.url || this.url, s = t.responseType || this.responseType, o = void 0 !== t.body ? t.body : this.body, a = void 0 !== t.withCredentials ? t.withCredentials : this.withCredentials, l = void 0 !== t.reportProgress ? t.reportProgress : this.reportProgress; let c = t.headers || this.headers, u = t.params || this.params; const d = null !== (e = t.context) && void 0 !== e ? e : this.context; return void 0 !== t.setHeaders && (c = Object.keys(t.setHeaders).reduce((f, h) => f.set(h, t.setHeaders[h]), c)), t.setParams && (u = Object.keys(t.setParams).reduce((f, h) => f.set(h, t.setParams[h]), u)), new Na(i, r, o, { params: u, headers: c, context: d, reportProgress: l, responseType: s, withCredentials: a }) } } var et = (() => ((et = et || {})[et.Sent = 0] = "Sent", et[et.UploadProgress = 1] = "UploadProgress", et[et.ResponseHeader = 2] = "ResponseHeader", et[et.DownloadProgress = 3] = "DownloadProgress", et[et.Response = 4] = "Response", et[et.User = 5] = "User", et))(); class Eu extends class { constructor(t, e = 200, i = "OK") { this.headers = t.headers || new wi, this.status = void 0 !== t.status ? t.status : e, this.statusText = t.statusText || i, this.url = t.url || null, this.ok = this.status >= 200 && this.status < 300 } }{ constructor(t = {}) { super(t), this.type = et.Response, this.body = void 0 !== t.body ? t.body : null } clone(t = {}) { return new Eu({ body: void 0 !== t.body ? t.body : this.body, headers: t.headers || this.headers, status: void 0 !== t.status ? t.status : this.status, statusText: t.statusText || this.statusText, url: t.url || this.url || void 0 }) } } function Dg(n, t) { return { body: t, headers: n.headers, context: n.context, observe: n.observe, params: n.params, reportProgress: n.reportProgress, responseType: n.responseType, withCredentials: n.withCredentials } } let Du = (() => { class n { constructor(e) { this.handler = e } request(e, i, r = {}) { let s; if (e instanceof Na) s = e; else { let l, c; l = r.headers instanceof wi ? r.headers : new wi(r.headers), r.params && (c = r.params instanceof Ji ? r.params : new Ji({ fromObject: r.params })), s = new Na(e, i, void 0 !== r.body ? r.body : null, { headers: l, context: r.context, params: c, reportProgress: r.reportProgress, responseType: r.responseType || "json", withCredentials: r.withCredentials }) } const o = pn(s).pipe(function (n, t) { return Ou(n, void 0, 1) }(l => this.handler.handle(l))); if (e instanceof Na || "events" === r.observe) return o; const a = o.pipe(Da(l => l instanceof Eu)); switch (r.observe || "body") { case "body": switch (s.responseType) { case "arraybuffer": return a.pipe(Dt(l => { if (null !== l.body && !(l.body instanceof ArrayBuffer)) throw new Error("Response is not an ArrayBuffer."); return l.body })); case "blob": return a.pipe(Dt(l => { if (null !== l.body && !(l.body instanceof Blob)) throw new Error("Response is not a Blob."); return l.body })); case "text": return a.pipe(Dt(l => { if (null !== l.body && "string" != typeof l.body) throw new Error("Response is not a string."); return l.body })); case "json": default: return a.pipe(Dt(l => l.body)) }case "response": return a; default: throw new Error(`Unreachable: unhandled observe type ${r.observe}}`) } } delete(e, i = {}) { return this.request("DELETE", e, i) } get(e, i = {}) { return this.request("GET", e, i) } head(e, i = {}) { return this.request("HEAD", e, i) } jsonp(e, i) { return this.request("JSONP", e, { params: (new Ji).append(i, "JSONP_CALLBACK"), observe: "body", responseType: "json" }) } options(e, i = {}) { return this.request("OPTIONS", e, i) } patch(e, i, r = {}) { return this.request("PATCH", e, Dg(r, i)) } post(e, i, r = {}) { return this.request("POST", e, Dg(r, i)) } put(e, i, r = {}) { return this.request("PUT", e, Dg(r, i)) } } return n.\u0275fac = function (e) { return new (e || n)(m(nA)) }, n.\u0275prov = E({ token: n, factory: n.\u0275fac }), n })(); const _U = ["*"]; function pA(n) { return Error(`Unable to find icon with the name "${n}"`) } function gA(n) { return Error(`The URL provided to MatIconRegistry was not trusted as a resource URL via Angular's DomSanitizer. Attempted URL was "${n}".`) } function mA(n) { return Error(`The literal provided to MatIconRegistry was not trusted as safe HTML by Angular's DomSanitizer. Attempted literal was "${n}".`) } class Vr { constructor(t, e, i) { this.url = t, this.svgText = e, this.options = i } } let xu = (() => { class n { constructor(e, i, r, s) { this._httpClient = e, this._sanitizer = i, this._errorHandler = s, this._svgIconConfigs = new Map, this._iconSetConfigs = new Map, this._cachedIconsByUrl = new Map, this._inProgressUrlFetches = new Map, this._fontCssClassesByAlias = new Map, this._resolvers = [], this._defaultFontSetClass = "material-icons", this._document = r } addSvgIcon(e, i, r) { return this.addSvgIconInNamespace("", e, i, r) } addSvgIconLiteral(e, i, r) { return this.addSvgIconLiteralInNamespace("", e, i, r) } addSvgIconInNamespace(e, i, r, s) { return this._addSvgIconConfig(e, i, new Vr(r, null, s)) } addSvgIconResolver(e) { return this._resolvers.push(e), this } addSvgIconLiteralInNamespace(e, i, r, s) { const o = this._sanitizer.sanitize(de.HTML, r); if (!o) throw mA(r); return this._addSvgIconConfig(e, i, new Vr("", o, s)) } addSvgIconSet(e, i) { return this.addSvgIconSetInNamespace("", e, i) } addSvgIconSetLiteral(e, i) { return this.addSvgIconSetLiteralInNamespace("", e, i) } addSvgIconSetInNamespace(e, i, r) { return this._addSvgIconSetConfig(e, new Vr(i, null, r)) } addSvgIconSetLiteralInNamespace(e, i, r) { const s = this._sanitizer.sanitize(de.HTML, i); if (!s) throw mA(i); return this._addSvgIconSetConfig(e, new Vr("", s, r)) } registerFontClassAlias(e, i = e) { return this._fontCssClassesByAlias.set(e, i), this } classNameForFontAlias(e) { return this._fontCssClassesByAlias.get(e) || e } setDefaultFontSetClass(e) { return this._defaultFontSetClass = e, this } getDefaultFontSetClass() { return this._defaultFontSetClass } getSvgIconFromUrl(e) { const i = this._sanitizer.sanitize(de.RESOURCE_URL, e); if (!i) throw gA(e); const r = this._cachedIconsByUrl.get(i); return r ? pn(Mu(r)) : this._loadSvgIconFromConfig(new Vr(e, null)).pipe(bu(s => this._cachedIconsByUrl.set(i, s)), Dt(s => Mu(s))) } getNamedSvgIcon(e, i = "") { const r = _A(i, e); let s = this._svgIconConfigs.get(r); if (s) return this._getSvgFromConfig(s); if (s = this._getIconConfigFromResolvers(i, e), s) return this._svgIconConfigs.set(r, s), this._getSvgFromConfig(s); const o = this._iconSetConfigs.get(i); return o ? this._getSvgFromIconSetConfigs(e, o) : gD(pA(r)) } ngOnDestroy() { this._resolvers = [], this._svgIconConfigs.clear(), this._iconSetConfigs.clear(), this._cachedIconsByUrl.clear() } _getSvgFromConfig(e) { return e.svgText ? pn(Mu(this._svgElementFromConfig(e))) : this._loadSvgIconFromConfig(e).pipe(Dt(i => Mu(i))) } _getSvgFromIconSetConfigs(e, i) { const r = this._extractIconWithNameFromAnySet(e, i); return r ? pn(r) : rE(i.filter(o => !o.svgText).map(o => this._loadSvgIconSetFromConfig(o).pipe(function (n) { return function (e) { const i = new eU(n), r = e.lift(i); return i.caught = r } }(a => { const c = `Loading icon set URL: ${this._sanitizer.sanitize(de.RESOURCE_URL, o.url)} failed: ${a.message}`; return this._errorHandler.handleError(new Error(c)), pn(null) })))).pipe(Dt(() => { const o = this._extractIconWithNameFromAnySet(e, i); if (!o) throw pA(e); return o })) } _extractIconWithNameFromAnySet(e, i) { for (let r = i.length - 1; r >= 0; r--) { const s = i[r]; if (s.svgText && s.svgText.indexOf(e) > -1) { const o = this._svgElementFromConfig(s), a = this._extractSvgIconFromSet(o, e, s.options); if (a) return a } } return null } _loadSvgIconFromConfig(e) { return this._fetchIcon(e).pipe(bu(i => e.svgText = i), Dt(() => this._svgElementFromConfig(e))) } _loadSvgIconSetFromConfig(e) { return e.svgText ? pn(null) : this._fetchIcon(e).pipe(bu(i => e.svgText = i)) } _extractSvgIconFromSet(e, i, r) { const s = e.querySelector(`[id="${i}"]`); if (!s) return null; const o = s.cloneNode(!0); if (o.removeAttribute("id"), "svg" === o.nodeName.toLowerCase()) return this._setSvgAttributes(o, r); if ("symbol" === o.nodeName.toLowerCase()) return this._setSvgAttributes(this._toSvgElement(o), r); const a = this._svgElementFromString("<svg></svg>"); return a.appendChild(o), this._setSvgAttributes(a, r) } _svgElementFromString(e) { const i = this._document.createElement("DIV"); i.innerHTML = e; const r = i.querySelector("svg"); if (!r) throw Error("<svg> tag not found"); return r } _toSvgElement(e) { const i = this._svgElementFromString("<svg></svg>"), r = e.attributes; for (let s = 0; s < r.length; s++) { const { name: o, value: a } = r[s]; "id" !== o && i.setAttribute(o, a) } for (let s = 0; s < e.childNodes.length; s++)e.childNodes[s].nodeType === this._document.ELEMENT_NODE && i.appendChild(e.childNodes[s].cloneNode(!0)); return i } _setSvgAttributes(e, i) { return e.setAttribute("fit", ""), e.setAttribute("height", "100%"), e.setAttribute("width", "100%"), e.setAttribute("preserveAspectRatio", "xMidYMid meet"), e.setAttribute("focusable", "false"), i && i.viewBox && e.setAttribute("viewBox", i.viewBox), e } _fetchIcon(e) { var i; const { url: r, options: s } = e, o = null !== (i = null == s ? void 0 : s.withCredentials) && void 0 !== i && i; if (!this._httpClient) throw Error("Could not find HttpClient provider for use with Angular Material icons. Please include the HttpClientModule from @angular/common/http in your app imports."); if (null == r) throw Error(`Cannot fetch icon from URL "${r}".`); const a = this._sanitizer.sanitize(de.RESOURCE_URL, r); if (!a) throw gA(r); const l = this._inProgressUrlFetches.get(a); if (l) return l; const c = this._httpClient.get(a, { responseType: "text", withCredentials: o }).pipe(function (n) { return t => t.lift(new iU(n)) }(() => this._inProgressUrlFetches.delete(a)), qg()); return this._inProgressUrlFetches.set(a, c), c } _addSvgIconConfig(e, i, r) { return this._svgIconConfigs.set(_A(e, i), r), this } _addSvgIconSetConfig(e, i) { const r = this._iconSetConfigs.get(e); return r ? r.push(i) : this._iconSetConfigs.set(e, [i]), this } _svgElementFromConfig(e) { if (!e.svgElement) { const i = this._svgElementFromString(e.svgText); this._setSvgAttributes(i, e.options), e.svgElement = i } return e.svgElement } _getIconConfigFromResolvers(e, i) { for (let r = 0; r < this._resolvers.length; r++) { const s = this._resolvers[r](i, e); if (s) return bU(s) ? new Vr(s.url, null, s.options) : new Vr(s, null) } } } return n.\u0275fac = function (e) { return new (e || n)(m(Du, 8), m(xr), m(N, 8), m(wn)) }, n.\u0275prov = E({ factory: function () { return new n(m(Du, 8), m(xr), m(N, 8), m(wn)) }, token: n, providedIn: "root" }), n })(); function Mu(n) { return n.cloneNode(!0) } function _A(n, t) { return n + ":" + t } function bU(n) { return !(!n.url || !n.options) } const CU = mu(class { constructor(n) { this._elementRef = n } }), wU = new k("mat-icon-location", { providedIn: "root", factory: function () { const n = Ao(N), t = n ? n.location : null; return { getPathname: () => t ? t.pathname + t.search : "" } } }), yA = ["clip-path", "color-profile", "src", "cursor", "fill", "filter", "marker", "marker-start", "marker-mid", "marker-end", "mask", "stroke"], xU = yA.map(n => `[${n}]`).join(", "), MU = /^url\(['"]?#(.*?)['"]?\)$/; let vA = (() => { class n extends CU { constructor(e, i, r, s, o) { super(e), this._iconRegistry = i, this._location = s, this._errorHandler = o, this._inline = !1, this._currentIconFetch = he.EMPTY, r || e.nativeElement.setAttribute("aria-hidden", "true") } get inline() { return this._inline } set inline(e) { this._inline = Te(e) } get svgIcon() { return this._svgIcon } set svgIcon(e) { e !== this._svgIcon && (e ? this._updateSvgIcon(e) : this._svgIcon && this._clearSvgElement(), this._svgIcon = e) } get fontSet() { return this._fontSet } set fontSet(e) { const i = this._cleanupFontValue(e); i !== this._fontSet && (this._fontSet = i, this._updateFontIconClasses()) } get fontIcon() { return this._fontIcon } set fontIcon(e) { const i = this._cleanupFontValue(e); i !== this._fontIcon && (this._fontIcon = i, this._updateFontIconClasses()) } _splitIconName(e) { if (!e) return ["", ""]; const i = e.split(":"); switch (i.length) { case 1: return ["", i[0]]; case 2: return i; default: throw Error(`Invalid icon name: "${e}"`) } } ngOnInit() { this._updateFontIconClasses() } ngAfterViewChecked() { const e = this._elementsWithExternalReferences; if (e && e.size) { const i = this._location.getPathname(); i !== this._previousPath && (this._previousPath = i, this._prependPathToReferences(i)) } } ngOnDestroy() { this._currentIconFetch.unsubscribe(), this._elementsWithExternalReferences && this._elementsWithExternalReferences.clear() } _usingFontIcon() { return !this.svgIcon } _setSvgElement(e) { this._clearSvgElement(); const i = e.querySelectorAll("style"); for (let s = 0; s < i.length; s++)i[s].textContent += " "; const r = this._location.getPathname(); this._previousPath = r, this._cacheChildrenWithExternalReferences(e), this._prependPathToReferences(r), this._elementRef.nativeElement.appendChild(e) } _clearSvgElement() { const e = this._elementRef.nativeElement; let i = e.childNodes.length; for (this._elementsWithExternalReferences && this._elementsWithExternalReferences.clear(); i--;) { const r = e.childNodes[i]; (1 !== r.nodeType || "svg" === r.nodeName.toLowerCase()) && e.removeChild(r) } } _updateFontIconClasses() { if (!this._usingFontIcon()) return; const e = this._elementRef.nativeElement, i = this.fontSet ? this._iconRegistry.classNameForFontAlias(this.fontSet) : this._iconRegistry.getDefaultFontSetClass(); i != this._previousFontSetClass && (this._previousFontSetClass && e.classList.remove(this._previousFontSetClass), i && e.classList.add(i), this._previousFontSetClass = i), this.fontIcon != this._previousFontIconClass && (this._previousFontIconClass && e.classList.remove(this._previousFontIconClass), this.fontIcon && e.classList.add(this.fontIcon), this._previousFontIconClass = this.fontIcon) } _cleanupFontValue(e) { return "string" == typeof e ? e.trim().split(" ")[0] : e } _prependPathToReferences(e) { const i = this._elementsWithExternalReferences; i && i.forEach((r, s) => { r.forEach(o => { s.setAttribute(o.name, `url('${e}#${o.value}')`) }) }) } _cacheChildrenWithExternalReferences(e) { const i = e.querySelectorAll(xU), r = this._elementsWithExternalReferences = this._elementsWithExternalReferences || new Map; for (let s = 0; s < i.length; s++)yA.forEach(o => { const a = i[s], l = a.getAttribute(o), c = l ? l.match(MU) : null; if (c) { let u = r.get(a); u || (u = [], r.set(a, u)), u.push({ name: o, value: c[1] }) } }) } _updateSvgIcon(e) { if (this._svgNamespace = null, this._svgName = null, this._currentIconFetch.unsubscribe(), e) { const [i, r] = this._splitIconName(e); i && (this._svgNamespace = i), r && (this._svgName = r), this._currentIconFetch = this._iconRegistry.getNamedSvgIcon(r, i).pipe(Ks(1)).subscribe(s => this._setSvgElement(s), s => { this._errorHandler.handleError(new Error(`Error retrieving icon ${i}:${r}! ${s.message}`)) }) } } } return n.\u0275fac = function (e) { return new (e || n)(g(O), g(xu), function (n) { return function (n, t) { if ("class" === t) return n.classes; if ("style" === t) return n.styles; const e = n.attrs; if (e) { const i = e.length; let r = 0; for (; r < i;) { const s = e[r]; if (xm(s)) break; if (0 === s) r += 2; else if ("number" == typeof s) for (r++; r < i && "string" == typeof e[r];)r++; else { if (s === t) return e[r + 1]; r += 2 } } } return null }(it(), n) }("aria-hidden"), g(wU), g(wn)) }, n.\u0275cmp = tt({ type: n, selectors: [["mat-icon"]], hostAttrs: ["role", "img", 1, "mat-icon", "notranslate"], hostVars: 7, hostBindings: function (e, i) { 2 & e && (Qe("data-mat-icon-type", i._usingFontIcon() ? "font" : "svg")("data-mat-icon-name", i._svgName || i.fontIcon)("data-mat-icon-namespace", i._svgNamespace || i.fontSet), je("mat-icon-inline", i.inline)("mat-icon-no-color", "primary" !== i.color && "accent" !== i.color && "warn" !== i.color)) }, inputs: { color: "color", inline: "inline", svgIcon: "svgIcon", fontSet: "fontSet", fontIcon: "fontIcon" }, exportAs: ["matIcon"], features: [D], ngContentSelectors: _U, decls: 1, vars: 0, template: function (e, i) { 1 & e && (an(), Ae(0)) }, styles: [".mat-icon{background-repeat:no-repeat;display:inline-block;fill:currentColor;height:24px;width:24px}.mat-icon.mat-icon-inline{font-size:inherit;height:inherit;line-height:inherit;width:inherit}[dir=rtl] .mat-icon-rtl-mirror{transform:scale(-1, 1)}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon{display:block}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon-button .mat-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon-button .mat-icon{margin:auto}\n"], encapsulation: 2, changeDetection: 0 }), n })(), AU = (() => { class n { } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275mod = ee({ type: n }), n.\u0275inj = X({ imports: [[at], at] }), n })(); const SU = function () { return { "app-toolbar": !0 } }; let TU = (() => { class n { constructor() { } ngOnInit() { } } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275cmp = tt({ type: n, selectors: [["app-navbar"]], decls: 5, vars: 2, consts: [[3, "ngClass.lt-sm"], ["aria-hidden", "false", "aria-label", "Example home icon"], [2, "margin", "0.5%"]], template: function (e, i) { 1 & e && (x(0, "mat-toolbar", 0), x(1, "mat-icon", 1), oe(2, "punch_clock"), M(), x(3, "span", 2), oe(4, "Chess Clock"), M(), M()), 2 & e && K("ngClass.lt-sm", Zn(1, SU)) }, directives: [d3, wu, vA], styles: [".app-toolbar[_ngcontent-%COMP%]{position:sticky;position:-webkit-sticky;top:0;z-index:1000}"] }), n })(); const Sg = "inline", Au = ["row", "column", "row-reverse", "column-reverse"]; function bA(n) { n = n ? n.toLowerCase() : ""; let [t, e, i] = n.split(" "); return Au.find(r => r === t) || (t = Au[0]), e === Sg && (e = i !== Sg ? i : "", i = Sg), [t, FU(e), !!i] } function Pa(n) { let [t] = bA(n); return t.indexOf("row") > -1 } function FU(n) { if (n) switch (n.toLowerCase()) { case "reverse": case "wrap-reverse": case "reverse-wrap": n = "wrap-reverse"; break; case "no": case "none": case "nowrap": n = "nowrap"; break; default: n = "wrap" }return n } let kU = (() => { class n extends We { buildStyles(e) { return function (n) { let [t, e, i] = bA(n); return function (n, t = null, e = !1) { return { display: e ? "inline-flex" : "flex", "box-sizing": "border-box", "flex-direction": n, "flex-wrap": t || null } }(t, e, i) }(e) } } return n.\u0275fac = function () { let t; return function (i) { return (t || (t = P(n)))(i || n) } }(), n.\u0275prov = E({ factory: function () { return new n }, token: n, providedIn: "root" }), n })(); const OU = ["fxLayout", "fxLayout.xs", "fxLayout.sm", "fxLayout.md", "fxLayout.lg", "fxLayout.xl", "fxLayout.lt-sm", "fxLayout.lt-md", "fxLayout.lt-lg", "fxLayout.lt-xl", "fxLayout.gt-xs", "fxLayout.gt-sm", "fxLayout.gt-md", "fxLayout.gt-lg"]; let NU = (() => { class n extends Pe { constructor(e, i, r, s) { super(e, r, i, s), this.DIRECTIVE_KEY = "layout", this.styleCache = PU, this.init() } } return n.\u0275fac = function (e) { return new (e || n)(g(O), g(Re), g(kU), g(Le)) }, n.\u0275dir = C({ type: n, features: [D] }), n })(), Tg = (() => { class n extends NU { constructor() { super(...arguments), this.inputs = OU } } return n.\u0275fac = function () { let t; return function (i) { return (t || (t = P(n)))(i || n) } }(), n.\u0275dir = C({ type: n, selectors: [["", "fxLayout", ""], ["", "fxLayout.xs", ""], ["", "fxLayout.sm", ""], ["", "fxLayout.md", ""], ["", "fxLayout.lg", ""], ["", "fxLayout.xl", ""], ["", "fxLayout.lt-sm", ""], ["", "fxLayout.lt-md", ""], ["", "fxLayout.lt-lg", ""], ["", "fxLayout.lt-xl", ""], ["", "fxLayout.gt-xs", ""], ["", "fxLayout.gt-sm", ""], ["", "fxLayout.gt-md", ""], ["", "fxLayout.gt-lg", ""]], inputs: { fxLayout: "fxLayout", "fxLayout.xs": "fxLayout.xs", "fxLayout.sm": "fxLayout.sm", "fxLayout.md": "fxLayout.md", "fxLayout.lg": "fxLayout.lg", "fxLayout.xl": "fxLayout.xl", "fxLayout.lt-sm": "fxLayout.lt-sm", "fxLayout.lt-md": "fxLayout.lt-md", "fxLayout.lt-lg": "fxLayout.lt-lg", "fxLayout.lt-xl": "fxLayout.lt-xl", "fxLayout.gt-xs": "fxLayout.gt-xs", "fxLayout.gt-sm": "fxLayout.gt-sm", "fxLayout.gt-md": "fxLayout.gt-md", "fxLayout.gt-lg": "fxLayout.gt-lg" }, features: [D] }), n })(); const PU = new Map, CA = { "margin-left": null, "margin-right": null, "margin-top": null, "margin-bottom": null }; let LU = (() => { class n extends We { constructor(e) { super(), this._styler = e } buildStyles(e, i) { return e.endsWith(Su) ? function (n, t) { const [e, i] = n.split(" "), s = c => `-${c}`; let o = "0px", a = s(i || e), l = "0px"; return "rtl" === t ? l = s(e) : o = s(e), { margin: `0px ${o} ${a} ${l}` } }(e = e.slice(0, e.indexOf(Su)), i.directionality) : {} } sideEffect(e, i, r) { const s = r.items; if (e.endsWith(Su)) { const o = function (n, t) { const [e, i] = n.split(" "); let s = "0px", a = "0px"; return "rtl" === t ? a = e : s = e, { padding: `0px ${s} ${i || e} ${a}` } }(e = e.slice(0, e.indexOf(Su)), r.directionality); this._styler.applyStyleToElements(o, r.items) } else { const o = s.pop(), a = function (n, t) { const e = EA(t.directionality, t.layout), i = Object.assign({}, CA); return i[e] = n, i }(e, r); this._styler.applyStyleToElements(a, s), this._styler.applyStyleToElements(CA, [o]) } } } return n.\u0275fac = function (e) { return new (e || n)(m(Re)) }, n.\u0275prov = E({ factory: function () { return new n(m(Re)) }, token: n, providedIn: "root" }), n })(); const VU = ["fxLayoutGap", "fxLayoutGap.xs", "fxLayoutGap.sm", "fxLayoutGap.md", "fxLayoutGap.lg", "fxLayoutGap.xl", "fxLayoutGap.lt-sm", "fxLayoutGap.lt-md", "fxLayoutGap.lt-lg", "fxLayoutGap.lt-xl", "fxLayoutGap.gt-xs", "fxLayoutGap.gt-sm", "fxLayoutGap.gt-md", "fxLayoutGap.gt-lg"]; let BU = (() => { class n extends Pe { constructor(e, i, r, s, o, a) { super(e, o, s, a), this.zone = i, this.directionality = r, this.styleUtils = s, this.layout = "row", this.DIRECTIVE_KEY = "layout-gap", this.observerSubject = new ie; const l = [this.directionality.change, this.observerSubject.asObservable()]; this.init(l), this.marshal.trackValue(this.nativeElement, "layout").pipe(pt(this.destroySubject)).subscribe(this.onLayoutChange.bind(this)) } get childrenNodes() { const e = this.nativeElement.children, i = []; for (let r = e.length; r--;)i[r] = e[r]; return i } ngAfterContentInit() { this.buildChildObservable(), this.triggerUpdate() } ngOnDestroy() { super.ngOnDestroy(), this.observer && this.observer.disconnect() } onLayoutChange(e) { const r = e.value.split(" "); this.layout = r[0], Au.find(s => s === this.layout) || (this.layout = "row"), this.triggerUpdate() } updateWithValue(e) { const i = this.childrenNodes.filter(r => 1 === r.nodeType && this.willDisplay(r)).sort((r, s) => { const o = +this.styler.lookupStyle(r, "order"), a = +this.styler.lookupStyle(s, "order"); return isNaN(o) || isNaN(a) || o === a ? 0 : o > a ? 1 : -1 }); if (i.length > 0) { const r = this.directionality.value, s = this.layout; "row" === s && "rtl" === r ? this.styleCache = HU : "row" === s && "rtl" !== r ? this.styleCache = GU : "column" === s && "rtl" === r ? this.styleCache = jU : "column" === s && "rtl" !== r && (this.styleCache = $U), this.addStyles(e, { directionality: r, items: i, layout: s }) } } clearStyles() { const e = Object.keys(this.mru).length > 0, i = e ? "padding" : EA(this.directionality.value, this.layout); e && super.clearStyles(), this.styleUtils.applyStyleToElements({ [i]: "" }, this.childrenNodes) } willDisplay(e) { const i = this.marshal.getValue(e, "show-hide"); return !0 === i || void 0 === i && "none" !== this.styleUtils.lookupStyle(e, "display") } buildChildObservable() { this.zone.runOutsideAngular(() => { "undefined" != typeof MutationObserver && (this.observer = new MutationObserver(e => { e.some(r => r.addedNodes && r.addedNodes.length > 0 || r.removedNodes && r.removedNodes.length > 0) && this.observerSubject.next() }), this.observer.observe(this.nativeElement, { childList: !0 })) }) } } return n.\u0275fac = function (e) { return new (e || n)(g(O), g(H), g(zi), g(Re), g(LU), g(Le)) }, n.\u0275dir = C({ type: n, features: [D] }), n })(), wA = (() => { class n extends BU { constructor() { super(...arguments), this.inputs = VU } } return n.\u0275fac = function () { let t; return function (i) { return (t || (t = P(n)))(i || n) } }(), n.\u0275dir = C({ type: n, selectors: [["", "fxLayoutGap", ""], ["", "fxLayoutGap.xs", ""], ["", "fxLayoutGap.sm", ""], ["", "fxLayoutGap.md", ""], ["", "fxLayoutGap.lg", ""], ["", "fxLayoutGap.xl", ""], ["", "fxLayoutGap.lt-sm", ""], ["", "fxLayoutGap.lt-md", ""], ["", "fxLayoutGap.lt-lg", ""], ["", "fxLayoutGap.lt-xl", ""], ["", "fxLayoutGap.gt-xs", ""], ["", "fxLayoutGap.gt-sm", ""], ["", "fxLayoutGap.gt-md", ""], ["", "fxLayoutGap.gt-lg", ""]], inputs: { fxLayoutGap: "fxLayoutGap", "fxLayoutGap.xs": "fxLayoutGap.xs", "fxLayoutGap.sm": "fxLayoutGap.sm", "fxLayoutGap.md": "fxLayoutGap.md", "fxLayoutGap.lg": "fxLayoutGap.lg", "fxLayoutGap.xl": "fxLayoutGap.xl", "fxLayoutGap.lt-sm": "fxLayoutGap.lt-sm", "fxLayoutGap.lt-md": "fxLayoutGap.lt-md", "fxLayoutGap.lt-lg": "fxLayoutGap.lt-lg", "fxLayoutGap.lt-xl": "fxLayoutGap.lt-xl", "fxLayoutGap.gt-xs": "fxLayoutGap.gt-xs", "fxLayoutGap.gt-sm": "fxLayoutGap.gt-sm", "fxLayoutGap.gt-md": "fxLayoutGap.gt-md", "fxLayoutGap.gt-lg": "fxLayoutGap.gt-lg" }, features: [D] }), n })(); const HU = new Map, jU = new Map, GU = new Map, $U = new Map, Su = " grid"; function EA(n, t) { switch (t) { case "column": return "margin-bottom"; case "column-reverse": return "margin-top"; case "row": return "rtl" === n ? "margin-left" : "margin-right"; case "row-reverse": return "rtl" === n ? "margin-right" : "margin-left"; default: return "rtl" === n ? "margin-left" : "margin-right" } } let E8 = (() => { class n extends We { buildStyles(e, i) { const r = {}, [s, o] = e.split(" "); switch (s) { case "center": r["justify-content"] = "center"; break; case "space-around": r["justify-content"] = "space-around"; break; case "space-between": r["justify-content"] = "space-between"; break; case "space-evenly": r["justify-content"] = "space-evenly"; break; case "end": case "flex-end": r["justify-content"] = "flex-end"; break; case "start": case "flex-start": default: r["justify-content"] = "flex-start" }switch (o) { case "start": case "flex-start": r["align-items"] = r["align-content"] = "flex-start"; break; case "center": r["align-items"] = r["align-content"] = "center"; break; case "end": case "flex-end": r["align-items"] = r["align-content"] = "flex-end"; break; case "space-between": r["align-content"] = "space-between", r["align-items"] = "stretch"; break; case "space-around": r["align-content"] = "space-around", r["align-items"] = "stretch"; break; case "baseline": r["align-content"] = "stretch", r["align-items"] = "baseline"; break; case "stretch": default: r["align-items"] = r["align-content"] = "stretch" }return function (n, ...t) { if (null == n) throw TypeError("Cannot convert undefined or null to object"); for (let e of t) if (null != e) for (let i in e) e.hasOwnProperty(i) && (n[i] = e[i]); return n }(r, { display: i.inline ? "inline-flex" : "flex", "flex-direction": i.layout, "box-sizing": "border-box", "max-width": "stretch" === o ? Pa(i.layout) ? null : "100%" : null, "max-height": "stretch" === o && Pa(i.layout) ? "100%" : null }) } } return n.\u0275fac = function () { let t; return function (i) { return (t || (t = P(n)))(i || n) } }(), n.\u0275prov = E({ factory: function () { return new n }, token: n, providedIn: "root" }), n })(); const D8 = ["fxLayoutAlign", "fxLayoutAlign.xs", "fxLayoutAlign.sm", "fxLayoutAlign.md", "fxLayoutAlign.lg", "fxLayoutAlign.xl", "fxLayoutAlign.lt-sm", "fxLayoutAlign.lt-md", "fxLayoutAlign.lt-lg", "fxLayoutAlign.lt-xl", "fxLayoutAlign.gt-xs", "fxLayoutAlign.gt-sm", "fxLayoutAlign.gt-md", "fxLayoutAlign.gt-lg"]; let x8 = (() => { class n extends Pe { constructor(e, i, r, s) { super(e, r, i, s), this.DIRECTIVE_KEY = "layout-align", this.layout = "row", this.inline = !1, this.init(), this.marshal.trackValue(this.nativeElement, "layout").pipe(pt(this.destroySubject)).subscribe(this.onLayoutChange.bind(this)) } updateWithValue(e) { const i = this.layout || "row", r = this.inline; "row" === i && r ? this.styleCache = I8 : "row" !== i || r ? "row-reverse" === i && r ? this.styleCache = R8 : "row-reverse" !== i || r ? "column" === i && r ? this.styleCache = F8 : "column" !== i || r ? "column-reverse" === i && r ? this.styleCache = k8 : "column-reverse" === i && !r && (this.styleCache = T8) : this.styleCache = A8 : this.styleCache = S8 : this.styleCache = M8, this.addStyles(e, { layout: i, inline: r }) } onLayoutChange(e) { const i = e.value.split(" "); this.layout = i[0], this.inline = e.value.includes("inline"), Au.find(r => r === this.layout) || (this.layout = "row"), this.triggerUpdate() } } return n.\u0275fac = function (e) { return new (e || n)(g(O), g(Re), g(E8), g(Le)) }, n.\u0275dir = C({ type: n, features: [D] }), n })(), Ig = (() => { class n extends x8 { constructor() { super(...arguments), this.inputs = D8 } } return n.\u0275fac = function () { let t; return function (i) { return (t || (t = P(n)))(i || n) } }(), n.\u0275dir = C({ type: n, selectors: [["", "fxLayoutAlign", ""], ["", "fxLayoutAlign.xs", ""], ["", "fxLayoutAlign.sm", ""], ["", "fxLayoutAlign.md", ""], ["", "fxLayoutAlign.lg", ""], ["", "fxLayoutAlign.xl", ""], ["", "fxLayoutAlign.lt-sm", ""], ["", "fxLayoutAlign.lt-md", ""], ["", "fxLayoutAlign.lt-lg", ""], ["", "fxLayoutAlign.lt-xl", ""], ["", "fxLayoutAlign.gt-xs", ""], ["", "fxLayoutAlign.gt-sm", ""], ["", "fxLayoutAlign.gt-md", ""], ["", "fxLayoutAlign.gt-lg", ""]], inputs: { fxLayoutAlign: "fxLayoutAlign", "fxLayoutAlign.xs": "fxLayoutAlign.xs", "fxLayoutAlign.sm": "fxLayoutAlign.sm", "fxLayoutAlign.md": "fxLayoutAlign.md", "fxLayoutAlign.lg": "fxLayoutAlign.lg", "fxLayoutAlign.xl": "fxLayoutAlign.xl", "fxLayoutAlign.lt-sm": "fxLayoutAlign.lt-sm", "fxLayoutAlign.lt-md": "fxLayoutAlign.lt-md", "fxLayoutAlign.lt-lg": "fxLayoutAlign.lt-lg", "fxLayoutAlign.lt-xl": "fxLayoutAlign.lt-xl", "fxLayoutAlign.gt-xs": "fxLayoutAlign.gt-xs", "fxLayoutAlign.gt-sm": "fxLayoutAlign.gt-sm", "fxLayoutAlign.gt-md": "fxLayoutAlign.gt-md", "fxLayoutAlign.gt-lg": "fxLayoutAlign.gt-lg" }, features: [D] }), n })(); const M8 = new Map, A8 = new Map, S8 = new Map, T8 = new Map, I8 = new Map, F8 = new Map, R8 = new Map, k8 = new Map; let DA = (() => { class n { } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275mod = ee({ type: n }), n.\u0275inj = X({ imports: [[_g, qs]] }), n })(); const O8 = ["*", [["mat-card-footer"]]], N8 = ["*", "mat-card-footer"]; let xA = (() => { class n { constructor(e) { this._animationMode = e } } return n.\u0275fac = function (e) { return new (e || n)(g(Qi, 8)) }, n.\u0275cmp = tt({ type: n, selectors: [["mat-card"]], hostAttrs: [1, "mat-card", "mat-focus-indicator"], hostVars: 2, hostBindings: function (e, i) { 2 & e && je("_mat-animation-noopable", "NoopAnimations" === i._animationMode) }, exportAs: ["matCard"], ngContentSelectors: N8, decls: 2, vars: 0, template: function (e, i) { 1 & e && (an(O8), Ae(0), Ae(1, 1)) }, styles: [".mat-card{transition:box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);display:block;position:relative;padding:16px;border-radius:4px}._mat-animation-noopable.mat-card{transition:none;animation:none}.mat-card .mat-divider-horizontal{position:absolute;left:0;width:100%}[dir=rtl] .mat-card .mat-divider-horizontal{left:auto;right:0}.mat-card .mat-divider-horizontal.mat-divider-inset{position:static;margin:0}[dir=rtl] .mat-card .mat-divider-horizontal.mat-divider-inset{margin-right:0}.cdk-high-contrast-active .mat-card{outline:solid 1px}.mat-card-actions,.mat-card-subtitle,.mat-card-content{display:block;margin-bottom:16px}.mat-card-title{display:block;margin-bottom:8px}.mat-card-actions{margin-left:-8px;margin-right:-8px;padding:8px 0}.mat-card-actions-align-end{display:flex;justify-content:flex-end}.mat-card-image{width:calc(100% + 32px);margin:0 -16px 16px -16px}.mat-card-footer{display:block;margin:0 -16px -16px -16px}.mat-card-actions .mat-button,.mat-card-actions .mat-raised-button,.mat-card-actions .mat-stroked-button{margin:0 8px}.mat-card-header{display:flex;flex-direction:row}.mat-card-header .mat-card-title{margin-bottom:12px}.mat-card-header-text{margin:0 16px}.mat-card-avatar{height:40px;width:40px;border-radius:50%;flex-shrink:0;object-fit:cover}.mat-card-title-group{display:flex;justify-content:space-between}.mat-card-sm-image{width:80px;height:80px}.mat-card-md-image{width:112px;height:112px}.mat-card-lg-image{width:152px;height:152px}.mat-card-xl-image{width:240px;height:240px;margin:-8px}.mat-card-title-group>.mat-card-xl-image{margin:-8px 0 8px}@media(max-width: 599px){.mat-card-title-group{margin:0}.mat-card-xl-image{margin-left:0;margin-right:0}}.mat-card>:first-child,.mat-card-content>:first-child{margin-top:0}.mat-card>:last-child:not(.mat-card-footer),.mat-card-content>:last-child:not(.mat-card-footer){margin-bottom:0}.mat-card-image:first-child{margin-top:-16px;border-top-left-radius:inherit;border-top-right-radius:inherit}.mat-card>.mat-card-actions:last-child{margin-bottom:-8px;padding-bottom:0}.mat-card-actions:not(.mat-card-actions-align-end) .mat-button:first-child,.mat-card-actions:not(.mat-card-actions-align-end) .mat-raised-button:first-child,.mat-card-actions:not(.mat-card-actions-align-end) .mat-stroked-button:first-child{margin-left:0;margin-right:0}.mat-card-actions-align-end .mat-button:last-child,.mat-card-actions-align-end .mat-raised-button:last-child,.mat-card-actions-align-end .mat-stroked-button:last-child{margin-left:0;margin-right:0}.mat-card-title:not(:first-child),.mat-card-subtitle:not(:first-child){margin-top:-4px}.mat-card-header .mat-card-subtitle:not(:first-child){margin-top:-8px}.mat-card>.mat-card-xl-image:first-child{margin-top:-8px}.mat-card>.mat-card-xl-image:last-child{margin-bottom:-8px}\n"], encapsulation: 2, changeDetection: 0 }), n })(), H8 = (() => { class n { } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275mod = ee({ type: n }), n.\u0275inj = X({ imports: [[at], at] }), n })(); const j8 = ["underline"], G8 = ["connectionContainer"], $8 = ["inputContainer"], U8 = ["label"]; function z8(n, t) { 1 & n && (kl(0), x(1, "div", 14), Ye(2, "div", 15), Ye(3, "div", 16), Ye(4, "div", 17), M(), x(5, "div", 18), Ye(6, "div", 15), Ye(7, "div", 16), Ye(8, "div", 17), M(), Ol()) } function W8(n, t) { 1 & n && (x(0, "div", 19), Ae(1, 1), M()) } function q8(n, t) { if (1 & n && (kl(0), Ae(1, 2), x(2, "span"), oe(3), M(), Ol()), 2 & n) { const e = He(2); B(3), Ms(e._control.placeholder) } } function K8(n, t) { 1 & n && Ae(0, 3, ["*ngSwitchCase", "true"]) } function Q8(n, t) { 1 & n && (x(0, "span", 23), oe(1, " *"), M()) } function Y8(n, t) { if (1 & n) { const e = pr(); x(0, "label", 20, 21), ye("cdkObserveContent", function () { return ai(e), He().updateOutlineGap() }), Ee(2, q8, 4, 1, "ng-container", 12), Ee(3, K8, 1, 0, "ng-content", 12), Ee(4, Q8, 2, 0, "span", 22), M() } if (2 & n) { const e = He(); je("mat-empty", e._control.empty && !e._shouldAlwaysFloat())("mat-form-field-empty", e._control.empty && !e._shouldAlwaysFloat())("mat-accent", "accent" == e.color)("mat-warn", "warn" == e.color), K("cdkObserveContentDisabled", "outline" != e.appearance)("id", e._labelId)("ngSwitch", e._hasLabel()), Qe("for", e._control.id)("aria-owns", e._control.id), B(2), K("ngSwitchCase", !1), B(1), K("ngSwitchCase", !0), B(1), K("ngIf", !e.hideRequiredMarker && e._control.required && !e._control.disabled) } } function J8(n, t) { 1 & n && (x(0, "div", 24), Ae(1, 4), M()) } function Z8(n, t) { if (1 & n && (x(0, "div", 25, 26), Ye(2, "span", 27), M()), 2 & n) { const e = He(); B(2), je("mat-accent", "accent" == e.color)("mat-warn", "warn" == e.color) } } function X8(n, t) { 1 & n && (x(0, "div"), Ae(1, 5), M()), 2 & n && K("@transitionMessages", He()._subscriptAnimationState) } function ez(n, t) { if (1 & n && (x(0, "div", 31), oe(1), M()), 2 & n) { const e = He(2); K("id", e._hintLabelId), B(1), Ms(e.hintLabel) } } function tz(n, t) { if (1 & n && (x(0, "div", 28), Ee(1, ez, 2, 2, "div", 29), Ae(2, 6), Ye(3, "div", 30), Ae(4, 7), M()), 2 & n) { const e = He(); K("@transitionMessages", e._subscriptAnimationState), B(1), K("ngIf", e.hintLabel) } } const nz = ["*", [["", "matPrefix", ""]], [["mat-placeholder"]], [["mat-label"]], [["", "matSuffix", ""]], [["mat-error"]], [["mat-hint", 3, "align", "end"]], [["mat-hint", "align", "end"]]], iz = ["*", "[matPrefix]", "mat-placeholder", "mat-label", "[matSuffix]", "mat-error", "mat-hint:not([align='end'])", "mat-hint[align='end']"], MA = new k("MatError"), sz = { transitionMessages: cx("transitionMessages", [Pp("enter", Ir({ opacity: 1, transform: "translateY(0%)" })), Lp("void => enter", [Ir({ opacity: 0, transform: "translateY(-5px)" }), Np("300ms cubic-bezier(0.55, 0, 0.55, 0.2)")])]) }; let Fg = (() => { class n { } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275dir = C({ type: n }), n })(); const AA = new k("MatHint"); let Rg = (() => { class n { } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275dir = C({ type: n, selectors: [["mat-label"]] }), n })(), az = (() => { class n { } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275dir = C({ type: n, selectors: [["mat-placeholder"]] }), n })(); const SA = new k("MatPrefix"), TA = new k("MatSuffix"); let IA = 0; const cz = mu(class { constructor(n) { this._elementRef = n } }, "primary"), uz = new k("MAT_FORM_FIELD_DEFAULT_OPTIONS"), RA = new k("MatFormField"); let dz = (() => { class n extends cz { constructor(e, i, r, s, o, a, l, c) { super(e), this._changeDetectorRef = i, this._dir = s, this._defaults = o, this._platform = a, this._ngZone = l, this._outlineGapCalculationNeededImmediately = !1, this._outlineGapCalculationNeededOnStable = !1, this._destroyed = new ie, this._showAlwaysAnimate = !1, this._subscriptAnimationState = "", this._hintLabel = "", this._hintLabelId = "mat-hint-" + IA++, this._labelId = "mat-form-field-label-" + IA++, this.floatLabel = this._getDefaultFloatLabelState(), this._animationsEnabled = "NoopAnimations" !== c, this.appearance = o && o.appearance ? o.appearance : "legacy", this._hideRequiredMarker = !(!o || null == o.hideRequiredMarker) && o.hideRequiredMarker } get appearance() { return this._appearance } set appearance(e) { const i = this._appearance; this._appearance = e || this._defaults && this._defaults.appearance || "legacy", "outline" === this._appearance && i !== e && (this._outlineGapCalculationNeededOnStable = !0) } get hideRequiredMarker() { return this._hideRequiredMarker } set hideRequiredMarker(e) { this._hideRequiredMarker = Te(e) } _shouldAlwaysFloat() { return "always" === this.floatLabel && !this._showAlwaysAnimate } _canLabelFloat() { return "never" !== this.floatLabel } get hintLabel() { return this._hintLabel } set hintLabel(e) { this._hintLabel = e, this._processHints() } get floatLabel() { return "legacy" !== this.appearance && "never" === this._floatLabel ? "auto" : this._floatLabel } set floatLabel(e) { e !== this._floatLabel && (this._floatLabel = e || this._getDefaultFloatLabelState(), this._changeDetectorRef.markForCheck()) } get _control() { return this._explicitFormFieldControl || this._controlNonStatic || this._controlStatic } set _control(e) { this._explicitFormFieldControl = e } getLabelId() { return this._hasFloatingLabel() ? this._labelId : null } getConnectedOverlayOrigin() { return this._connectionContainerRef || this._elementRef } ngAfterContentInit() { this._validateControlChild(); const e = this._control; e.controlType && this._elementRef.nativeElement.classList.add(`mat-form-field-type-${e.controlType}`), e.stateChanges.pipe(Us(null)).subscribe(() => { this._validatePlaceholders(), this._syncDescribedByIds(), this._changeDetectorRef.markForCheck() }), e.ngControl && e.ngControl.valueChanges && e.ngControl.valueChanges.pipe(pt(this._destroyed)).subscribe(() => this._changeDetectorRef.markForCheck()), this._ngZone.runOutsideAngular(() => { this._ngZone.onStable.pipe(pt(this._destroyed)).subscribe(() => { this._outlineGapCalculationNeededOnStable && this.updateOutlineGap() }) }), uo(this._prefixChildren.changes, this._suffixChildren.changes).subscribe(() => { this._outlineGapCalculationNeededOnStable = !0, this._changeDetectorRef.markForCheck() }), this._hintChildren.changes.pipe(Us(null)).subscribe(() => { this._processHints(), this._changeDetectorRef.markForCheck() }), this._errorChildren.changes.pipe(Us(null)).subscribe(() => { this._syncDescribedByIds(), this._changeDetectorRef.markForCheck() }), this._dir && this._dir.change.pipe(pt(this._destroyed)).subscribe(() => { "function" == typeof requestAnimationFrame ? this._ngZone.runOutsideAngular(() => { requestAnimationFrame(() => this.updateOutlineGap()) }) : this.updateOutlineGap() }) } ngAfterContentChecked() { this._validateControlChild(), this._outlineGapCalculationNeededImmediately && this.updateOutlineGap() } ngAfterViewInit() { this._subscriptAnimationState = "enter", this._changeDetectorRef.detectChanges() } ngOnDestroy() { this._destroyed.next(), this._destroyed.complete() } _shouldForward(e) { const i = this._control ? this._control.ngControl : null; return i && i[e] } _hasPlaceholder() { return !!(this._control && this._control.placeholder || this._placeholderChild) } _hasLabel() { return !(!this._labelChildNonStatic && !this._labelChildStatic) } _shouldLabelFloat() { return this._canLabelFloat() && (this._control && this._control.shouldLabelFloat || this._shouldAlwaysFloat()) } _hideControlPlaceholder() { return "legacy" === this.appearance && !this._hasLabel() || this._hasLabel() && !this._shouldLabelFloat() } _hasFloatingLabel() { return this._hasLabel() || "legacy" === this.appearance && this._hasPlaceholder() } _getDisplayedMessages() { return this._errorChildren && this._errorChildren.length > 0 && this._control.errorState ? "error" : "hint" } _animateAndLockLabel() { this._hasFloatingLabel() && this._canLabelFloat() && (this._animationsEnabled && this._label && (this._showAlwaysAnimate = !0, Ea(this._label.nativeElement, "transitionend").pipe(Ks(1)).subscribe(() => { this._showAlwaysAnimate = !1 })), this.floatLabel = "always", this._changeDetectorRef.markForCheck()) } _validatePlaceholders() { } _processHints() { this._validateHints(), this._syncDescribedByIds() } _validateHints() { } _getDefaultFloatLabelState() { return this._defaults && this._defaults.floatLabel || "auto" } _syncDescribedByIds() { if (this._control) { let e = []; if (this._control.userAriaDescribedBy && "string" == typeof this._control.userAriaDescribedBy && e.push(...this._control.userAriaDescribedBy.split(" ")), "hint" === this._getDisplayedMessages()) { const i = this._hintChildren ? this._hintChildren.find(s => "start" === s.align) : null, r = this._hintChildren ? this._hintChildren.find(s => "end" === s.align) : null; i ? e.push(i.id) : this._hintLabel && e.push(this._hintLabelId), r && e.push(r.id) } else this._errorChildren && e.push(...this._errorChildren.map(i => i.id)); this._control.setDescribedByIds(e) } } _validateControlChild() { } updateOutlineGap() { const e = this._label ? this._label.nativeElement : null; if (!("outline" === this.appearance && e && e.children.length && e.textContent.trim() && this._platform.isBrowser)) return; if (!this._isAttachedToDOM()) return void (this._outlineGapCalculationNeededImmediately = !0); let i = 0, r = 0; const s = this._connectionContainerRef.nativeElement, o = s.querySelectorAll(".mat-form-field-outline-start"), a = s.querySelectorAll(".mat-form-field-outline-gap"); if (this._label && this._label.nativeElement.children.length) { const l = s.getBoundingClientRect(); if (0 === l.width && 0 === l.height) return this._outlineGapCalculationNeededOnStable = !0, void (this._outlineGapCalculationNeededImmediately = !1); const c = this._getStartEnd(l), u = e.children, d = this._getStartEnd(u[0].getBoundingClientRect()); let f = 0; for (let h = 0; h < u.length; h++)f += u[h].offsetWidth; i = Math.abs(d - c) - 5, r = f > 0 ? .75 * f + 10 : 0 } for (let l = 0; l < o.length; l++)o[l].style.width = `${i}px`; for (let l = 0; l < a.length; l++)a[l].style.width = `${r}px`; this._outlineGapCalculationNeededOnStable = this._outlineGapCalculationNeededImmediately = !1 } _getStartEnd(e) { return this._dir && "rtl" === this._dir.value ? e.right : e.left } _isAttachedToDOM() { const e = this._elementRef.nativeElement; if (e.getRootNode) { const i = e.getRootNode(); return i && i !== e } return document.documentElement.contains(e) } } return n.\u0275fac = function (e) { return new (e || n)(g(O), g(Is), g(O), g(zi, 8), g(uz, 8), g(Ce), g(H), g(Qi, 8)) }, n.\u0275cmp = tt({ type: n, selectors: [["mat-form-field"]], contentQueries: function (e, i, r) { if (1 & e && (Fn(r, Fg, 5), Fn(r, Fg, 7), Fn(r, Rg, 5), Fn(r, Rg, 7), Fn(r, az, 5), Fn(r, MA, 5), Fn(r, AA, 5), Fn(r, SA, 5), Fn(r, TA, 5)), 2 & e) { let s; ct(s = ut()) && (i._controlNonStatic = s.first), ct(s = ut()) && (i._controlStatic = s.first), ct(s = ut()) && (i._labelChildNonStatic = s.first), ct(s = ut()) && (i._labelChildStatic = s.first), ct(s = ut()) && (i._placeholderChild = s.first), ct(s = ut()) && (i._errorChildren = s), ct(s = ut()) && (i._hintChildren = s), ct(s = ut()) && (i._prefixChildren = s), ct(s = ut()) && (i._suffixChildren = s) } }, viewQuery: function (e, i) { if (1 & e && (Bi(j8, 5), Bi(G8, 7), Bi($8, 5), Bi(U8, 5)), 2 & e) { let r; ct(r = ut()) && (i.underlineRef = r.first), ct(r = ut()) && (i._connectionContainerRef = r.first), ct(r = ut()) && (i._inputContainerRef = r.first), ct(r = ut()) && (i._label = r.first) } }, hostAttrs: [1, "mat-form-field"], hostVars: 40, hostBindings: function (e, i) { 2 & e && je("mat-form-field-appearance-standard", "standard" == i.appearance)("mat-form-field-appearance-fill", "fill" == i.appearance)("mat-form-field-appearance-outline", "outline" == i.appearance)("mat-form-field-appearance-legacy", "legacy" == i.appearance)("mat-form-field-invalid", i._control.errorState)("mat-form-field-can-float", i._canLabelFloat())("mat-form-field-should-float", i._shouldLabelFloat())("mat-form-field-has-label", i._hasFloatingLabel())("mat-form-field-hide-placeholder", i._hideControlPlaceholder())("mat-form-field-disabled", i._control.disabled)("mat-form-field-autofilled", i._control.autofilled)("mat-focused", i._control.focused)("ng-untouched", i._shouldForward("untouched"))("ng-touched", i._shouldForward("touched"))("ng-pristine", i._shouldForward("pristine"))("ng-dirty", i._shouldForward("dirty"))("ng-valid", i._shouldForward("valid"))("ng-invalid", i._shouldForward("invalid"))("ng-pending", i._shouldForward("pending"))("_mat-animation-noopable", !i._animationsEnabled) }, inputs: { color: "color", floatLabel: "floatLabel", appearance: "appearance", hideRequiredMarker: "hideRequiredMarker", hintLabel: "hintLabel" }, exportAs: ["matFormField"], features: [ae([{ provide: RA, useExisting: n }]), D], ngContentSelectors: iz, decls: 15, vars: 8, consts: [[1, "mat-form-field-wrapper"], [1, "mat-form-field-flex", 3, "click"], ["connectionContainer", ""], [4, "ngIf"], ["class", "mat-form-field-prefix", 4, "ngIf"], [1, "mat-form-field-infix"], ["inputContainer", ""], [1, "mat-form-field-label-wrapper"], ["class", "mat-form-field-label", 3, "cdkObserveContentDisabled", "id", "mat-empty", "mat-form-field-empty", "mat-accent", "mat-warn", "ngSwitch", "cdkObserveContent", 4, "ngIf"], ["class", "mat-form-field-suffix", 4, "ngIf"], ["class", "mat-form-field-underline", 4, "ngIf"], [1, "mat-form-field-subscript-wrapper", 3, "ngSwitch"], [4, "ngSwitchCase"], ["class", "mat-form-field-hint-wrapper", 4, "ngSwitchCase"], [1, "mat-form-field-outline"], [1, "mat-form-field-outline-start"], [1, "mat-form-field-outline-gap"], [1, "mat-form-field-outline-end"], [1, "mat-form-field-outline", "mat-form-field-outline-thick"], [1, "mat-form-field-prefix"], [1, "mat-form-field-label", 3, "cdkObserveContentDisabled", "id", "ngSwitch", "cdkObserveContent"], ["label", ""], ["class", "mat-placeholder-required mat-form-field-required-marker", "aria-hidden", "true", 4, "ngIf"], ["aria-hidden", "true", 1, "mat-placeholder-required", "mat-form-field-required-marker"], [1, "mat-form-field-suffix"], [1, "mat-form-field-underline"], ["underline", ""], [1, "mat-form-field-ripple"], [1, "mat-form-field-hint-wrapper"], ["class", "mat-hint", 3, "id", 4, "ngIf"], [1, "mat-form-field-hint-spacer"], [1, "mat-hint", 3, "id"]], template: function (e, i) { 1 & e && (an(nz), x(0, "div", 0), x(1, "div", 1, 2), ye("click", function (s) { return i._control.onContainerClick && i._control.onContainerClick(s) }), Ee(3, z8, 9, 0, "ng-container", 3), Ee(4, W8, 2, 0, "div", 4), x(5, "div", 5, 6), Ae(7), x(8, "span", 7), Ee(9, Y8, 5, 16, "label", 8), M(), M(), Ee(10, J8, 2, 0, "div", 9), M(), Ee(11, Z8, 3, 4, "div", 10), x(12, "div", 11), Ee(13, X8, 2, 1, "div", 12), Ee(14, tz, 5, 2, "div", 13), M(), M()), 2 & e && (B(3), K("ngIf", "outline" == i.appearance), B(1), K("ngIf", i._prefixChildren.length), B(5), K("ngIf", i._hasFloatingLabel()), B(1), K("ngIf", i._suffixChildren.length), B(1), K("ngIf", "outline" != i.appearance), B(1), K("ngSwitch", i._getDisplayedMessages()), B(1), K("ngSwitchCase", "error"), B(1), K("ngSwitchCase", "hint")) }, directives: [js, wc, Hw, _j], styles: [".mat-form-field{display:inline-block;position:relative;text-align:left}[dir=rtl] .mat-form-field{text-align:right}.mat-form-field-wrapper{position:relative}.mat-form-field-flex{display:inline-flex;align-items:baseline;box-sizing:border-box;width:100%}.mat-form-field-prefix,.mat-form-field-suffix{white-space:nowrap;flex:none;position:relative}.mat-form-field-infix{display:block;position:relative;flex:auto;min-width:0;width:180px}.cdk-high-contrast-active .mat-form-field-infix{border-image:linear-gradient(transparent, transparent)}.mat-form-field-label-wrapper{position:absolute;left:0;box-sizing:content-box;width:100%;height:100%;overflow:hidden;pointer-events:none}[dir=rtl] .mat-form-field-label-wrapper{left:auto;right:0}.mat-form-field-label{position:absolute;left:0;font:inherit;pointer-events:none;width:100%;white-space:nowrap;text-overflow:ellipsis;overflow:hidden;transform-origin:0 0;transition:transform 400ms cubic-bezier(0.25, 0.8, 0.25, 1),color 400ms cubic-bezier(0.25, 0.8, 0.25, 1),width 400ms cubic-bezier(0.25, 0.8, 0.25, 1);display:none}[dir=rtl] .mat-form-field-label{transform-origin:100% 0;left:auto;right:0}.mat-form-field-empty.mat-form-field-label,.mat-form-field-can-float.mat-form-field-should-float .mat-form-field-label{display:block}.mat-form-field-autofill-control:-webkit-autofill+.mat-form-field-label-wrapper .mat-form-field-label{display:none}.mat-form-field-can-float .mat-form-field-autofill-control:-webkit-autofill+.mat-form-field-label-wrapper .mat-form-field-label{display:block;transition:none}.mat-input-server:focus+.mat-form-field-label-wrapper .mat-form-field-label,.mat-input-server[placeholder]:not(:placeholder-shown)+.mat-form-field-label-wrapper .mat-form-field-label{display:none}.mat-form-field-can-float .mat-input-server:focus+.mat-form-field-label-wrapper .mat-form-field-label,.mat-form-field-can-float .mat-input-server[placeholder]:not(:placeholder-shown)+.mat-form-field-label-wrapper .mat-form-field-label{display:block}.mat-form-field-label:not(.mat-form-field-empty){transition:none}.mat-form-field-underline{position:absolute;width:100%;pointer-events:none;transform:scale3d(1, 1.0001, 1)}.mat-form-field-ripple{position:absolute;left:0;width:100%;transform-origin:50%;transform:scaleX(0.5);opacity:0;transition:background-color 300ms cubic-bezier(0.55, 0, 0.55, 0.2)}.mat-form-field.mat-focused .mat-form-field-ripple,.mat-form-field.mat-form-field-invalid .mat-form-field-ripple{opacity:1;transform:none;transition:transform 300ms cubic-bezier(0.25, 0.8, 0.25, 1),opacity 100ms cubic-bezier(0.25, 0.8, 0.25, 1),background-color 300ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-form-field-subscript-wrapper{position:absolute;box-sizing:border-box;width:100%;overflow:hidden}.mat-form-field-subscript-wrapper .mat-icon,.mat-form-field-label-wrapper .mat-icon{width:1em;height:1em;font-size:inherit;vertical-align:baseline}.mat-form-field-hint-wrapper{display:flex}.mat-form-field-hint-spacer{flex:1 0 1em}.mat-error{display:block}.mat-form-field-control-wrapper{position:relative}.mat-form-field-hint-end{order:1}.mat-form-field._mat-animation-noopable .mat-form-field-label,.mat-form-field._mat-animation-noopable .mat-form-field-ripple{transition:none}\n", '.mat-form-field-appearance-fill .mat-form-field-flex{border-radius:4px 4px 0 0;padding:.75em .75em 0 .75em}.cdk-high-contrast-active .mat-form-field-appearance-fill .mat-form-field-flex{outline:solid 1px}.cdk-high-contrast-active .mat-form-field-appearance-fill.mat-focused .mat-form-field-flex{outline:dashed 3px}.mat-form-field-appearance-fill .mat-form-field-underline::before{content:"";display:block;position:absolute;bottom:0;height:1px;width:100%}.mat-form-field-appearance-fill .mat-form-field-ripple{bottom:0;height:2px}.cdk-high-contrast-active .mat-form-field-appearance-fill .mat-form-field-ripple{height:0}.mat-form-field-appearance-fill:not(.mat-form-field-disabled) .mat-form-field-flex:hover~.mat-form-field-underline .mat-form-field-ripple{opacity:1;transform:none;transition:opacity 600ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-form-field-appearance-fill._mat-animation-noopable:not(.mat-form-field-disabled) .mat-form-field-flex:hover~.mat-form-field-underline .mat-form-field-ripple{transition:none}.mat-form-field-appearance-fill .mat-form-field-subscript-wrapper{padding:0 1em}\n', '.mat-input-element{font:inherit;background:transparent;color:currentColor;border:none;outline:none;padding:0;margin:0;width:100%;max-width:100%;vertical-align:bottom;text-align:inherit;box-sizing:content-box}.mat-input-element:-moz-ui-invalid{box-shadow:none}.mat-input-element::-ms-clear,.mat-input-element::-ms-reveal{display:none}.mat-input-element,.mat-input-element::-webkit-search-cancel-button,.mat-input-element::-webkit-search-decoration,.mat-input-element::-webkit-search-results-button,.mat-input-element::-webkit-search-results-decoration{-webkit-appearance:none}.mat-input-element::-webkit-contacts-auto-fill-button,.mat-input-element::-webkit-caps-lock-indicator,.mat-input-element::-webkit-credentials-auto-fill-button{visibility:hidden}.mat-input-element[type=date],.mat-input-element[type=datetime],.mat-input-element[type=datetime-local],.mat-input-element[type=month],.mat-input-element[type=week],.mat-input-element[type=time]{line-height:1}.mat-input-element[type=date]::after,.mat-input-element[type=datetime]::after,.mat-input-element[type=datetime-local]::after,.mat-input-element[type=month]::after,.mat-input-element[type=week]::after,.mat-input-element[type=time]::after{content:" ";white-space:pre;width:1px}.mat-input-element::-webkit-inner-spin-button,.mat-input-element::-webkit-calendar-picker-indicator,.mat-input-element::-webkit-clear-button{font-size:.75em}.mat-input-element::placeholder{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;transition:color 400ms 133.3333333333ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-input-element::placeholder:-ms-input-placeholder{-ms-user-select:text}.mat-input-element::-moz-placeholder{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;transition:color 400ms 133.3333333333ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-input-element::-moz-placeholder:-ms-input-placeholder{-ms-user-select:text}.mat-input-element::-webkit-input-placeholder{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;transition:color 400ms 133.3333333333ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-input-element::-webkit-input-placeholder:-ms-input-placeholder{-ms-user-select:text}.mat-input-element:-ms-input-placeholder{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;transition:color 400ms 133.3333333333ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-input-element:-ms-input-placeholder:-ms-input-placeholder{-ms-user-select:text}.mat-form-field-hide-placeholder .mat-input-element::placeholder{color:transparent !important;-webkit-text-fill-color:transparent;transition:none}.cdk-high-contrast-active .mat-form-field-hide-placeholder .mat-input-element::placeholder{opacity:0}.mat-form-field-hide-placeholder .mat-input-element::-moz-placeholder{color:transparent !important;-webkit-text-fill-color:transparent;transition:none}.cdk-high-contrast-active .mat-form-field-hide-placeholder .mat-input-element::-moz-placeholder{opacity:0}.mat-form-field-hide-placeholder .mat-input-element::-webkit-input-placeholder{color:transparent !important;-webkit-text-fill-color:transparent;transition:none}.cdk-high-contrast-active .mat-form-field-hide-placeholder .mat-input-element::-webkit-input-placeholder{opacity:0}.mat-form-field-hide-placeholder .mat-input-element:-ms-input-placeholder{color:transparent !important;-webkit-text-fill-color:transparent;transition:none}.cdk-high-contrast-active .mat-form-field-hide-placeholder .mat-input-element:-ms-input-placeholder{opacity:0}textarea.mat-input-element{resize:vertical;overflow:auto}textarea.mat-input-element.cdk-textarea-autosize{resize:none}textarea.mat-input-element{padding:2px 0;margin:-2px 0}select.mat-input-element{-moz-appearance:none;-webkit-appearance:none;position:relative;background-color:transparent;display:inline-flex;box-sizing:border-box;padding-top:1em;top:-1em;margin-bottom:-1em}select.mat-input-element::-ms-expand{display:none}select.mat-input-element::-moz-focus-inner{border:0}select.mat-input-element:not(:disabled){cursor:pointer}select.mat-input-element::-ms-value{color:inherit;background:none}.mat-focused .cdk-high-contrast-active select.mat-input-element::-ms-value{color:inherit}.mat-form-field-type-mat-native-select .mat-form-field-infix::after{content:"";width:0;height:0;border-left:5px solid transparent;border-right:5px solid transparent;border-top:5px solid;position:absolute;top:50%;right:0;margin-top:-2.5px;pointer-events:none}[dir=rtl] .mat-form-field-type-mat-native-select .mat-form-field-infix::after{right:auto;left:0}.mat-form-field-type-mat-native-select .mat-input-element{padding-right:15px}[dir=rtl] .mat-form-field-type-mat-native-select .mat-input-element{padding-right:0;padding-left:15px}.mat-form-field-type-mat-native-select .mat-form-field-label-wrapper{max-width:calc(100% - 10px)}.mat-form-field-type-mat-native-select.mat-form-field-appearance-outline .mat-form-field-infix::after{margin-top:-5px}.mat-form-field-type-mat-native-select.mat-form-field-appearance-fill .mat-form-field-infix::after{margin-top:-10px}\n', ".mat-form-field-appearance-legacy .mat-form-field-label{transform:perspective(100px);-ms-transform:none}.mat-form-field-appearance-legacy .mat-form-field-prefix .mat-icon,.mat-form-field-appearance-legacy .mat-form-field-suffix .mat-icon{width:1em}.mat-form-field-appearance-legacy .mat-form-field-prefix .mat-icon-button,.mat-form-field-appearance-legacy .mat-form-field-suffix .mat-icon-button{font:inherit;vertical-align:baseline}.mat-form-field-appearance-legacy .mat-form-field-prefix .mat-icon-button .mat-icon,.mat-form-field-appearance-legacy .mat-form-field-suffix .mat-icon-button .mat-icon{font-size:inherit}.mat-form-field-appearance-legacy .mat-form-field-underline{height:1px}.cdk-high-contrast-active .mat-form-field-appearance-legacy .mat-form-field-underline{height:0;border-top:solid 1px}.mat-form-field-appearance-legacy .mat-form-field-ripple{top:0;height:2px;overflow:hidden}.cdk-high-contrast-active .mat-form-field-appearance-legacy .mat-form-field-ripple{height:0;border-top:solid 2px}.mat-form-field-appearance-legacy.mat-form-field-disabled .mat-form-field-underline{background-position:0;background-color:transparent}.cdk-high-contrast-active .mat-form-field-appearance-legacy.mat-form-field-disabled .mat-form-field-underline{border-top-style:dotted;border-top-width:2px}.mat-form-field-appearance-legacy.mat-form-field-invalid:not(.mat-focused) .mat-form-field-ripple{height:1px}\n", ".mat-form-field-appearance-outline .mat-form-field-wrapper{margin:.25em 0}.mat-form-field-appearance-outline .mat-form-field-flex{padding:0 .75em 0 .75em;margin-top:-0.25em;position:relative}.mat-form-field-appearance-outline .mat-form-field-prefix,.mat-form-field-appearance-outline .mat-form-field-suffix{top:.25em}.mat-form-field-appearance-outline .mat-form-field-outline{display:flex;position:absolute;top:.25em;left:0;right:0;bottom:0;pointer-events:none}.mat-form-field-appearance-outline .mat-form-field-outline-start,.mat-form-field-appearance-outline .mat-form-field-outline-end{border:1px solid currentColor;min-width:5px}.mat-form-field-appearance-outline .mat-form-field-outline-start{border-radius:5px 0 0 5px;border-right-style:none}[dir=rtl] .mat-form-field-appearance-outline .mat-form-field-outline-start{border-right-style:solid;border-left-style:none;border-radius:0 5px 5px 0}.mat-form-field-appearance-outline .mat-form-field-outline-end{border-radius:0 5px 5px 0;border-left-style:none;flex-grow:1}[dir=rtl] .mat-form-field-appearance-outline .mat-form-field-outline-end{border-left-style:solid;border-right-style:none;border-radius:5px 0 0 5px}.mat-form-field-appearance-outline .mat-form-field-outline-gap{border-radius:.000001px;border:1px solid currentColor;border-left-style:none;border-right-style:none}.mat-form-field-appearance-outline.mat-form-field-can-float.mat-form-field-should-float .mat-form-field-outline-gap{border-top-color:transparent}.mat-form-field-appearance-outline .mat-form-field-outline-thick{opacity:0}.mat-form-field-appearance-outline .mat-form-field-outline-thick .mat-form-field-outline-start,.mat-form-field-appearance-outline .mat-form-field-outline-thick .mat-form-field-outline-end,.mat-form-field-appearance-outline .mat-form-field-outline-thick .mat-form-field-outline-gap{border-width:2px}.mat-form-field-appearance-outline.mat-focused .mat-form-field-outline,.mat-form-field-appearance-outline.mat-form-field-invalid .mat-form-field-outline{opacity:0;transition:opacity 100ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-form-field-appearance-outline.mat-focused .mat-form-field-outline-thick,.mat-form-field-appearance-outline.mat-form-field-invalid .mat-form-field-outline-thick{opacity:1}.cdk-high-contrast-active .mat-form-field-appearance-outline.mat-focused .mat-form-field-outline-thick{border:3px dashed}.mat-form-field-appearance-outline:not(.mat-form-field-disabled) .mat-form-field-flex:hover .mat-form-field-outline{opacity:0;transition:opacity 600ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-form-field-appearance-outline:not(.mat-form-field-disabled) .mat-form-field-flex:hover .mat-form-field-outline-thick{opacity:1}.mat-form-field-appearance-outline .mat-form-field-subscript-wrapper{padding:0 1em}.mat-form-field-appearance-outline._mat-animation-noopable:not(.mat-form-field-disabled) .mat-form-field-flex:hover~.mat-form-field-outline,.mat-form-field-appearance-outline._mat-animation-noopable .mat-form-field-outline,.mat-form-field-appearance-outline._mat-animation-noopable .mat-form-field-outline-start,.mat-form-field-appearance-outline._mat-animation-noopable .mat-form-field-outline-end,.mat-form-field-appearance-outline._mat-animation-noopable .mat-form-field-outline-gap{transition:none}\n", ".mat-form-field-appearance-standard .mat-form-field-flex{padding-top:.75em}.mat-form-field-appearance-standard .mat-form-field-underline{height:1px}.cdk-high-contrast-active .mat-form-field-appearance-standard .mat-form-field-underline{height:0;border-top:solid 1px}.mat-form-field-appearance-standard .mat-form-field-ripple{bottom:0;height:2px}.cdk-high-contrast-active .mat-form-field-appearance-standard .mat-form-field-ripple{height:0;border-top:solid 2px}.mat-form-field-appearance-standard.mat-form-field-disabled .mat-form-field-underline{background-position:0;background-color:transparent}.cdk-high-contrast-active .mat-form-field-appearance-standard.mat-form-field-disabled .mat-form-field-underline{border-top-style:dotted;border-top-width:2px}.mat-form-field-appearance-standard:not(.mat-form-field-disabled) .mat-form-field-flex:hover~.mat-form-field-underline .mat-form-field-ripple{opacity:1;transform:none;transition:opacity 600ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-form-field-appearance-standard._mat-animation-noopable:not(.mat-form-field-disabled) .mat-form-field-flex:hover~.mat-form-field-underline .mat-form-field-ripple{transition:none}\n"], encapsulation: 2, data: { animation: [sz.transitionMessages] }, changeDetection: 0 }), n })(), kA = (() => { class n { } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275mod = ee({ type: n }), n.\u0275inj = X({ imports: [[Ec, at, UD], at] }), n })(); const OA = zc({ passive: !0 }); let NA = (() => { class n { constructor(e, i) { this._platform = e, this._ngZone = i, this._monitoredElements = new Map } monitor(e) { if (!this._platform.isBrowser) return hD; const i = vi(e), r = this._monitoredElements.get(i); if (r) return r.subject; const s = new ie, o = "cdk-text-field-autofilled", a = l => { "cdk-text-field-autofill-start" !== l.animationName || i.classList.contains(o) ? "cdk-text-field-autofill-end" === l.animationName && i.classList.contains(o) && (i.classList.remove(o), this._ngZone.run(() => s.next({ target: l.target, isAutofilled: !1 }))) : (i.classList.add(o), this._ngZone.run(() => s.next({ target: l.target, isAutofilled: !0 }))) }; return this._ngZone.runOutsideAngular(() => { i.addEventListener("animationstart", a, OA), i.classList.add("cdk-text-field-autofill-monitored") }), this._monitoredElements.set(i, { subject: s, unlisten: () => { i.removeEventListener("animationstart", a, OA) } }), s } stopMonitoring(e) { const i = vi(e), r = this._monitoredElements.get(i); r && (r.unlisten(), r.subject.complete(), i.classList.remove("cdk-text-field-autofill-monitored"), i.classList.remove("cdk-text-field-autofilled"), this._monitoredElements.delete(i)) } ngOnDestroy() { this._monitoredElements.forEach((e, i) => this.stopMonitoring(i)) } } return n.\u0275fac = function (e) { return new (e || n)(m(Ce), m(H)) }, n.\u0275prov = E({ factory: function () { return new n(m(Ce), m(H)) }, token: n, providedIn: "root" }), n })(), PA = (() => { class n { } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275mod = ee({ type: n }), n.\u0275inj = X({ imports: [[xa]] }), n })(); const hz = new k("MAT_INPUT_VALUE_ACCESSOR"), pz = ["button", "checkbox", "file", "hidden", "image", "radio", "range", "reset", "submit"]; let gz = 0; const mz = m$(class { constructor(n, t, e, i) { this._defaultErrorStateMatcher = n, this._parentForm = t, this._parentFormGroup = e, this.ngControl = i } }); let _z = (() => { class n extends mz { constructor(e, i, r, s, o, a, l, c, u, d) { super(a, s, o, r), this._elementRef = e, this._platform = i, this._autofillMonitor = c, this._formField = d, this._uid = "mat-input-" + gz++, this.focused = !1, this.stateChanges = new ie, this.controlType = "mat-input", this.autofilled = !1, this._disabled = !1, this._required = !1, this._type = "text", this._readonly = !1, this._neverEmptyInputTypes = ["date", "datetime", "datetime-local", "month", "time", "week"].filter(p => _D().has(p)); const f = this._elementRef.nativeElement, h = f.nodeName.toLowerCase(); this._inputValueAccessor = l || f, this._previousNativeValue = this.value, this.id = this.id, i.IOS && u.runOutsideAngular(() => { e.nativeElement.addEventListener("keyup", p => { const y = p.target; !y.value && 0 === y.selectionStart && 0 === y.selectionEnd && (y.setSelectionRange(1, 1), y.setSelectionRange(0, 0)) }) }), this._isServer = !this._platform.isBrowser, this._isNativeSelect = "select" === h, this._isTextarea = "textarea" === h, this._isInFormField = !!d, this._isNativeSelect && (this.controlType = f.multiple ? "mat-native-select-multiple" : "mat-native-select") } get disabled() { return this.ngControl && null !== this.ngControl.disabled ? this.ngControl.disabled : this._disabled } set disabled(e) { this._disabled = Te(e), this.focused && (this.focused = !1, this.stateChanges.next()) } get id() { return this._id } set id(e) { this._id = e || this._uid } get required() { return this._required } set required(e) { this._required = Te(e) } get type() { return this._type } set type(e) { this._type = e || "text", this._validateType(), !this._isTextarea && _D().has(this._type) && (this._elementRef.nativeElement.type = this._type) } get value() { return this._inputValueAccessor.value } set value(e) { e !== this.value && (this._inputValueAccessor.value = e, this.stateChanges.next()) } get readonly() { return this._readonly } set readonly(e) { this._readonly = Te(e) } ngAfterViewInit() { this._platform.isBrowser && this._autofillMonitor.monitor(this._elementRef.nativeElement).subscribe(e => { this.autofilled = e.isAutofilled, this.stateChanges.next() }) } ngOnChanges() { this.stateChanges.next() } ngOnDestroy() { this.stateChanges.complete(), this._platform.isBrowser && this._autofillMonitor.stopMonitoring(this._elementRef.nativeElement) } ngDoCheck() { this.ngControl && this.updateErrorState(), this._dirtyCheckNativeValue(), this._dirtyCheckPlaceholder() } focus(e) { this._elementRef.nativeElement.focus(e) } _focusChanged(e) { e !== this.focused && (this.focused = e, this.stateChanges.next()) } _onInput() { } _dirtyCheckPlaceholder() { var e, i; const r = (null === (i = null === (e = this._formField) || void 0 === e ? void 0 : e._hideControlPlaceholder) || void 0 === i ? void 0 : i.call(e)) ? null : this.placeholder; if (r !== this._previousPlaceholder) { const s = this._elementRef.nativeElement; this._previousPlaceholder = r, r ? s.setAttribute("placeholder", r) : s.removeAttribute("placeholder") } } _dirtyCheckNativeValue() { const e = this._elementRef.nativeElement.value; this._previousNativeValue !== e && (this._previousNativeValue = e, this.stateChanges.next()) } _validateType() { pz.indexOf(this._type) } _isNeverEmpty() { return this._neverEmptyInputTypes.indexOf(this._type) > -1 } _isBadInput() { let e = this._elementRef.nativeElement.validity; return e && e.badInput } get empty() { return !(this._isNeverEmpty() || this._elementRef.nativeElement.value || this._isBadInput() || this.autofilled) } get shouldLabelFloat() { if (this._isNativeSelect) { const e = this._elementRef.nativeElement, i = e.options[0]; return this.focused || e.multiple || !this.empty || !!(e.selectedIndex > -1 && i && i.label) } return this.focused || !this.empty } setDescribedByIds(e) { e.length ? this._elementRef.nativeElement.setAttribute("aria-describedby", e.join(" ")) : this._elementRef.nativeElement.removeAttribute("aria-describedby") } onContainerClick() { this.focused || this.focus() } } return n.\u0275fac = function (e) { return new (e || n)(g(O), g(Ce), g(yi, 10), g(wa, 8), g(Bc, 8), g(fM), g(hz, 10), g(NA), g(H), g(RA, 8)) }, n.\u0275dir = C({ type: n, selectors: [["input", "matInput", ""], ["textarea", "matInput", ""], ["select", "matNativeControl", ""], ["input", "matNativeControl", ""], ["textarea", "matNativeControl", ""]], hostAttrs: [1, "mat-input-element", "mat-form-field-autofill-control"], hostVars: 9, hostBindings: function (e, i) { 1 & e && ye("focus", function () { return i._focusChanged(!0) })("blur", function () { return i._focusChanged(!1) })("input", function () { return i._onInput() }), 2 & e && (Ll("disabled", i.disabled)("required", i.required), Qe("id", i.id)("data-placeholder", i.placeholder)("readonly", i.readonly && !i._isNativeSelect || null)("aria-invalid", i.empty && i.required ? null : i.errorState)("aria-required", i.required), je("mat-input-server", i._isServer)) }, inputs: { id: "id", disabled: "disabled", required: "required", type: "type", value: "value", readonly: "readonly", placeholder: "placeholder", errorStateMatcher: "errorStateMatcher", userAriaDescribedBy: ["aria-describedby", "userAriaDescribedBy"] }, exportAs: ["matInput"], features: [ae([{ provide: Fg, useExisting: n }]), D, nt] }), n })(), yz = (() => { class n { } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275mod = ee({ type: n }), n.\u0275inj = X({ providers: [fM], imports: [[PA, kA, at], PA, kA] }), n })(); function vz(n, t) { 1 & n && (x(0, "span"), oe(1), M()), 2 & n && (B(1), ln(" ", "00", " ")) } function bz(n, t) { if (1 & n && (x(0, "span"), oe(1), M()), 2 & n) { const e = He(); B(1), ln(" ", e.minutes, " ") } } function Cz(n, t) { if (1 & n && (x(0, "span"), oe(1), M()), 2 & n) { const e = He(); B(1), ln(" ", "0" + e.minutes, " ") } } function wz(n, t) { 1 & n && (x(0, "span"), oe(1), M()), 2 & n && (B(1), ln(" ", "00", " ")) } function Ez(n, t) { if (1 & n && (x(0, "span"), oe(1), M()), 2 & n) { const e = He(); B(1), ln(" ", e.seconds, " ") } } function Dz(n, t) { if (1 & n && (x(0, "span"), oe(1), M()), 2 & n) { const e = He(); B(1), ln(" ", "0" + e.seconds, " ") } } function xz(n, t) { 1 & n && (x(0, "mat-icon", 5), oe(1, " timer "), M()) } function Mz(n, t) { 1 & n && Ye(0, "mat-icon", 5) } const Az = function () { return { "small-timer-text": !0, "medium-timer-text": !1, "large-timer-text": !1 } }, Sz = function () { return { "small-timer-text": !1, "medium-timer-text": !0, "large-timer-text": !1 } }, Tz = function () { return { "small-timer-text": !1, "medium-timer-text": !1, "large-timer-text": !0 } }; let Iz = (() => { class n { constructor() { this.onEndOfGame = new ge, this.minutes = this.defaultMinutes, this.seconds = this.defaultSeconds } ngOnInit() { this.startTimer() } startTimer() { clearInterval(), setInterval(() => { console.log(this.gameState.get()), 1 == this.active && "active" == this.gameState.get() ? this.decrementSecond() : "reset" == this.gameState.get() ? (this.stopTimer(), this.resetClock()) : ("paused" == this.gameState.get() || "ended" == this.gameState.get()) && this.stopTimer() }, 1e3) } stopTimer() { clearInterval() } resetClock() { this.minutes = this.defaultMinutes, this.seconds = this.defaultSeconds } decrementSecond() { this.seconds > 0 ? this.seconds-- : this.minutes > 0 ? (this.seconds = 59, this.minutes--) : (clearInterval(), this.onEndOfGame.emit("ended")) } } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275cmp = tt({ type: n, selectors: [["app-player-timer"]], inputs: { active: "active", playerName: "playerName", gameState: "gameState", defaultMinutes: "defaultMinutes", defaultSeconds: "defaultSeconds" }, outputs: { onEndOfGame: "onEndOfGame" }, decls: 16, vars: 15, consts: [["fxLayout", "row", "fxLayoutAlign", "center"], [3, "ngClass.lt-sm", "ngClass.sm", "ngClass.gt-sm"], [4, "ngIf"], ["fxLayout", "row", "fxLayoutAlign", "center", 2, "margin-top", "15%"], ["aria-hidden", "false", "aria-label", "Timer icon", "style", "font-size: 50px; width: 50px;", 4, "ngIf"], ["aria-hidden", "false", "aria-label", "Timer icon", 2, "font-size", "50px", "width", "50px"]], template: function (e, i) { 1 & e && (x(0, "h1", 0), x(1, "b"), oe(2), M(), M(), x(3, "mat-card"), x(4, "h1", 1), Ee(5, vz, 2, 1, "span", 2), Ee(6, bz, 2, 1, "span", 2), Ee(7, Cz, 2, 1, "span", 2), x(8, "span"), oe(9, " : "), M(), Ee(10, wz, 2, 1, "span", 2), Ee(11, Ez, 2, 1, "span", 2), Ee(12, Dz, 2, 1, "span", 2), M(), M(), x(13, "h1", 3), Ee(14, xz, 2, 0, "mat-icon", 4), Ee(15, Mz, 1, 0, "mat-icon", 4), M()), 2 & e && (B(2), ln(" ", i.playerName, " "), B(2), K("ngClass.lt-sm", Zn(12, Az))("ngClass.sm", Zn(13, Sz))("ngClass.gt-sm", Zn(14, Tz)), B(1), K("ngIf", !i.minutes), B(1), K("ngIf", !!i.minutes && i.minutes >= 10), B(1), K("ngIf", !!i.minutes && i.minutes < 10), B(3), K("ngIf", !i.seconds), B(1), K("ngIf", i.seconds && i.seconds >= 10), B(1), K("ngIf", i.seconds && i.seconds < 10), B(2), K("ngIf", 1 == i.active), B(1), K("ngIf", 0 == i.active)) }, directives: [Tg, Ig, xA, wu, js, vA], styles: [".small-timer-text[_ngcontent-%COMP%]{font-size:3em}.medium-timer-text[_ngcontent-%COMP%]{font-size:3.5em}.large-timer-text[_ngcontent-%COMP%]{font-size:4em}"] }), n })(); function Fz(n, t) { if (1 & n) { const e = pr(); x(0, "div", 18), x(1, "button", 19), ye("click", function () { return ai(e), He().startGame() }), oe(2, "Start"), M(), M() } } function Rz(n, t) { if (1 & n) { const e = pr(); x(0, "div", 18), x(1, "button", 20), ye("click", function () { return ai(e), He().pauseGame() }), oe(2, "Pause"), M(), x(3, "button", 21), ye("click", function () { return ai(e), He().resetGame() }), oe(4, "Reset"), M(), M() } } function kz(n, t) { if (1 & n) { const e = pr(); x(0, "div", 18), x(1, "button", 22), ye("click", function () { return ai(e), He().startGame() }), oe(2, "Resume"), M(), x(3, "button", 21), ye("click", function () { return ai(e), He().resetGame() }), oe(4, "Reset"), M(), M() } } function Oz(n, t) { if (1 & n) { const e = pr(); x(0, "div", 18), x(1, "button", 21), ye("click", function () { return ai(e), He().resetGame() }), oe(2, "Reset"), M(), M() } } const LA = function () { return { standalone: !0 } }, Nz = function () { return { "custom-button-container-mobile-sm": !0, "custom-button-container-mobile-md": !1, "custom-button-container-mobile-lg": !1 } }, Pz = function () { return { "custom-button-container-mobile-sm": !1, "custom-button-container-mobile-md": !0, "custom-button-container-mobile-lg": !1 } }, Lz = function () { return { "custom-button-container-mobile-sm": !1, "custom-button-container-mobile-md": !1, "custom-button-container-mobile-lg": !0 } }; let Vz = (() => { class n { constructor(e) { this._snackbar = e, this.title = "chess-clock", this.gameState = new M2("reset"), this.key = "", this.player1TimerActive = !0, this.player2TimerActive = !1, this.defaultMinutes = 5, this.defaultSeconds = 0 } handleKeyboardEvent(e) { this.key = e.key, ("Enter" === this.key || " " === this.key) && this.switchTimers() } validateIsKeyPressNumber(e, i) { switch (this.key = e.key, console.log(e.key), e.key) { case "0": case "1": case "2": case "3": case "4": case "5": case "6": case "7": case "8": case "9": switch (i) { case "minutes": return e.target.value && (this.defaultMinutes = parseInt(e.target.value)), console.log(this.defaultMinutes), !0; case "seconds": return e.target.value && (this.defaultSeconds = parseInt(e.target.value)), console.log(this.defaultSeconds), !0; default: return console.error("Not sure how you got here, it should be one of the above!"), !1 }default: return e.preventDefault(), console.log(this.key), !1 } } openSnackBar(e, i) { this._snackbar.open(e, i) } closeSnackBar() { this._snackbar.dismiss() } switchTimers() { this.player1TimerActive = !this.player1TimerActive, this.player2TimerActive = !this.player2TimerActive } startGame() { this.gameState.set("active") } resetGame() { this.closeSnackBar(), this.gameState.set("reset") } pauseGame() { this.gameState.set("paused") } endGame(e) { this.gameState.set("ended"), this.openSnackBar("Timer complete!", "Close"), console.log(e) } } return n.\u0275fac = function (e) { return new (e || n)(g(o3)) }, n.\u0275cmp = tt({ type: n, selectors: [["app-root"]], hostBindings: function (e, i) { 1 & e && ye("keydown", function (s) { return i.handleKeyboardEvent(s) }, !1, __) }, decls: 48, vars: 28, consts: [["name", "body"], ["name", "content", "fxLayout", "column", "fxLayoutGap.lt-sm", "7.5%", "fxLayoutGap.sm", "5%", "fxLayoutGap.gt-sm", "2.5%"], ["fxLayout.lt-sm", "column", "fxLayout.gt-xs", "row", "fxLayoutAlign.lt-sm", "center", "fxLayoutAlign.gt-xs", "space-around"], [2, "opacity", "0.75"], ["appearance", "fill"], ["type", "number", "matInput", "", "placeholder", "Number of Minutes", 3, "value", "ngModel", "ngModelOptions", "ngModelChange", "keypress"], ["type", "number", "matInput", "", "placeholder", "Number of Seconds", 3, "value", "ngModel", "ngModelOptions", "ngModelChange", "keypress"], ["fxHide.lt-md", ""], ["mat-raised-button", "", "onclick", "this.blur()", 3, "click"], ["fxLayout", "row", "fxLayoutAlign", "center"], ["name", "desktop-message", "fxHide.lt-md", "", 2, "margin", "0", "opacity", "0.75"], ["name", "mobile-message", "fxHide.gt-sm", "", 2, "margin", "0", "opacity", "0.75"], ["fxLayout", "row", "fxLayoutAlign", "space-around"], [3, "playerName", "active", "defaultMinutes", "defaultSeconds", "gameState", "onEndOfGame"], [3, "playerName", "active", "defaultMinutes", "defaultSeconds", "gameState"], ["fxLayout", "column", "fxLayoutAlign", "center", "fxLayoutGap.lt-md", "5%", 3, "ngClass.lt-sm", "ngClass.sm", "ngClass.gt-sm"], ["fxHide.gt-sm", "", "mat-raised-button", "", "onclick", "this.blur()", 1, "custom-button-md", "button-switch", 3, "click"], ["fxLayout", "column", "fxLayoutGap", "3%", 4, "ngIf"], ["fxLayout", "column", "fxLayoutGap", "3%"], ["mat-raised-button", "", "onclick", "this.blur()", 1, "custom-button-md", "button-start", 3, "click"], ["mat-raised-button", "", "onclick", "this.blur()", 1, "custom-button-md", "button-pause", 3, "click"], ["mat-raised-button", "", "onclick", "this.blur()", 1, "custom-button-md", "button-reset", 3, "click"], ["mat-raised-button", "", "onclick", "this.blur()", 1, "custom-button-md", "button-resume", 3, "click"]], template: function (e, i) { 1 & e && (x(0, "div", 0), Ye(1, "app-navbar"), x(2, "div", 1), x(3, "mat-card"), x(4, "form", 2), x(5, "div"), x(6, "mat-label", 3), oe(7, "Starting time:"), M(), M(), x(8, "div"), x(9, "mat-form-field", 4), x(10, "mat-label"), oe(11, "Minutes"), M(), x(12, "input", 5), ye("ngModelChange", function (s) { return i.defaultMinutes = s })("keypress", function (s) { return i.validateIsKeyPressNumber(s, "minutes") }), M(), M(), M(), x(13, "div"), x(14, "mat-form-field", 4), x(15, "mat-label"), oe(16, "Seconds"), M(), x(17, "input", 6), ye("ngModelChange", function (s) { return i.defaultSeconds = s })("keypress", function (s) { return i.validateIsKeyPressNumber(s, "seconds") }), M(), M(), M(), x(18, "div", 7), x(19, "button", 8), ye("click", function (s) { return i.switchTimers(), s.preventDefault() }), oe(20, " Switch starting player "), M(), M(), M(), x(21, "div", 9), x(22, "h4", 10), oe(23, "Press "), x(24, "b"), x(25, "kbd"), oe(26, "spacebar"), M(), M(), oe(27, " or "), x(28, "b"), x(29, "kbd"), oe(30, "enter"), M(), M(), oe(31, " to switch the timer to the other player! "), M(), x(32, "h4", 11), oe(33, "Tap "), x(34, "b"), oe(35, "Switch"), M(), oe(36, " to move the timer to the other player! "), M(), M(), M(), x(37, "div", 12), x(38, "app-player-timer", 13), ye("onEndOfGame", function (s) { return i.endGame(s) }), M(), Ye(39, "app-player-timer", 14), M(), x(40, "div", 15), x(41, "div", 9), x(42, "button", 16), ye("click", function () { return i.switchTimers() }), oe(43, "Switch"), M(), M(), Ee(44, Fz, 3, 0, "div", 17), Ee(45, Rz, 5, 0, "div", 17), Ee(46, kz, 5, 0, "div", 17), Ee(47, Oz, 3, 0, "div", 17), M(), M(), M()), 2 & e && (B(12), K("value", i.defaultMinutes)("ngModel", i.defaultMinutes)("ngModelOptions", Zn(23, LA)), B(5), K("value", i.defaultSeconds)("ngModel", i.defaultSeconds)("ngModelOptions", Zn(24, LA)), B(21), K("playerName", "Player 1")("active", i.player1TimerActive)("defaultMinutes", i.defaultMinutes)("defaultSeconds", i.defaultSeconds)("gameState", i.gameState), B(1), K("playerName", "Player 2")("active", i.player2TimerActive)("defaultMinutes", i.defaultMinutes)("defaultSeconds", i.defaultSeconds)("gameState", i.gameState), B(1), K("ngClass.lt-sm", Zn(25, Nz))("ngClass.sm", Zn(26, Pz))("ngClass.gt-sm", Zn(27, Lz)), B(4), K("ngIf", "reset" === i.gameState.get()), B(1), K("ngIf", "active" === i.gameState.get()), B(1), K("ngIf", "paused" === i.gameState.get()), B(1), K("ngIf", "ended" === i.gameState.get())) }, directives: [TU, Tg, wA, xA, HE, FE, wa, Ig, Rg, dz, pp, _z, Ic, IE, hp, QM, gg, Iz, wu, js], styles: [".custom-button-container-mobile-sm[_ngcontent-%COMP%]   div[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{padding:3% 7.5%;font-size:1.5em;width:30%;margin:auto}.custom-button-container-mobile-md[_ngcontent-%COMP%]   div[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{padding:3% 7.5%;font-size:1.5em;width:25%;margin:auto}.custom-button-container-mobile-lg[_ngcontent-%COMP%]   div[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{padding:3% 7.5%;font-size:1.5em;width:20%;margin:auto}.button-pause[_ngcontent-%COMP%]{background-color:#cea800;color:#fff}.button-reset[_ngcontent-%COMP%]{background-color:#a91409;color:#fff}.button-resume[_ngcontent-%COMP%]{background-color:#00bd7e;color:#fff}.button-start[_ngcontent-%COMP%]{background-color:#28a844;color:#fff}.button-switch[_ngcontent-%COMP%]{background-color:#0067bb;color:#fff}"] }), n })(), zA = (() => { class n { } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275mod = ee({ type: n }), n.\u0275inj = X({ imports: [[_g]] }), n })(), sW = (() => { class n { constructor(e, i) { Gs(i) && !e && console.warn("Warning: Flex Layout loaded on the server without FlexLayoutServerModule") } static withConfig(e, i = []) { return { ngModule: n, providers: e.serverLoaded ? [{ provide: Vn, useValue: Object.assign(Object.assign({}, yg), e) }, { provide: vg, useValue: i, multi: !0 }, { provide: Lr, useValue: !0 }] : [{ provide: Vn, useValue: Object.assign(Object.assign({}, yg), e) }, { provide: vg, useValue: i, multi: !0 }] } } } return n.\u0275fac = function (e) { return new (e || n)(m(Lr), m(bt)) }, n.\u0275mod = ee({ type: n }), n.\u0275inj = X({ imports: [[DA, tA, zA], DA, tA, zA] }), n })(), oW = (() => { class n { } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275mod = ee({ type: n, bootstrap: [Vz] }), n.\u0275inj = X({ providers: [], imports: [[ep, a$, sW, x2, EM, H8, AU, yz, IM, f3]] }), n })(); (function () { if (UC) throw new Error("Cannot enable prod mode after platform setup."); $C = !1 })(), AB().bootstrapModule(oW).catch(n => console.error(n)) } }, ro => { ro(ro.s = 565) }]);